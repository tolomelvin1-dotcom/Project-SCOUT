<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>S.C.O.U.T. Rover Mapping & Control (Data-Driven 3D)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script> 
<style>
/* BASE STYLING (Dark Theme) */
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #1e1e1e; color: #d4d4d4; }
.container { 
    max-width: 1700px; 
    margin: auto; 
    background: #2d2d30; 
    padding: 25px; 
    border-radius: 10px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.5); 
    display: flex; 
    flex-wrap: wrap; 
}

/* LAYOUT PANELS */
.controls-panel { flex: 1; min-width: 350px; padding-right: 20px; }
.map-panel { flex: 1; min-width: 450px; }
.photo-panel { flex: 1; min-width: 450px; padding-left: 20px; border-left: 1px solid #3c3c3c; }
.map-3d-panel { flex: 1; min-width: 450px; margin-top: 20px; }
.plant-analysis-panel { 
    flex-basis: 100%; /* Take full width */
    margin-top: 30px; 
    padding-top: 20px; 
    border-top: 1px solid #3c3c3c;
}

/* TYPOGRAPHY & HEADERS */
h1 { color: #569cd6; border-bottom: 3px solid #3c3c3c; padding-bottom: 10px; }
h2 { color: #4ec9b0; margin-top: 20px; }
h3 { color: #c8c8c8; margin-top: 10px; }
#status { font-weight: bold; color: #ffcc00; }
/* BUTTONS */
button { padding: 10px 15px; margin: 8px 5px; cursor: pointer; border: none; border-radius: 6px; font-weight: bold; transition: background-color 0.2s; }
.move-controls button { background-color: #569cd6; color: white; }
.arm-controls button { background-color: #6a9955; color: white; }
.camera-control button { background-color: #ce4257; color: white; }
.history-controls button { background-color: #ff9900; color: white; }

/* DATA DISPLAY */
.data-display { margin-top: 20px; padding: 15px; border: 1px solid #3c3c3c; border-radius: 6px; background-color: #252526; }
.data-row strong { display: inline-block; width: 140px; color: #9cdcfe; }

/* CANVAS MAP (2D) */
#roverMap { border: 3px solid #6a9955; background-color: #3d3d3d; display: block; margin: 20px auto 0; }
/* 3D MAP CANVAS */
#threeDContainer {
    width: 450px;
    height: 450px;
    border: 3px solid #569cd6;
    background-color: #1a1a1a;
    margin: 20px auto 0;
    display: block;
}

/* 4x4 PHOTO GRID STYLES */
#photoGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 5px;
    border: 2px solid #569cd6;
    max-width: 450px;
    margin: 20px auto;
    aspect-ratio: 1 / 1;
    background-color: #252526;
}
.grid-cell {
    background-color: #3d3d3d;
    border: 1px solid #4ec9b0;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    overflow: hidden;
    transition: background-color 0.1s;
}

/* Delete Photo Button Styles */
.delete-photo-btn {
    position: absolute;
    bottom: 2px;
    right: 2px;
    background-color: rgba(220, 53, 69, 0.8);
    color: white;
    border: none;
    border-radius: 3px;
    padding: 2px 5px;
    font-size: 10px;
    cursor: pointer;
    z-index: 20;
    line-height: 1;
    display: none; /* Hidden by default */
}
/* Show delete button only if there is a photo */
.grid-cell:has(.cell-photo) .delete-photo-btn {
    display: block;
}


/* NEW: Plant Analysis Grid Styles */
#plantAnalysisGrid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); /* Responsive grid for analysis cards */
    gap: 20px;
    margin-top: 15px;
}
.analysis-card {
    padding: 15px;
    border-radius: 8px;
    background-color: #3e3e42;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transition: box-shadow 0.2s;
}
.plant-id-label {
    font-size: 1.4em;
    font-weight: bold;
    color: #ffd700; /* Gold */
    border-bottom: 2px solid #555;
    padding-bottom: 5px;
    margin-bottom: 10px;
}
.status-good { color: #9cdcfe; } /* Blue for status labels */

/* Recommendation coloring */
.rec-optimal, .rec-action, .rec-critical { 
    /* Fix: Ensure text displays fully and wraps */
    padding: 5px; 
    border-radius: 4px; 
    display: inline-block; 
    font-weight: bold;
    white-space: normal; /* Allow text to wrap naturally */
    word-break: break-word;
    width: 100%; /* Take full width of parent */
    box-sizing: border-box;
}
.rec-optimal { background-color: #28a745; color: white; }
.rec-action { background-color: #ffc107; color: black; }
.rec-critical { background-color: #dc3545; color: white; }

/* MODAL (History Viewer) STYLES */
.modal {
    display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7);
}
.modal-content {
    background-color: #2d2d30; margin: 10% auto; padding: 20px; border: 1px solid #3c3c3c; width: 80%; border-radius: 10px;
}
.close-btn {
    color: #aaa; float: right; font-size: 28px; font-weight: bold;
}
.close-btn:hover, .close-btn:focus {
    color: #fff; text-decoration: none; cursor: pointer;
}
.trial-item {
    padding: 10px; margin-bottom: 5px; background-color: #252526; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;
}
.trial-item:hover { background-color: #404040; }
</style>
</head>
<body>
<div class="container">

    <div class="controls-panel">
        <h1>S.C.O.U.T. Rover Control</h1>
        <p>System Status: <span id="status">Connecting...</span></p>

        <div class="data-display history-controls">
            <h2>Trial Management  üíæ </h2>
            <div class="data-row"><strong>Current Trial:</strong> <span id="currentTrialNumber">1</span></div>
            <p>
                <button onclick="saveCurrentTrial()"> üíæ  Save Trial Data</button>
                <button onclick="openHistoryModal()"> üìÖ  View History</button>
            </p>
            <p><small>Saved trials are stored in your browser's local storage.</small></p>
        </div>

        <div class="move-controls">
            <h2>Rover Movement</h2>
            <button onclick="sendCommand('forward')">Forward (‚Üë)</button>
            <button onclick="sendCommand('stop')"> üõë  STOP</button>
            <button onclick="sendCommand('backward')">Backward (‚Üì)</button><br>
            <button onclick="sendCommand('left')">Left (‚Üê)</button>
            <button onclick="sendCommand('right')">Right (‚Üí)</button>
        </div>
        <hr style="border-top: 1px solid #3c3c3c;">
        <div class="arm-controls">
            <h2>Data Acquisition</h2>
            <button onclick="sendCommand('probe')"> üî¨  Probe Soil (Arm Down)</button>
            <button onclick="sendCommand('read_sensors')"> üíß  Read Soil Data</button>
            <button onclick="sendCommand('read_nav')"> üß≠  Get GPS/Heading</button>
        </div>
        <hr style="border-top: 1px solid #3c3c3c;">
        <div class="data-display">
            <h2>Live Sensor Data</h2>

            <h3>Navigation Data</h3>
            <div class="data-row"><strong>Latitude:</strong> <span id="latitudeData">N/A</span></div>
            <div class="data-row"><strong>Longitude:</strong> <span id="longitudeData">N/A</span></div>
            <div class="data-row"><strong>GPS Fix:</strong> <span id="gpsFix">No Fix</span></div>
            <div class="data-row"><strong>Heading:</strong> <span id="headingData">N/A</span></div>
            <h3>Soil Data</h3>
            <div class="data-row"><strong>Moisture:</strong> <span id="moistureData">N/A</span></div>
            <div class="data-row"><strong>NPK (N, P, K):</strong> <span id="npkData">N/A</span></div>
        </div>
    </div>

    <div class="map-panel">
        <h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
        <canvas id="roverMap" width="450" height="450"></canvas>
        <p>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Health}$. $\text{Triangle} = \text{Rover}$.</p>
        <button onclick="clearMapData()"> üóë Ô∏è Clear Map Data</button>
    </div>

    <div class="map-3d-panel">
        <h2>3D Soil Metric Visualization  üìä </h2>
        <div id="threeDContainer"></div>
        <div class="three-d-controls">
            <p>Bar Height = Soil Moisture %. Bar Color = Plant Health (Green/Yellow/Red).</p>
        </div>
    </div>

    <div class="photo-panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')"> üì∏  Take Photo (to Dell Wyse)</button>
            <button onclick="loadStockPhotos()"> üñº Ô∏è Load Stock Photos</button>
            <p>Last photo status: <span id="lastPhotoStatus">N/A</span>. Sent to Dell Wyse server at <span id="server-ip">192.168.X.X:5000</span>.</p>
        </div>
        <hr style="border-top: 1px solid #3c3c3c;">
        <h2>Manual Photo Upload Map (Zones 1-16)</h2>
        <p>Click a zone below to upload/replace the photo. Click the **X** to delete it. **Photo presence triggers AI analysis.**</p>
        <div id="photoGrid">
        </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
    </div>

    <div class="plant-analysis-panel">
        <h2>Plant-Specific AI Analysis (16 Zones) üî¨</h2>
        <p>This grid shows the fused analysis of **Leaf Photo (Simulated $\text{AI}$)** + **Local Soil Data ($\text{NPK}$/Moisture)** for all plant zones.</p>
        <div id="plantAnalysisGrid">
            </div>
    </div>
</div>

<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
        <h2>Saved Trial History</h2>
        <div id="trialHistoryList">
        </div>
        <hr style="border-top: 1px solid #3c3c3c; margin-top: 15px;">
        <button onclick="clearAllHistory()" style="background-color: #dc3545;"> üö®  Clear All Saved Trials</button>
    </div>
</div>

<script>
// JAVASCRIPT LOGIC

// !!! CONFIGURE YOUR IPs HERE !!!
const ESP32_IP = '192.168.1.50';
const DELL_WYSE_IP = 'http://192.168.X.X:5000';

const ESP32_URL_BASE = `http://${ESP32_IP}`;
const STATUS_ELEMENT = document.getElementById('status');
const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');

document.getElementById('server-ip').innerText = DELL_WYSE_IP.replace('http://', '');

// --- GLOBAL CONSTANTS ---
const FIELD_SIZE = 4;
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 450;
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100;

// Plant locations in meters (16 zones)
const PLANT_LOCATIONS_M = [];
for(let r=0; r<FIELD_SIZE; r++) for(let c=0; c<FIELD_SIZE; c++) PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5, id: (r * FIELD_SIZE) + c + 1});

// Global Data Structures
let loggedData = []; // Stores sensor data {x_m, y_m, moisture, npk_n, npk_p, npk_k, healthStatus}
let photoData = {}; // Stores {zoneId: base64Image}
let selectedZone = 0;
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;

let currentRoverData = {
    latitude: 'N/A',
    longitude: 'N/A',
    heading: 0,
    x_m: 2.0,
    y_m: 2.0
};

// --- MOCK AI PARAMETERS ---
const PHOTO_DISEASES = [
    { name: "Healthy", probability: 0.70 },
    { name: "Early Blight", probability: 0.15 },
    { name: "Septoria Leaf Spot", probability: 0.10 },
    { name: "Bacterial Spot", probability: 0.05 },
];

// --- 3D RENDERING SETUP (THREE.JS) ---
let scene, camera, renderer, rover3D, controls;
let dataCubes = {}; // Holds the 3D cubes for data visualization

function initThreeD() {
    const container = document.getElementById('threeDContainer');
    const width = container.clientWidth;
    const height = container.clientHeight;
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
    camera.position.set(2, 6, 2);
    camera.lookAt(2, 0, 2);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 10;
    controls.maxPolarAngle = Math.PI / 2.2;

    const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
    gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2);
    scene.add(gridHelper);

    const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
    const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
    rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
    rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m);
    scene.add(rover3D);

    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    if(controls) controls.update();
    renderer.render(scene, camera);
}

function updateRover3DPosition() {
    if (rover3D) {
        rover3D.position.set(
            parseFloat(currentRoverData.x_m),
            0.05,
            parseFloat(currentRoverData.y_m)
        );
        rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
    }
}
function clear3DDataCubes() {
    Object.values(dataCubes).forEach(cube => {
        scene.remove(cube);
        cube.geometry.dispose();
        cube.material.dispose();
    });
    dataCubes = {};
}
function getHealthColorHex(status) {
    switch (status) {
        case 'Good': return 0x28a745; // Green
        case 'Caution': return 0xffc107; // Yellow
        case 'Bad': return 0xdc3545; // Red
        default: return 0x5a5a5a;
    }
}

function draw3DMap() {
    clear3DDataCubes();
    loggedData.forEach((data, index) => {
        const { x_m, y_m, moisture, healthStatus } = data;
        const cubeWidth = 0.5;
        const cubeDepth = 0.5;
        const cubeHeight = Math.max(0.01, moisture / MAX_MOISTURE);
        const colorHex = getHealthColorHex(healthStatus);

        const geometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
        const material = new THREE.MeshPhongMaterial({
            color: colorHex,
            opacity: 0.8,
            transparent: true
        });
        const cube = new THREE.Mesh(geometry, material);

        cube.position.set(
            x_m,
            cubeHeight / 2,
            y_m
        );
        cube.name = `data-cube-${index}`;
        dataCubes[index] = cube;
        scene.add(cube);
    });

    updateRover3DPosition();
}
// ------------------------------------
// --- PHOTO GRID FUNCTIONS ---
// ------------------------------------
function loadStockPhotos() {
    for (let i = 1; i <= 16; i++) {
        const color = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        const stockImage = `<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="${color}"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="20" fill="#fff">Zone ${i}</text></svg>`;
        const base64StockImage = 'data:image/svg+xml;base64,' + btoa(stockImage);
        photoData[i] = base64StockImage;
        renderPhotoInCell(i, base64StockImage);
    }
    LAST_PHOTO_STATUS.innerText = '16 stock photos loaded.';
    fetchAIResults(); // Trigger analysis after loading photos
}

function deletePhoto(zoneId) {
    if (!photoData[zoneId]) return;
    delete photoData[zoneId];
    renderPhotoInCell(zoneId, null);
    STATUS_ELEMENT.innerText = `Photo deleted from Zone ${zoneId}.`;
    fetchAIResults(); // Trigger analysis after deleting photo
}

function generatePhotoGrid() {
    const grid = document.getElementById('photoGrid');
    for (let i = 1; i <= 16; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.id = 'zone-' + i;
        cell.innerHTML = `
            <span class="cell-label">${i}</span>
            <button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>
        `;

        cell.addEventListener('click', function(e) {
            // Check if the click target is the delete button itself before triggering upload
            if (e.target.className !== 'delete-photo-btn') {
                selectedZone = i;
                document.getElementById('fileInput').click();
            }
        });

        grid.appendChild(cell);
    }
    loadCurrentPhotoData();
}
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file || selectedZone === 0) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const base64Image = e.target.result;
        photoData[selectedZone] = base64Image;
        renderPhotoInCell(selectedZone, base64Image);
        selectedZone = 0;
        
        // FIX: Clear the file input value so that selecting a new file on a different zone works
        event.target.value = '';
        
        fetchAIResults(); // Trigger AI analysis after uploading photo
    };
    reader.readAsDataURL(file);
}
function renderPhotoInCell(zoneId, base64Image) {
    const cell = document.getElementById('zone-' + zoneId);
    if (!cell) return;
    const existingPhoto = cell.querySelector('.cell-photo');
    if (existingPhoto) existingPhoto.remove();
    if (base64Image) {
        const img = document.createElement('img');
        img.src = base64Image;
        img.className = 'cell-photo';
        cell.appendChild(img);
    }
}
function clearPhotoGrid() {
    for (let i = 1; i <= 16; i++) {
        renderPhotoInCell(i, null);
    }
}

function loadCurrentPhotoData() {
    clearPhotoGrid();
    for (const [zoneId, base64Image] of Object.entries(photoData)) {
        renderPhotoInCell(parseInt(zoneId), base64Image);
    }
}
// ------------------------------------
// --- COMBINED AI ANALYSIS LOGIC ---
// ------------------------------------

// FIX: Deterministic pseudo-random function using Zone ID as a seed for consistent results
function deterministicPseudoRandom(seed) {
    let x = Math.sin(seed * 10000);
    return x - Math.floor(x);
}

function getNearestSensorData(plantX, plantY) {
    let nearestData = null;
    let min_dist_sq = Infinity;
    loggedData.forEach(data => {
        let dx = data.x_m - plantX;
        let dy = data.y_m - plantY;
        let dist_sq = dx * dx + dy * dy;
        // Only consider data within the same 1m x 1m grid cell (0.707m is max dist to center)
        if (dist_sq < 0.707 * 0.707 && dist_sq < min_dist_sq) {
            min_dist_sq = dist_sq;
            nearestData = data;
        }
    });
    return nearestData;
}

function analyzePlant(plant, sensorData, photoExists) {
    let diagnosis = "No Data";
    let recommendation = "Conduct full sensor probe and capture leaf photo.";
    let totalScore = 100;

    // --- 1. Photo Analysis (Simulated AI) ---
    let visualDiagnosis = "Visual: Healthy Leaf";
    let visualAction = "";
    if (photoExists) {
        // Use the deterministic function based on plant.id (Zone ID)
        const randomRoll = deterministicPseudoRandom(plant.id); 
        let cumulativeProb = 0;
        let prediction = PHOTO_DISEASES[0]; // Default to Healthy

        for (const disease of PHOTO_DISEASES) {
            cumulativeProb += disease.probability;
            if (randomRoll <= cumulativeProb) {
                prediction = disease;
                break;
            }
        }

        visualDiagnosis = `Visual: ${prediction.name}`;
        if (prediction.name !== "Healthy") {
            totalScore -= 40;
            visualAction = `Immediate visual confirmation required. Apply ${prediction.name} specific fungicide.`;
        }
    } else {
        totalScore -= 5; // Small penalty for missing visual data
        visualDiagnosis = "Visual: No Photo";
    }

    // --- 2. Sensor Analysis (NPK/Moisture) ---
    let sensorAction = "";
    if (sensorData) {
        const { moisture, npk_n, npk_p, npk_k } = sensorData;
        
        // Moisture Check
        if (moisture < 25) { totalScore -= 20; sensorAction += "CRITICAL LOW MOISTURE. Immediate deep watering. "; } 
        else if (moisture < 40) { totalScore -= 10; sensorAction += "Low moisture. Increase irrigation. "; }
        
        // NPK Check (Example: Ideal sum around 150)
        let npk_sum = npk_n + npk_p + npk_k;
        if (npk_sum < 100) { totalScore -= 15; sensorAction += "Severe NPK deficiency. Apply balanced fertilizer. "; }
        else if (npk_sum < 150) { totalScore -= 5; sensorAction += "NPK low. Boost feed/foliar spray. "; }

        diagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;

    } else {
        totalScore -= 20; // Major penalty for missing sensor data
        diagnosis = "Soil: Sensor Data Missing";
        sensorAction = "REQUIRED: Conduct soil probe near this plant (Rover at Zone " + plant.id + ").";
    }

    // --- 3. Combined Recommendation ---
    recommendation = (visualAction + sensorAction).trim() || "Optimal: Continue monitoring.";

    // Final Health Classification
    let healthClass = 'rec-optimal';
    if (totalScore <= 60) healthClass = 'rec-critical';
    else if (totalScore <= 85) healthClass = 'rec-action';

    return {
        id: plant.id,
        score: Math.max(0, totalScore.toFixed(0)), // Max 100, Min 0
        visualDiagnosis: visualDiagnosis,
        sensorDiagnosis: diagnosis,
        recommendation: recommendation,
        healthClass: healthClass
    };
}


function fetchAIResults() {
    const analysisGrid = document.getElementById('plantAnalysisGrid');
    analysisGrid.innerHTML = ''; // Clear previous results

    PLANT_LOCATIONS_M.forEach(plant => {
        const sensorData = getNearestSensorData(plant.x, plant.y);
        const photoExists = !!photoData[plant.id];
        
        const analysis = analyzePlant(plant, sensorData, photoExists);
        
        // FIX: Display the full recommendation text without truncation
        const recLabel = analysis.recommendation; 

        const card = `
            <div class="analysis-card">
                <div class="plant-id-label">Zone ${analysis.id} (P${Math.ceil(plant.id/4)}R${(plant.id-1)%4 + 1})</div>
                <div class="analysis-row">
                    <strong>Composite Score:</strong> <span class="status-good">${analysis.score}/100</span>
                </div>
                <div class="analysis-row">
                    <strong>Leaf Analysis:</strong> ${analysis.visualDiagnosis}
                </div>
                <div class="analysis-row">
                    <strong>Soil Analysis:</strong> ${analysis.sensorDiagnosis}
                </div>
                <div class="analysis-row" style="margin-top: 10px;">
                    <strong>Recommendation:</strong> <span class="${analysis.healthClass}">${recLabel}</span>
                </div>
            </div>
        `;
        analysisGrid.insertAdjacentHTML('beforeend', card);
    });

    STATUS_ELEMENT.innerText = `AI Analysis Complete: ${PLANT_LOCATIONS_M.length} plants analyzed.`;
}

// ------------------------------------
// --- COMMUNICATION FUNCTIONS ---
// ------------------------------------

function sendCommand(command) {
    let url = (command === 'capture') ? `${ESP32_URL_BASE}/capture` : `${ESP32_URL_BASE}/move?dir=${command}`;

    STATUS_ELEMENT.innerText = `Sending command: ${command}...`;
    fetch(url)
    .then(response => {
        if (!response.ok) { throw new Error(`HTTP Error: ${response.status}`); }
        return response.text();
    })
    .then(data => {
        STATUS_ELEMENT.innerText = `Command '${command}' Success.`;
        if (command.startsWith('read_') || command === 'probe') {
            setTimeout(() => fetchData(command), 500);
        } else if (command === 'capture') {
            LAST_PHOTO_STATUS.innerText = 'Photo captured and sent to server.';
            // Assume rover is near a plant, simulate adding a photo for the nearest zone.
            const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
            if (nearestPlant) {
                // Mock image data that is distinguishable from stock photos
                photoData[nearestPlant.id] = `data:image/jpeg;base64,mocked_rover_capture_zone_${nearestPlant.id}`;
                renderPhotoInCell(nearestPlant.id, photoData[nearestPlant.id]);
            }
            setTimeout(() => fetchAIResults(), 1000);
        }
    })
    .catch(error => {
        STATUS_ELEMENT.innerText = `ERROR: Command ${command} failed. Is ESP32 at ${ESP32_IP} online?`;
        console.error('Error sending command:', error);
    });
}

function getNearestPlant(x, y) {
    let nearest = null;
    let minDistSq = Infinity;
    PLANT_LOCATIONS_M.forEach(plant => {
        let dx = plant.x - x;
        let dy = plant.y - y;
        let distSq = dx * dx + dy * dy;
        if (distSq < minDistSq) {
            minDistSq = distSq;
            nearest = plant;
        }
    });
    return nearest;
}

// --- MOCK/SIMULATED DATA FETCH (Called manually by 'read' buttons) ---
function fetchData(lastCommand = null) {
    STATUS_ELEMENT.innerText = "Fetching latest data...";

    setTimeout(() => {
        // --- Simulate GPS/Nav Data ---
        let headingStr = (Math.random() * 360).toFixed(1) + ' deg';
        currentRoverData.heading = parseFloat(headingStr.split(' ')[0]) || 0;
        currentRoverData.latitude = "40.7128";
        currentRoverData.longitude = "-74.0060";
        document.getElementById('latitudeData').innerText = currentRoverData.latitude;
        document.getElementById('longitudeData').innerText = currentRoverData.longitude;
        document.getElementById('gpsFix').innerText = "3D Fix";
        document.getElementById('headingData').innerText = headingStr;

        // Simulate Rover Movement (random walk)
        if (lastCommand !== 'read_nav' && lastCommand !== 'stop') {
            currentRoverData.x_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.x_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
            currentRoverData.y_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.y_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
        }

        // --- Simulate Soil Data ---
        let moistureVal = (Math.random() * 80 + 10).toFixed(1);
        let npk_n = Math.floor(Math.random() * 100);
        let npk_p = Math.floor(Math.random() * 100);
        let npk_k = Math.floor(Math.random() * 100);
        let moistureStr = moistureVal + '%';
        let npkStr = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
        document.getElementById('moistureData').innerText = moistureStr;
        document.getElementById('npkData').innerText = npkStr;

        if (lastCommand === 'probe' || lastCommand === 'read_sensors') {
            let healthStatus = analyzeHealth(parseFloat(moistureVal), npk_n, npk_p, npk_k);
            
            // Log the data to the global array at the current rover position
            loggedData.push({
                x_m: parseFloat(currentRoverData.x_m),
                y_m: parseFloat(currentRoverData.y_m),
                healthStatus: healthStatus,
                moisture: parseFloat(moistureVal),
                npk_n: npk_n, npk_p: npk_p, npk_k: npk_k
            });
            STATUS_ELEMENT.innerText = `Data logged! Status: ${healthStatus}`;
            fetchAIResults(); // Trigger analysis to update grid with new sensor data
        }

        drawMap();
        draw3DMap();
        STATUS_ELEMENT.innerText = "Data update complete.";
    }, 500);
}


// ------------------------------------
// --- 2D MAP LOGIC (for visualization only) ---
// ------------------------------------
function analyzeHealth(moisture, npk_n, npk_p, npk_k) {
    let issues = 0;
    const MIN_MOISTURE = 30;
    const IDEAL_NPK_SUM = 150;
    const NPK_TOLERANCE = 50;
    if (moisture < MIN_MOISTURE || moisture > 80) { issues++; }

    let npk_sum = npk_n + npk_p + npk_k;
    if (Math.abs(npk_sum - IDEAL_NPK_SUM) > NPK_TOLERANCE) { issues++; }
    if (issues >= 2) return 'Bad';
    if (issues === 1) return 'Caution';
    return 'Good';
}

function clearMapData(resetRover = true) {
    loggedData = [];
    photoData = {}; // Clear photos as well
    if (resetRover) {
        currentRoverData.x_m = 2.0;
        currentRoverData.y_m = 2.0;
        currentRoverData.heading = 0;
    }
    drawMap();
    draw3DMap();
    clearPhotoGrid(); // Clear photo grid display
    fetchAIResults(); // Update analysis grid to show no data
    STATUS_ELEMENT.innerText = "Map and photo data cleared.";
}

function drawMap() {
    CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE);

    // 1. Draw the 4x4 Grid
    CTX.strokeStyle = '#5a5a5a';
    CTX.lineWidth = 1;
    for (let i = 1; i < FIELD_SIZE; i++) {
        let px = i * PIXELS_PER_METER;
        CTX.beginPath(); CTX.moveTo(px, 0); CTX.lineTo(px, MAP_SIZE); CTX.stroke();
        CTX.beginPath(); CTX.moveTo(0, px); CTX.lineTo(MAP_SIZE, px); CTX.stroke();
    }
    
    // 2. Map Soil Condition (Background Squares)
    const GRID_SIZE_M = 1.0;
    for (let row = 0; row < FIELD_SIZE; row++) {
        for (let col = 0; col < FIELD_SIZE; col++) {
            let center_x_m = col * GRID_SIZE_M + 0.5;
            let center_y_m = row * GRID_SIZE_M + 0.5;
            let nearestData = getNearestSensorData(center_x_m, center_y_m);

            if (nearestData) {
                let moistureColor;
                if (nearestData.moisture < 20) { moistureColor = '#0070e040'; } // Low Moisture (Blue)
                else if (nearestData.moisture > 70) { moistureColor = '#80008040'; } // High Moisture (Purple)
                else { moistureColor = '#6a995540'; } // Optimal Moisture (Green)

                CTX.fillStyle = moistureColor;
                CTX.fillRect(
                    col * PIXELS_PER_METER,
                    MAP_SIZE - ((row + 1) * PIXELS_PER_METER),
                    PIXELS_PER_METER,
                    PIXELS_PER_METER
                );
            }
        }
    }

    // 3. Draw Plant Health Circles
    PLANT_LOCATIONS_M.forEach((plant, index) => {
        let px = plant.x * PIXELS_PER_METER;
        let py = MAP_SIZE - (plant.y * PIXELS_PER_METER);
        let nearestData = getNearestSensorData(plant.x, plant.y);
        let plantColor = nearestData ? getHealthColor(nearestData.healthStatus) : '#5a5a5a';

        CTX.fillStyle = plantColor;
        CTX.beginPath();
        CTX.arc(px, py, 6, 0, 2 * Math.PI);
        CTX.fill();

        if (nearestData && nearestData.healthStatus) {
            CTX.fillStyle = 'white';
            CTX.font = '10px Arial';
            CTX.fillText(nearestData.healthStatus.charAt(0), px - 3, py + 3);
        }
    });

    // 4. Draw Rover Position and Heading (Triangle)
    let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
    let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
    let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);
    CTX.fillStyle = '#9cdcfe';
    CTX.save();
    CTX.translate(rover_x_px, rover_y_px);
    CTX.rotate(heading_rad);
    CTX.beginPath();
    CTX.moveTo(10, 0);
    CTX.lineTo(-10, -8);
    CTX.lineTo(-10, 8);
    CTX.closePath();
    CTX.fill();
    CTX.restore();
    CTX.fillStyle = 'white';
    CTX.beginPath();
    CTX.arc(rover_x_px, rover_y_px, 3, 0, 2 * Math.PI);
    CTX.fill();
}

function getHealthColor(status) {
    switch (status) {
        case 'Good': return '#28a745';
        case 'Caution': return '#ffc107';
        case 'Bad': return '#dc3545';
        default: return '#5a5a5a';
    }
}
// ------------------------------------
// --- HISTORY & DATA SAVING FUNCTIONS ---
// ------------------------------------

function saveCurrentTrial() {
    const trialData = {
        id: currentTrialNumber,
        date: new Date().toLocaleString(),
        roverData: { ...currentRoverData },
        loggedData: [...loggedData],
        photoData: { ...photoData },
        aiData: { // Save the entire current analysis for history viewing
            analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML
        }
    };
    trialHistory.push(trialData);
    localStorage.setItem('trialHistory', JSON.stringify(trialHistory));

    STATUS_ELEMENT.innerText = `Trial ${currentTrialNumber} saved successfully! Starting new trial...`;

    // Reset for new trial
    loggedData = [];
    photoData = {};
    currentTrialNumber++;
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
    clearMapData(false);
    clearPhotoGrid();
    clear3DDataCubes();
    fetchAIResults(); // Clear the analysis grid too
    updateRover3DPosition();
}
function openHistoryModal() {
    const modal = document.getElementById('historyModal');
    const list = document.getElementById('trialHistoryList');
    list.innerHTML = '';
    if (trialHistory.length === 0) {
        list.innerHTML = '<p>No trials saved yet.</p>';
    } else {
        trialHistory.forEach(trial => {
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.innerHTML = `<strong>Trial ${trial.id}:</strong> ${trial.date} (${trial.loggedData.length} readings)`;
            item.onclick = () => loadPastTrial(trial.id);
            list.appendChild(item);
        });
    }
    modal.style.display = "block";
}
function closeHistoryModal() {
    document.getElementById('historyModal').style.display = "none";
}
function loadPastTrial(trialId) {
    const trial = trialHistory.find(t => t.id === trialId);
    if (!trial) return;
    
    // 1. Load Rover Data
    currentRoverData = trial.roverData;
    document.getElementById('latitudeData').innerText = trial.roverData.latitude;
    document.getElementById('longitudeData').innerText = trial.roverData.longitude;
    document.getElementById('headingData').innerText = trial.roverData.heading + ' deg';
    document.getElementById('gpsFix').innerText = 'Historical';

    // 2. Load Logged Data & Maps
    loggedData = trial.loggedData;
    drawMap();
    draw3DMap();

    // 3. Load Photo Data
    photoData = trial.photoData;
    loadCurrentPhotoData();

    // 4. Load AI Analysis Data
    document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;

    STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
    document.getElementById('currentTrialNumber').innerText = `${currentTrialNumber} (Viewing Trial ${trialId})`;
    closeHistoryModal();
}
function clearAllHistory() {
    if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
        localStorage.removeItem('trialHistory');
        trialHistory = [];
        currentTrialNumber = 1;
        document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
        closeHistoryModal();
        STATUS_ELEMENT.innerText = "All trial history cleared.";
    }
}
// --- Initialization ---
window.onload = function() {
    initThreeD();
    drawMap();
    generatePhotoGrid();
    fetchAIResults();
};
</script>
</body>
</html>
