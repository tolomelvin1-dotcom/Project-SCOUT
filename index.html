<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PROJECT S.C.O.U.T.: Fused AI & Rover Control Dashboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
/* --- 1. MODERNIZED STYLING & VARIABLE DEFINITIONS --- */
:root {
    --color-primary: #0078D4; /* Modern Blue for actions/highlights */
    --color-secondary: #4EC9B0; /* Teal/Cyan for headers */
    --color-background: #1F1F1F; /* Darkest Background */
    --color-card: #2D2D30; /* Card/Panel Background */
    --color-text: #E0E0E0;
    --color-border: #3C3C3C;
    --color-status-good: #6AA84F; /* Green */
    --color-status-caution: #FFC000; /* Yellow */
    --color-status-bad: #C55050; /* Red */
    --color-text-highlight: #9CDCFE;
}

/* BASE STYLING */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    background-color: var(--color-background);
    color: var(--color-text);
    line-height: 1.5;
}

/* HEADER & FOOTER */
.header-bar {
    background-color: #1E1E1E;
    color: var(--color-text);
    padding: 15px 40px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.header-bar h1 {
    margin: 0;
    color: var(--color-primary);
    font-size: 1.8em;
    font-weight: 300;
}

/* --- 2. GRID LAYOUT RESTORATION (2x3 Dashboard) --- */
.container {
    max-width: 1700px; /* Wider for 3 columns */
    margin: 20px auto;
    padding: 20px;
    border-radius: 10px;
    
    /* 3 Columns: 1 for controls, 2 for visuals/analysis */
    display: grid;
    /* Fixed control width, rest splits evenly */
    grid-template-columns: minmax(380px, 0.25fr) minmax(380px, 1fr) minmax(380px, 1fr);
    gap: 20px;
}

/* Panel Styles */
.panel {
    background: var(--color-card);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    overflow: hidden; /* prevents content from leaking */
}
.panel h2 {
    color: var(--color-secondary);
    font-weight: 400;
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 5px;
    margin-top: 0;
}

/* Specific Panel Locations (Reverting to a clearer flow) */
/* Controls panel spans column 1 and rows 1 & 2 */
.controls-data-panel { grid-column: 1 / 2; grid-row: 1 / 3; }
.map-2d-panel { grid-column: 2 / 3; grid-row: 1 / 2; }
.photo-panel { grid-column: 3 / 4; grid-row: 1 / 2; }
.map-3d-panel { grid-column: 2 / 3; grid-row: 2 / 3; }
.analysis-panel { grid-column: 3 / 4; grid-row: 2 / 3; }

/* DATA DISPLAY & BUTTONS */
.data-row { margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;}
.data-row strong { color: var(--color-text-highlight); font-weight: 500; min-width: 120px;}
.data-value { font-family: 'Consolas', monospace; color: var(--color-text); text-align: right;}
.section-divider { border-top: 1px solid var(--color-border); margin: 20px 0; }
button {
    padding: 10px 15px; margin: 5px 5px 5px 0; cursor: pointer; border: none;
    border-radius: 6px; font-weight: bold; transition: background-color 0.2s, box-shadow 0.2s;
}
.move-controls button { background-color: var(--color-primary); color: white; }
.arm-controls button { background-color: var(--color-status-good); color: white; }
.camera-control button { background-color: #C55050; color: white; } /* Dark Red */

/* MAPS */
#roverMap, #threeDContainer {
    width: 100%;
    /* Ensure maps are vertically aligned in their rows */
    height: 380px;
    background-color: #3d3d3d;
    border: 3px solid var(--color-primary);
    margin-top: 10px;
    display: block;
}
#threeDContainer { background-color: #1a1a1a; }

/* PHOTO GRID */
#photoGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 3px;
    max-width: 400px;
    margin: 15px auto;
    aspect-ratio: 1 / 1;
}
.grid-cell {
    border: 1px solid var(--color-border); background-color: #444; cursor: pointer;
    display: flex; justify-content: center; align-items: center; font-size: 0.9em;
    color: #bbb; position: relative; overflow: hidden;
}
.grid-cell img { width: 100%; height: 100%; object-fit: cover; }
.delete-photo-btn {
    position: absolute; bottom: 2px; right: 2px;
    background-color: rgba(220, 53, 69, 0.8); color: white; border: none;
    border-radius: 3px; padding: 2px 5px; font-size: 10px; cursor: pointer;
    z-index: 20; line-height: 1; display: none;
}
.grid-cell:has(.cell-photo) .delete-photo-btn { display: block; }


/* ANALYSIS CARDS */
#plantAnalysisGrid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 15px;
    margin-top: 15px;
    /* Limit height to match 3D map above */
    max-height: 480px;
    overflow-y: auto;
}
.analysis-card {
    padding: 15px; border-radius: 8px; background-color: #3e3e42; border-left: 5px solid;
}
.plant-id-label {
    font-size: 1.1em; font-weight: bold; color: var(--color-secondary);
    border-bottom: 1px dashed var(--color-border); padding-bottom: 5px; margin-bottom: 10px;
}
.rec-optimal { background-color: var(--color-status-good); color: white; }
.rec-action { background-color: var(--color-status-caution); color: black; }
.rec-critical { background-color: var(--color-status-bad); color: white; }

/* MODAL STYLES (basic) */
.modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); }
.modal-content { background-color: var(--color-card); margin: 5% auto; padding: 25px; border-radius: 10px; width: 80%; max-width: 1100px; max-height: 90vh; overflow-y: auto; }
.close { color: var(--color-text-highlight); float: right; font-size: 28px; font-weight: bold; }
#stockImageGrid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; padding: 10px;
}
#stockImageGrid img { width: 100%; height: 100px; object-fit: cover; border-radius: 5px; }
</style>
</head>
<body>
<div class="header-bar">
    <h1>PROJECT S.C.O.U.T.: Fused AI & Rover Control Dashboard</h1>
    <span id="status">System Initializing...</span>
</div>

<div class="container">

    <div class="panel controls-data-panel">
        <h2>Rover Control & Live ThingSpeak Data</h2>

        <div>
            <h3>Trial Management üíæ</h3>
            <div class="data-row">
                <strong>Current Trial:</strong> <span class="data-value" id="currentTrialNumber">1</span>
            </div>
            <button onclick="saveCurrentTrial()"> üíæ Save & New Trial</button>
            <button onclick="openHistoryModal()"> üìÖ View History</button>
        </div>

        <div class="section-divider"></div>

        <div class="move-controls">
            <h3>Rover Movement (Mock ESP32 Commands)</h3>
            <p>
                <button onclick="sendCommand('forward')">Forward (‚Üë)</button>
                <button onclick="sendCommand('stop')"> üõë STOP</button>
                <button onclick="sendCommand('backward')">Backward (‚Üì)</button><br>
                <button onclick="sendCommand('left')">Left (‚Üê)</button>
                <button onclick="sendCommand('right')">Right (‚Üí)</button>
            </p>
        </div>

        <div class="section-divider"></div>

        <div class="arm-controls">
            <h3>Data Acquisition</h3>
            <button onclick="sendCommand('probe')"> üî¨ Probe Soil (Arm Down)</button>
            <button onclick="fetchData('refresh')"> üì° Refresh ThingSpeak</button>
        </div>

        <div style="margin-top: 20px;">
            <h3>Live Sensor Data</h3>
            <div class="data-row"><strong>Latitude:</strong> <span id="latitudeData" class="data-value">N/A</span></div>
            <div class="data-row"><strong>Longitude:</strong> <span id="longitudeData" class="data-value">N/A</span></div>
            <div class="data-row"><strong>Heading:</strong> <span id="headingData" class="data-value">N/A</span></div>
            <div class="data-row"><strong>GPS Fix:</strong> <span id="gpsFix" class="data-value">No Fix</span></div>
            <div class="section-divider" style="margin: 10px 0;"></div>
            <div class="data-row"><strong>Moisture:</strong> <span id="moistureData" class="data-value">N/A</span></div>
            <div class="data-row"><strong>NPK (N/P/K):</strong> <span id="npkData" class="data-value">N/A</span></div>
        </div>
    </div>

    <div class="panel map-2d-panel">
        <h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
        <canvas id="roverMap" width="450" height="450"></canvas>
        <p><small>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Health}$. $\text{Triangle} = \text{Rover}$.</small></p>
        <button onclick="clearMapData()"> üóë Clear Data & Reset Rover</button>
    </div>

    <div class="panel photo-panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')"> üì∏ Take Photo (Current Zone)</button>
            <button onclick="openStockImageModal()"> üñºÔ∏è Load Simulation Photos</button>
            <p><small>Click a zone to assign a photo. Last photo status: <span id="lastPhotoStatus">N/A</span>.</small></p>
        </div>

        <div id="photoGrid">
        </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
    </div>

    <div class="panel map-3d-panel">
        <h2>3D Soil Metric Visualization üìä</h2>
        <div id="threeDContainer"></div>
        <p><small>Bar Height = Soil Moisture %. Bar Color = Plant Health (Green/Yellow/Red).</small></p>
    </div>

    <div class="panel analysis-panel">
        <h2>Plant-Specific Fused AI Analysis (16 Zones) üî¨</h2>
        <p><small>Fused analysis of **Leaf Photo (AI)** + **ThingSpeak Soil Data**.</small></p>
        <div id="plantAnalysisGrid">
        </div>
    </div>

</div>

<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeHistoryModal()">&times;</span>
        <h2>Trial History Log üìÖ</h2>
        <div id="trialHistoryList"></div>
        <button class="camera-control" onclick="clearAllHistory()" style="margin-top: 20px;"> ‚ö†Ô∏è Permanently Delete All History</button>
    </div>
</div>
<div id="stockImageModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeStockImageModal()">&times;</span>
        <h2>AI Simulation Photo Gallery üñºÔ∏è</h2>
        <p>Select a simulated plant image to assign it to the selected plant zone.</p>
        <div id="stockImageGrid"></div>
    </div>
</div>

<script>
// JAVASCRIPT LOGIC
// !!! THING SPEAK CONFIGURATION !!!
const ESP32_IP = '192.168.1.50'; // Placeholder for Rover IP
const ESP32_URL_BASE = `http://${ESP32_IP}`;

// --- THINGSPEAK CONFIGURATION (USING USER'S KEY) ---
const THINGSPEAK_CHANNEL_ID = '254870'; // Placeholder Channel ID - **MUST BE CORRECTED BY USER**
const THINGSPEAK_READ_API_KEY = '6OXH3SUQ4VNSOJX1';
const THINGSPEAK_URL = `https://api.thingspeak.com/channels/${THINGSPEAK_CHANNEL_ID}/feeds.json?api_key=${THINGSPEAK_READ_API_KEY}&results=1`;

const STATUS_ELEMENT = document.getElementById('status');
const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');

// --- GLOBAL CONSTANTS & DATA STRUCTURES ---
const FIELD_SIZE = 4;
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 450;
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100;

const PLANT_LOCATIONS_M = [];
for(let r=0; r<FIELD_SIZE; r++) for(let c=0; c<FIELD_SIZE; c++) PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5, id: (r * FIELD_SIZE) + c + 1});

let loggedData = [];
let photoData = {};
let stockPhotoData = {};
let selectedZone = 0;
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;

let currentRoverData = {
    latitude: '40.7128',
    longitude: '-74.0060',
    heading: 0,
    x_m: 2.0,
    y_m: 2.0
};

// --- SIMULATED LIBRARY: TOMATO DIAGNOSTIC RULES (CRITICAL: DARK SPOTS PRIORITY) ---
const TOMATO_DIAGNOSTIC_LIBRARY = {
    DISEASE_TIERS: [
        { name: "Mottling/Mosaic Pattern (Viral)", severity: 95, probability: 0.10, class: 'rec-critical', recommendation: "***ISOLATION REQUIRED***: Strong indicator of Tobacco Mosaic Virus (TMV) or similar. Incurable. Remove plant immediately to prevent field-wide contamination."
        },
        { name: "Dark Spots & Lesions (Fungal/Bact)", severity: 85, probability: 0.15, class: 'rec-critical', recommendation: "***DARK SPOT DETECTION (AI DETERMINANT)***: High probability of Early Blight or Bacterial Spot. Apply broad-spectrum fungicide and improve air circulation/reduce leaf wetness."
        },
        { name: "Leaf Curl & Wilting (Stress/Viral)", severity: 75, probability: 0.10, class: 'rec-critical', recommendation: "WILTING: Could be severe water stress, root rot, or Tomato Yellow Leaf Curl Virus (TYLCV). Check moisture urgently. If moisture is good, isolate for potential virus."
        },
        { name: "General Yellowing (Chlorosis)", severity: 50, probability: 0.25, class: 'rec-action', recommendation: "GENERAL YELLOWING: A common sign of nutrient deficiency (N, Mg, Fe) or pH imbalance. Check NPK data for confirmation."
        },
        { name: "Healthy, Deep Green", severity: 0, probability: 0.40, class: 'rec-optimal', recommendation: "OPTIMAL: No visual symptoms detected. Continue regular monitoring."
        }
    ],
    NPK_GUIDELINES: {
        moisture: { ideal_min: 40, ideal_max: 60, low_crit: 25, high_crit: 75, penalty_minor: 10, penalty_major: 30, low_rec: "deep watering", high_rec: "review soil drainage/stop irrigation" },
        N: { ideal_min: 60, ideal_max: 100, low_crit: 30, high_crit: 150, penalty_minor: 15, penalty_major: 40, low_rec: "high-Nitrogen (N) liquid feed", high_rec: "stop all N-fertilizer, flush soil" },
        P: { ideal_min: 50, ideal_max: 80, low_crit: 20, high_crit: 120, penalty_minor: 10, penalty_major: 25, low_rec: "Phosphorus (P) booster for root development", high_rec: "check fertilizer blend for P excess" },
        K: { ideal_min: 70, ideal_max: 120, low_crit: 40, high_crit: 180, penalty_minor: 10, penalty_major: 25, low_rec: "Potassium (K) to boost resistance/fruit set", high_rec: "check for K salt toxicity" },
    }
};

// --- UTILITY FUNCTIONS ---
function simpleStringHash(str) {
    let hash = 0;
    for (let i = 0; i < Math.min(str.length, 1000); i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash |= 0;
    }
    return Math.abs(hash);
}
function deterministicPseudoRandom(seed) {
    const a = 1664525;
    const c = 1013904223;
    const m = 4294967296;
    let state = (Math.abs(Math.floor(seed)) * 101) % m;
    state = (a * state + c) % m;
    return state / m;
}
function getHealthColorHex(status) {
    switch (status) {
        case 'Good': return 0x6AA84F;
        case 'Caution': return 0xFFC000;
        case 'Bad': return 0xC55050;
        default: return 0x5a5a5a;
    }
}
function getHealthColor(status) {
    if (status === 'Good') return 'var(--color-status-good)';
    if (status === 'Caution') return 'var(--color-status-caution)';
    if (status === 'Bad') return 'var(--color-status-bad)';
    return '#888888';
}

// --- CORE ROVER & DATA FETCH FUNCTIONS ---

function getNearestPlant(x, y) {
    let nearest = null;
    let minDistSq = Infinity;
    PLANT_LOCATIONS_M.forEach(plant => {
        let dx = plant.x - x;
        let dy = plant.y - y;
        let distSq = dx * dx + dy * dy;
        if (distSq < 1 * 1 && distSq < minDistSq) {
            minDistSq = distSq;
            nearest = plant;
        }
    });
    return nearest;
}

function sendCommand(command) {
    let url = (command === 'capture') ? `${ESP32_URL_BASE}/capture` : `${ESP32_URL_BASE}/move?dir=${command}`;
    STATUS_ELEMENT.innerText = `Sending command: ${command}...`;

    // --- Mock Movement for UI Update ---
    if (['forward', 'backward', 'left', 'right'].includes(command)) {
        const step = 0.5;
        const rad = currentRoverData.heading * Math.PI / 180;
        let newX = parseFloat(currentRoverData.x_m);
        let newY = parseFloat(currentRoverData.y_m);
        let newHeading = currentRoverData.heading;

        if (command === 'forward') { newX += step * Math.cos(rad); newY += step * Math.sin(rad); }
        else if (command === 'backward') { newX -= step * Math.cos(rad); newY -= step * Math.sin(rad); }
        else if (command === 'left') { newHeading = (newHeading - 45 + 360) % 360; }
        else if (command === 'right') { newHeading = (newHeading + 45) % 360; }

        currentRoverData.x_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newX)).toFixed(2);
        currentRoverData.y_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newY)).toFixed(2);
        currentRoverData.heading = newHeading;
        updateRoverPositionUI();
        drawMap();
        updateRover3DPosition();
        STATUS_ELEMENT.innerText = `Command '${command}' Success (Mock Movement).`;
        return; // Skip API call for mock movement
    }

    // --- API Call Simulation for Probe/Capture ---
    fetch(url) // Actual call to ESP32 (will likely fail in this browser context)
        .then(response => {
            if (!response.ok) { throw new Error(`HTTP Error: ${response.status}`); }
            return response.text();
        })
        .then(data => {
            if (command === 'probe') {
                STATUS_ELEMENT.innerText = `Probe command sent. Awaiting ThingSpeak data update...`;
                // Wait for the ESP32 to push data to ThingSpeak
                setTimeout(() => fetchData(command), 1000);
            } else if (command === 'capture') {
                LAST_PHOTO_STATUS.innerText = 'Photo captured and sent to server (simulated).';
                const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
                if (nearestPlant) {
                    photoData[nearestPlant.id] = `data:image/jpeg;base64,mocked_rover_capture_zone_${nearestPlant.id}_diag:Healthy_${Date.now()}`;
                    renderPhotoInCell(nearestPlant.id, photoData[nearestPlant.id]);
                    fetchAIResults();
                    STATUS_ELEMENT.innerText = `Photo captured and assigned to Zone ${nearestPlant.id}.`;
                }
            } else {
                 STATUS_ELEMENT.innerText = `Command '${command}' Success. Rover response: ${data.substring(0, 30)}...`;
            }
        })
        .catch(error => {
            // Treat as successful for the sake of the demo if it's probe/capture, but log error
            console.error('Error sending command (API failed, continuing with demo):', error);
            if (command === 'probe') {
                STATUS_ELEMENT.innerText = `Probe command simulated. Fetching ThingSpeak data now...`;
                setTimeout(() => fetchData(command), 500);
            } else if (command === 'capture') {
                // Mock success for capture
                LAST_PHOTO_STATUS.innerText = 'Photo captured and sent to server (mocked success).';
                const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
                if (nearestPlant) {
                    photoData[nearestPlant.id] = `data:image/jpeg;base64,mocked_rover_capture_zone_${nearestPlant.id}_diag:Dark_Spots_${Date.now()}`; // Mock a disease sometimes
                    renderPhotoInCell(nearestPlant.id, photoData[nearestPlant.id]);
                    fetchAIResults();
                    STATUS_ELEMENT.innerText = `Photo captured (mocked) and assigned to Zone ${nearestPlant.id}.`;
                }
            } else {
                STATUS_ELEMENT.innerText = `ERROR: Command ${command} failed. Is ESP32 at ${ESP32_IP} online?`;
            }
        });
}

async function fetchData(lastCommand = null) {
    STATUS_ELEMENT.innerText = "Fetching latest data from ThingSpeak...";
    try {
        const response = await fetch(THINGSPEAK_URL);
        if (!response.ok) { throw new Error(`ThingSpeak HTTP Error: ${response.status}`); }
        const data = await response.json();
        const lastField = data.feeds[0];

        if (!lastField || !lastField.entry_id) {
            STATUS_ELEMENT.innerText = "ThingSpeak: No recent data feed available. Check API Key/Channel ID.";
            return;
        }

        // --- Parse Data from ThingSpeak Fields (ASSUMED MAPPING) ---
        const moistureVal = parseFloat(lastField.field1) || 0;
        const npk_n = parseInt(lastField.field2) || 0;
        const npk_p = parseInt(lastField.field3) || 0;
        const npk_k = parseInt(lastField.field4) || 0;
        // Mock X/Y/Heading if not available or zero
        const x_m = parseFloat(lastField.field5) || currentRoverData.x_m;
        const y_m = parseFloat(lastField.field6) || currentRoverData.y_m;
        const heading = parseFloat(lastField.field7) || currentRoverData.heading;

        // --- Update Rover Data (Navigation) ---
        currentRoverData.heading = heading;
        currentRoverData.x_m = x_m.toFixed(2);
        currentRoverData.y_m = y_m.toFixed(2);

        // Update UI
        updateRoverPositionUI(moistureVal, npk_n, npk_p, npk_k, heading);

        // --- Log Data if command was 'probe' ---
        if (lastCommand === 'probe') {
            let healthStatus = analyzeHealth(moistureVal, npk_n, npk_p, npk_k);

            const isNewLogPosition = !loggedData.some(d =>
                Math.abs(d.x_m - x_m) < 0.2 && Math.abs(d.y_m - y_m) < 0.2
            );

            const newLogEntry = {
                x_m: x_m, y_m: y_m, healthStatus: healthStatus,
                moisture: moistureVal, npk_n: npk_n, npk_p: npk_p, npk_k: npk_k,
                timestamp: new Date().toLocaleTimeString()
            };

            if (isNewLogPosition) {
                 loggedData.push(newLogEntry);
                STATUS_ELEMENT.innerText = `New data point logged from ThingSpeak! Status: ${healthStatus}`;
            } else {
                const existingIndex = loggedData.findIndex(d => Math.abs(d.x_m - x_m) < 0.2 && Math.abs(d.y_m - y_m) < 0.2);
                loggedData[existingIndex] = newLogEntry; // Overwrite existing log
                 STATUS_ELEMENT.innerText = `Data refreshed (Overwrite). Status: ${healthStatus}`;
            }

            fetchAIResults();
        } else {
             STATUS_ELEMENT.innerText = "ThingSpeak data refreshed successfully.";
        }

        drawMap();
        draw3DMap();

    } catch (error) {
        STATUS_ELEMENT.innerText = `ERROR: Failed to fetch ThingSpeak data. Check Channel ID/API Key/Network.`;
        console.error('ThingSpeak Fetch Error:', error);
    }
}

function updateRoverPositionUI(moisture = null, npk_n = null, npk_p = null, npk_k = null, heading = null) {
    document.getElementById('latitudeData').innerText = currentRoverData.latitude;
    document.getElementById('longitudeData').innerText = currentRoverData.longitude;
    document.getElementById('gpsFix').innerText = "3D Fix";
    document.getElementById('headingData').innerText = (heading !== null ? heading.toFixed(0) : currentRoverData.heading.toFixed(0)) + ' deg';

    if (moisture !== null) {
        document.getElementById('moistureData').innerText = moisture.toFixed(1) + '%';
        document.getElementById('npkData').innerText = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
    }
}

function analyzeHealth(moisture, npk_n, npk_p, npk_k) {
    let issues = 0;
    const GUIDELINES = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES;

    if (moisture < GUIDELINES.moisture.low_crit || moisture > GUIDELINES.moisture.high_crit) issues++;
    if (npk_n < GUIDELINES.N.low_crit || npk_n > GUIDELINES.N.high_crit) issues++;
    if (npk_p < GUIDELINES.P.low_crit || npk_p > GUIDELINES.P.high_crit) issues++;
    if (npk_k < GUIDELINES.K.low_crit || npk_k > GUIDELINES.K.high_crit) issues++;

    if (issues >= 2) return 'Bad';
    if (issues === 1) return 'Caution';
    return 'Good';
}

function clearMapData(resetRover = true) {
    loggedData = [];
    photoData = {};
    if (resetRover) {
        currentRoverData.x_m = 2.0;
        currentRoverData.y_m = 2.0;
        currentRoverData.heading = 0;
    }
    drawMap();
    draw3DMap();
    clearPhotoGrid();
    fetchAIResults();
    updateRoverPositionUI();
    STATUS_ELEMENT.innerText = "Map data, rover logs, and photos cleared.";
}

// --- 2D Map Drawing ---
function drawMap() {
    CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE);
    CTX.strokeStyle = '#5a5a5a';
    CTX.lineWidth = 1;

    // Draw Grid Lines (1m x 1m)
    for (let i = 0; i <= FIELD_SIZE; i++) {
        let p = i * PIXELS_PER_METER;
        CTX.beginPath(); CTX.moveTo(p, 0); CTX.lineTo(p, MAP_SIZE); CTX.stroke();
        CTX.beginPath(); CTX.moveTo(0, p); CTX.lineTo(MAP_SIZE, p); CTX.stroke();
    }

    // Draw Logged Data Points (Health Status)
    loggedData.forEach(data => {
        let x_px = data.x_m * PIXELS_PER_METER;
        let y_px = MAP_SIZE - (data.y_m * PIXELS_PER_METER);

        CTX.beginPath();
        CTX.arc(x_px, y_px, 12, 0, 2 * Math.PI);
        CTX.fillStyle = getHealthColor(data.healthStatus);
        CTX.fill();
        CTX.strokeStyle = 'white';
        CTX.lineWidth = 2;
        CTX.stroke();
    });

    // Draw Rover
    let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
    let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
    // Convert heading (0=North/Y+) to map angle (0=East/X+)
    let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);
    let size = 15;

    CTX.save();
    CTX.translate(rover_x_px, rover_y_px);
    CTX.rotate(heading_rad);

    CTX.beginPath();
    CTX.moveTo(size, 0);
    CTX.lineTo(-size * 0.5, -size * 0.7);
    CTX.lineTo(-size * 0.5, size * 0.7);
    CTX.closePath();

    CTX.fillStyle = 'var(--color-primary)';
    CTX.fill();
    CTX.strokeStyle = 'var(--color-text-highlight)';
    CTX.lineWidth = 2;
    CTX.stroke();
    CTX.restore();
}

// --- 3D Map Functions ---
let scene, camera, renderer, rover3D, controls;
let dataCubes = {};

function initThreeD() {
    const container = document.getElementById('threeDContainer');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.set(2, 6, 2);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.innerHTML = '';
    container.appendChild(renderer.domElement);
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.2;
    const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
    gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2);
    scene.add(gridHelper);

    const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
    const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
    rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
    rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m);
    scene.add(rover3D);
    scene.add(new THREE.AmbientLight(0x404040, 2));
    scene.add(new THREE.DirectionalLight(0xffffff, 1.5));
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    if(controls) controls.update();
    renderer.render(scene, camera);
}

function updateRover3DPosition() {
    if (rover3D) {
        rover3D.position.set(parseFloat(currentRoverData.x_m), 0.05, parseFloat(currentRoverData.y_m));
        // Rotate the rover based on heading (0 deg in 3D points down -Y (North), 90 deg is -X (West))
        rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
    }
}

function draw3DMap() {
    Object.values(dataCubes).forEach(cube => { scene.remove(cube); cube.geometry.dispose(); cube.material.dispose(); });
    dataCubes = {};

    loggedData.forEach((data, index) => {
        const { x_m, y_m, moisture, healthStatus } = data;
        // Map moisture (0-100) to height (0.01 - 3.0)
        const cubeHeight = Math.max(0.01, moisture / MAX_MOISTURE * 3);
        const colorHex = getHealthColorHex(healthStatus);
        const geometry = new THREE.BoxGeometry(0.5, cubeHeight, 0.5);
        const material = new THREE.MeshPhongMaterial({ color: colorHex, opacity: 0.8, transparent: true });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x_m, cubeHeight / 2, y_m);
        dataCubes[index] = cube;
        scene.add(cube);
    });
    updateRover3DPosition();
}

// --- FUSED AI ANALYSIS LOGIC ---
function getNearestSensorData(plantX, plantY) {
    let nearestData = null;
    let min_dist_sq = Infinity;
    loggedData.forEach(data => {
        let dx = data.x_m - plantX;
        let dy = data.y_m - plantY;
        let dist_sq = dx * dx + dy * dy;
        if (dist_sq < 0.707 * 0.707 && dist_sq < min_dist_sq) {
            min_dist_sq = dist_sq;
            nearestData = data;
        }
    });
    return nearestData;
}

function getPhotoPrediction(base64Image) {
    // Check for explicit disease tag (Simulated AI feature)
    if (base64Image.includes('_diag:Dark_Spots')) {
        return TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Dark Spots"));
    }
    if (base64Image.includes('_diag:Mottling')) {
        return TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Mottling"));
    }

    // Default probabilistic roll for other symptoms
    const photoHash = simpleStringHash(base64Image);
    const randomRoll = deterministicPseudoRandom(photoHash);
    let cumulativeProb = 0;
    let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS[4];

    for (const disease of TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS) {
        if (disease.name.includes("Dark Spots") || disease.name.includes("Mottling")) continue;

        cumulativeProb += disease.probability;
        if (randomRoll <= cumulativeProb) {
            prediction = disease;
            break;
        }
    }
    return prediction;
}

function analyzePlant(plant, sensorData, photoExists) {
    let soilScore = 100;
    let soilProblems = [];
    let sensorDiagnosis = "Soil: Sensor Data Missing";
    let visualDiagnosis = "Visual: No Photo Taken";
    let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS[4]; // Default to Healthy
    let finalRecommendation = '';
    let healthClass = 'rec-optimal';

    // 1. Sensor Data Analysis
    if (sensorData) {
        const { moisture, npk_n, npk_p, npk_k } = sensorData;
        const data = { moisture, N: npk_n, P: npk_p, K: npk_k };
        const keys = ['moisture', 'N', 'P', 'K'];
        const guid = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES;

        keys.forEach(key => {
            const guideline = guid[key];
            const value = data[key];
            let problem = '';

            if (value < guideline.low_crit) { soilScore -= guideline.penalty_major; problem = `CRITICAL LOW ${key}`; }
            else if (value < guideline.ideal_min) { soilScore -= guideline.penalty_minor; problem = `LOW ${key}`; }
            else if (value > guideline.high_crit) { soilScore -= guideline.penalty_major; problem = `CRITICAL HIGH ${key}`; }
            else if (value > guideline.ideal_max) { soilScore -= guideline.penalty_minor; problem = `HIGH ${key}`; }

            if (problem) {
                let rec = (problem.includes('CRITICAL') ? "Urgent " : "") +
                (value < guideline.low_crit ? guideline.low_rec : guideline.high_rec);
                soilProblems.push({ key, value, problem, rec });
            }
        });
        sensorDiagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;
    } else {
        return { id: plant.id, score: 20, visualDiagnosis, sensorDiagnosis: "Soil: Sensor Data Missing", recommendation: "***CRITICAL ERROR: DATA GAP***. Rover has not probed this zone.", healthClass: 'rec-critical' };
    }

    // 2. Photo Analysis
    if (photoExists) {
        prediction = getPhotoPrediction(photoData[plant.id]);
        visualDiagnosis = `Visual: ${prediction.name}`;
    }

    // 3. Fused Diagnosis (Logic retains dark spot priority)
    const isMottling = prediction.name.includes('Mottling');
    const isDarkSpots = prediction.name.includes('Dark Spots');

    if (isMottling) {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
    } else if (isDarkSpots) {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
    } else if (soilProblems.length > 0) {
        const problemString = soilProblems.map(p => p.problem).join('; ');
        const recString = soilProblems.map(p => p.rec).join('; ');

        finalRecommendation = `CAUTION: Soil Imbalance (${problemString}). Recommended action: ${recString}`;
        healthClass = soilScore <= 60 ? 'rec-action' : 'rec-optimal';
    } else {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
    }

    const finalScore = Math.max(0, Math.round(soilScore - prediction.severity * 0.3));
    return { id: plant.id, score: finalScore.toFixed(0), visualDiagnosis, sensorDiagnosis, recommendation: finalRecommendation.trim(), healthClass };
}

function fetchAIResults() {
    const analysisGrid = document.getElementById('plantAnalysisGrid');
    analysisGrid.innerHTML = '';
    PLANT_LOCATIONS_M.forEach(plant => {
        const sensorData = getNearestSensorData(plant.x, plant.y);
        const photoExists = !!photoData[plant.id];
        const analysis = analyzePlant(plant, sensorData, photoExists);

        const card = `
        <div class="analysis-card ${analysis.healthClass}">
        <div class="plant-id-label">Zone ${analysis.id}</div>
        <div class="data-row">
            <strong>Score:</strong> <span class="data-value">${analysis.score}/100</span>
        </div>
        <div class="data-row">
            <strong>Leaf:</strong> <span class="data-value">${analysis.visualDiagnosis}</span>
        </div>
        <div class="data-row">
            <strong>Soil:</strong> <span class="data-value">${analysis.sensorDiagnosis.substring(0, 30)}...</span>
        </div>
        <div style="margin-top: 5px;">
            <span class="${analysis.healthClass}">${analysis.recommendation}</span>
        </div>
        </div>
        `;
        analysisGrid.insertAdjacentHTML('beforeend', card);
    });
    draw3DMap();
}

// --- PHOTO & MODAL LOGIC ---
function populateStockPhotos() {
    if (Object.keys(stockPhotoData).length === 16) return;
    const diseaseList = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS;
    for (let i = 1; i <= 16; i++) {
        const diseaseIndex = i % diseaseList.length;
        const diagTag = diseaseList[diseaseIndex].name.replace(/\s/g, '_').replace(/\//g, '-');
        const base64 = `data:image/svg+xml;base64,mocked_stock_photo_hash_${i}_diag:${diagTag}`;
        stockPhotoData[i] = base64;
    }
}
function openStockImageModal() {
    populateStockPhotos();
    const container = document.getElementById('stockImageGrid');
    container.innerHTML = '';
    for (let id = 1; id <= 16; id++) {
        const base64Image = stockPhotoData[id];
        const prediction = getPhotoPrediction(base64Image);
        const div = document.createElement('div');
        div.className = 'grid-cell';
        div.setAttribute('onclick', `assignStockPhotoToZone(${id})`);
        div.style.margin = '5px';
        div.innerHTML = `<img src="${base64Image}" alt="Stock Image ${id}" class="cell-photo" />
            <span style="position:absolute; top:2px; right:2px; background:rgba(0,0,0,0.7); color:white; padding: 2px 5px; border-radius:3px; font-size: 0.7em;">ID ${id}</span>
            <span style="position:absolute; bottom:2px; left:2px; background:rgba(0,0,0,0.7); color:white; padding: 2px 5px; border-radius:3px; font-size: 0.7em;">${prediction.name.split('(')[0].trim()}</span>
        `;
        container.appendChild(div);
    }
    document.getElementById('stockImageModal').style.display = "block";
}
function closeStockImageModal() { document.getElementById('stockImageModal').style.display = "none"; }
function assignStockPhotoToZone(stockId) {
    if (selectedZone === 0) {
        STATUS_ELEMENT.innerText = "Error: Please click a Zone (1-16) on the main Photo Grid first.";
        return;
    }
    const photo = stockPhotoData[stockId];
    photoData[selectedZone] = photo;
    renderPhotoInCell(selectedZone, photo);
    STATUS_ELEMENT.innerText = `Assigned Stock Photo ID ${stockId} to Zone ${selectedZone}.`;
    closeStockImageModal();
    selectedZone = 0;
    fetchAIResults();
}
function generatePhotoGrid() {
    const grid = document.getElementById('photoGrid');
    for (let i = 1; i <= 16; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.id = `zone-${i}`;
        cell.innerHTML = `<span class="cell-label">${i}</span>
        <button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>
        `;
        cell.setAttribute('onclick', `preparePhotoUpload(${i})`);
        grid.appendChild(cell);
    }
}
function preparePhotoUpload(zoneId) {
    selectedZone = zoneId;
    document.getElementById('fileInput').click();
}
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file && selectedZone !== 0) {
        const reader = new FileReader();
        reader.onload = function(e) {
            // Append a default 'Healthy' tag for user uploads
            photoData[selectedZone] = e.target.result + "_diag:Healthy";
            renderPhotoInCell(selectedZone, e.target.result + "_diag:Healthy");
            STATUS_ELEMENT.innerText = `Custom photo uploaded and assigned to Zone ${selectedZone}.`;
            selectedZone = 0;
            event.target.value = ''; // Clear input
            fetchAIResults();
        };
        reader.readAsDataURL(file);
    }
}
function renderPhotoInCell(zoneId, base64Image) {
    const cell = document.getElementById(`zone-${zoneId}`);
    if (!cell) return;

    // Clear existing content except the delete button
    cell.querySelectorAll('.cell-photo').forEach(el => el.remove());
    const zoneLabel = cell.querySelector('.cell-label');
    const deleteBtn = cell.querySelector('.delete-photo-btn');

    if (base64Image) {
        // Extract base64 part only if it contains the mock tag
        const displayImage = base64Image.split('_diag:')[0];
        const img = document.createElement('img');
        img.src = displayImage;
        img.className = 'cell-photo';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        cell.appendChild(img);
        zoneLabel.style.display = 'none';
        deleteBtn.style.display = 'block';
    } else {
        zoneLabel.style.display = 'block';
        deleteBtn.style.display = 'none';
    }
}
function deletePhoto(zoneId) {
    delete photoData[zoneId];
    renderPhotoInCell(zoneId, null);
    fetchAIResults();
}
function loadCurrentPhotoData() {
    for (let i = 1; i <= 16; i++) {
        renderPhotoInCell(i, photoData[i] || null);
    }
}
function clearPhotoGrid() {
    for (let i = 1; i <= 16; i++) {
        renderPhotoInCell(i, null);
    }
}


// --- HISTORY LOGIC ---
function saveCurrentTrial() {
    populateStockPhotos();
    const trialId = trialHistory.length + 1;
    const trialData = {
        id: trialId,
        date: new Date().toLocaleString(),
        roverData: { ...currentRoverData },
        loggedData: [...loggedData],
        photoData: { ...photoData },
        stockPhotoData: { ...stockPhotoData },
        aiData: {
            analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML
        }
    };
    trialHistory.push(trialData);
    localStorage.setItem('trialHistory', JSON.stringify(trialHistory));
    currentTrialNumber = trialId + 1;
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
    STATUS_ELEMENT.innerText = `Trial ${trialId} saved successfully! Starting new trial...`;

    // Reset for new trial
    loggedData = [];
    photoData = {};
    clearMapData(false);
}

function openHistoryModal() {
    const modal = document.getElementById('historyModal');
    const list = document.getElementById('trialHistoryList');
    list.innerHTML = '';

    if (trialHistory.length === 0) {
        list.innerHTML = '<p style="color:#FFC000; font-weight:bold;">No trial data saved yet.</p>';
    } else {
        [...trialHistory].reverse().forEach(trial => {
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.style.padding = '10px';
            item.style.borderBottom = '1px solid #3C3C3C';
            item.innerHTML = `<span><strong>Trial ${trial.id}:</strong> ${trial.date} (${trial.loggedData.length} readings)</span>
                <button onclick="loadPastTrial(${trial.id})" style="float:right; background-color:#4EC9B0; color:black;">Load</button>`;
            list.appendChild(item);
        });
    }
    modal.style.display = "block";
}
function closeHistoryModal() { document.getElementById('historyModal').style.display = "none"; }
function loadPastTrial(trialId) {
    const trial = trialHistory.find(t => t.id === trialId);
    if (!trial) return;

    currentRoverData = trial.roverData;
    document.getElementById('latitudeData').innerText = trial.roverData.latitude;
    document.getElementById('longitudeData').innerText = trial.roverData.longitude;
    document.getElementById('headingData').innerText = trial.roverData.heading + ' deg';
    document.getElementById('gpsFix').innerText = 'Historical';

    loggedData = trial.loggedData;
    photoData = trial.photoData;
    stockPhotoData = trial.stockPhotoData || {};
    document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;

    drawMap();
    draw3DMap();
    loadCurrentPhotoData();

    STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
    document.getElementById('currentTrialNumber').innerText = `${trialHistory.length + 1} (Viewing Trial ${trialId})`;
    closeHistoryModal();
}
function clearAllHistory() {
    if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
        localStorage.removeItem('trialHistory');
        trialHistory = [];
        currentTrialNumber = 1;
        document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
        closeHistoryModal();
        STATUS_ELEMENT.innerText = "All trial history cleared.";
    }
}

// --- Initialization ---
window.onload = function() {
    initThreeD();
    drawMap();
    generatePhotoGrid();
    populateStockPhotos();
    // Attempt an initial data fetch to update the live display
    fetchData();
    // Run AI analysis based on any restored data or empty state
    fetchAIResults();
    updateRoverPositionUI();
};
</script>
</body>
</html>
