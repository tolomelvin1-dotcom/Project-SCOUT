<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PROJECT SCOUT - Rover Control & Fused AI Analysis (v1.4)</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
/* =============================================================================
--- SECTION 1: GLOBAL STYLING AND THEME DEFINITIONS ---
=============================================================================
*/

/** Root Variables for Theming (High Contrast Dark Mode) **/
:root {
    --color-primary: #0078D4;       /* Command/Action Blue */
    --color-secondary: #4EC9B0;     /* Header/Accent Teal */
    --color-background: #090909;    /* Deepest Background */
    --color-card: #1E1E1E;          /* Panel/Card Background */
    --color-text: #F0F0F0;          /* High Contrast Text */
    --color-border: #3C3C3C;        /* Subtle Separator Lines */
    --color-status-good: #6AA84F;   /* Health: Green (Optimal) */
    --color-status-caution: #FFC000;/* Health: Yellow (Action Required) */
    --color-status-bad: #C55050;    /* Health: Red (Critical) */
    --color-status-initial: #5a5a5a;/* Status: Initial/No Data/Partial */
    --color-text-highlight: #9CDCFE;/* Code/Data Highlight */
    --font-stack: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    --shadow-deep: 0 6px 20px rgba(0,0,0,0.6);
}

/* Base Body and Typography Reset */
body {
    font-family: var(--font-stack);
    margin: 0;
    padding: 30px;
    background-color: var(--color-background);
    color: var(--color-text);
    line-height: 1.6;
    min-height: 100vh;
}

/* Main Layout Container */
.container {
    max-width: 1800px;
    margin: auto;
    background: var(--color-card);
    padding: 30px;
    border-radius: 15px;
    box-shadow: var(--shadow-deep);
    display: flex;
    flex-wrap: wrap; 
    justify-content: flex-start;
    gap: 30px; 
}

/* =============================================================================
--- SECTION 2: PANEL SIZING AND GENERAL STYLING ---
=============================================================================
*/

/* Flexible Layout Definition for Panels */
.controls-panel { flex: 0 0 380px; } 
.map-panel { flex: 1; min-width: 480px; } 
.photo-panel { flex: 1; min-width: 480px; } 
.map-3d-panel { flex: 0 0 480px; margin-top: 15px; } 
.plant-analysis-panel { 
    flex-basis: 100%; 
    margin-top: 30px; 
    padding-top: 25px; 
    border-top: 2px solid var(--color-border); 
} 

.panel {
    background: #252526;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    transition: box-shadow 0.3s ease-in-out;
}
.panel:hover {
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}

/* Headers and Titles */
h1 { 
    color: var(--color-primary); 
    border-bottom: 3px solid var(--color-border); 
    padding-bottom: 12px; 
    margin-top: 0; 
    font-size: 2.0em;
}
h2 { 
    color: var(--color-secondary); 
    margin-top: 25px; 
    font-weight: 600;
    font-size: 1.4em;
}

/* =============================================================================
--- SECTION 3: INTERACTIVE ELEMENTS (BUTTONS & DATA) ---
=============================================================================
*/

/* Generic Button Styles */
button {
    padding: 12px 20px; 
    margin: 8px 5px 8px 0; 
    cursor: pointer; 
    border: none;
    border-radius: 8px; 
    font-weight: bold; 
    transition: background-color 0.2s, transform 0.1s;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    font-size: 0.9em;
}
button:hover {
    filter: brightness(1.1);
}
button:active {
    transform: translateY(2px);
}

/* Specific Control Groups */
.move-controls button { background-color: var(--color-primary); color: white; }
.arm-controls button { background-color: #00AA90; color: white; }
.camera-control button { background-color: var(--color-primary); color: white; }
.history-controls button { background-color: #FF8C00; color: white; }
.stock-control button { background-color: #6C757D; color: white; }

/* Data Display Box */
.data-display { 
    margin-top: 20px; 
    padding: 20px; 
    border: 1px solid var(--color-border); 
    border-radius: 10px; 
    background-color: #1a1a1a; 
}
.data-row { 
    margin-bottom: 8px; 
    display: flex;
    justify-content: space-between;
    padding-right: 5px;
}
.data-row strong { 
    display: inline-block; 
    width: 160px; 
    color: var(--color-text-highlight); 
    font-weight: normal;
}

/* =============================================================================
--- SECTION 4: VISUALIZATION CONTAINERS & PHOTO GRID ---
=============================================================================
*/

#roverMap, #threeDContainer { 
    border: 3px solid var(--color-primary); 
    background-color: #3d3d3d; 
    display: block; 
    margin: 15px auto 0; 
    width: 480px; 
    height: 480px;
    border-radius: 8px;
}

/* Main Grid (On the Dashboard) */
#photoGrid {
    display: grid; 
    grid-template-columns: repeat(4, 1fr); 
    grid-template-rows: repeat(4, 1fr);
    gap: 10px; 
    border: 2px solid var(--color-secondary); 
    max-width: 480px; 
    margin: 15px auto;
    aspect-ratio: 1 / 1; 
    background-color: #252526;
    padding: 8px;
    border-radius: 10px;
}
.grid-cell {
    background-color: #3d3d3d; 
    border: 2px solid var(--color-secondary); 
    position: relative;
    display: flex; 
    justify-content: center; 
    align-items: center; 
    cursor: pointer; 
    overflow: hidden;
    transition: border-color 0.2s;
    border-radius: 5px;
}
.grid-cell:hover {
    border-color: var(--color-primary);
}
.cell-label { 
    font-size: 1.8em; 
    font-weight: bold; 
    color: rgba(255, 255, 255, 0.4); 
    pointer-events: none; 
}
.grid-cell img { 
    width: 100%; 
    height: 100%; 
    object-fit: cover; 
    position: absolute;
    top: 0;
    left: 0;
}
.delete-photo-btn {
    position: absolute; 
    bottom: 5px; 
    right: 5px; 
    background-color: rgba(220, 53, 69, 0.9); 
    color: white;
    border-radius: 5px; 
    padding: 5px 8px; 
    font-size: 12px; 
    cursor: pointer; 
    z-index: 20; 
    line-height: 1; 
    display: none;
    border: 1px solid white;
}
.grid-cell:has(.cell-photo) .delete-photo-btn { display: block; }


/* =============================================================================
--- SECTION 5: ANALYSIS CARDS AND MODALS (UPDATED RECOMMENDATION STYLES) ---
=============================================================================
*/
#plantAnalysisGrid {
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); 
    gap: 30px; 
    margin-top: 25px;
}
.analysis-card {
    background-color: #2D2D30;
    padding: 25px;
    border-radius: 10px;
    border-left: 6px solid var(--color-secondary);
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
}

/* Health Status Recommendations */
.rec-text {
    padding: 10px; 
    border-radius: 6px; 
    display: block; 
    font-weight: bold; 
    width: 100%; 
    box-sizing: border-box;
    margin-top: 5px !important;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
}
.rec-optimal { background-color: var(--color-status-good); color: white; border: 1px solid #486a34; }
.rec-action { background-color: var(--color-status-caution); color: #333; border: 1px solid #a88100; }
.rec-critical { background-color: var(--color-status-bad); color: white; border: 1px solid #843535; }
.rec-initial { background-color: var(--color-status-initial); color: white; border: 1px solid #3d3d3d; }


.modal { 
    display: none; 
    position: fixed; 
    z-index: 1000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    overflow: auto; 
    background-color: rgba(0,0,0,0.85); 
    justify-content: center;
    align-items: center;
}
.modal-content { 
    background-color: var(--color-card); 
    margin: 5% auto; 
    padding: 40px; 
    border: 3px solid var(--color-primary); 
    width: 90%; 
    max-width: 1000px; 
    border-radius: 15px; 
    box-shadow: var(--shadow-deep);
}
.close-btn { 
    color: #aaa; 
    float: right; 
    font-size: 36px; 
    font-weight: bold; 
    transition: color 0.2s;
}
.close-btn:hover, .close-btn:focus {
    color: white;
    text-decoration: none;
    cursor: pointer;
}

/* New CSS for Assigned Photos 4x4 Grid in Modal */
.assigned-photo-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* Enforces 4 columns */
    grid-template-rows: repeat(4, 1fr);    /* Enforces 4 rows */
    gap: 10px;
    padding: 10px;
    max-width: 500px; /* Constrain the overall size for better visibility */
    margin: 15px auto;
    aspect-ratio: 1/1;
}
.assigned-photo-grid > div {
    height: auto;
    padding: 0;
}
</style>
</head>
<body>
<div class="container">
    
    <div class="controls-panel panel">
        <h1>PROJECT SCOUT Control Dashboard</h1>
        <p>System Status: <span id="status">System Initializing (No Connection)</span></p>

        <div class="data-display history-controls">
            <h2>Trial Management 💾</h2>
            <div class="data-row"><strong>Current Trial #:</strong> <span id="currentTrialNumber">1</span></div>
            <p>
                <button onclick="saveCurrentTrial()">💾 Save & New Trial</button>
                <button onclick="openHistoryModal()">📅 View History</button>
            </p>
        </div>

        <div class="move-controls">
            <h2>Rover Movement</h2>
            <button onclick="sendCommand('forward')">Forward (↑)</button>
            <button onclick="sendCommand('stop')">🛑 STOP</button>
            <button onclick="sendCommand('backward')">Backward (↓)</button><br>
            <button onclick="sendCommand('left')">Left (←)</button>
            <button onclick="sendCommand('right')">Right (→)</button>
        </div>

        <div style="border-top: 1px solid var(--color-border); margin: 20px 0;"></div>

        <div class="arm-controls">
            <h2>Data Acquisition</h2>
            <button onclick="sendCommand('extendArm')">⬇️ Extend Arm</button>
            <button onclick="sendCommand('retractArm')">⬆️ Retract Arm</button>
            <button onclick="sendCommand('probe')">🔬 Probe Soil (Log Data)</button>
            <button onclick="checkConnectionStatus()">📡 Check Rover/API Status</button>
        </div>

        <div class="data-display">
            <h3>Live Sensor Data (ThingSpeak/API)</h3>
            <div class="data-row"><strong>GPS Latitude:</strong> <span id="latitudeData">---</span></div>
            <div class="data-row"><strong>GPS Longitude:</strong> <span id="longitudeData">---</span></div>
            <div class="data-row"><strong>Rover Heading:</strong> <span id="headingData">---</span></div>
            <div class="data-row"><strong>Soil Moisture:</strong> <span id="moistureData">---</span></div>
            <div class="data-row"><strong>NPK (N/P/K):</strong> <span id="npkData">---</span></div>
        </div>
    </div>

    <div class="map-panel panel">
        <h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
        <canvas id="roverMap" width="480" height="480"></canvas>
        <p><small>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Logged Data}$. $\text{Triangle} = \text{Rover}$.</small></p>
        <button onclick="clearMapData()">🗑️ Clear Map Data & Reset Rover</button>
    </div>

    <div class="photo-panel panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')">📸 Request Photo (Current Zone)</button>
        </div>
        <div class="stock-control">
            <button onclick="openStockPhotoModal()">📚 Stock Photo Gallery</button>
            <p><small>Click a zone cell below to assign a photo (Manual or Stock). Last photo status: <span id="lastPhotoStatus">---</span>.</small></p>
        </div>
        <div style="border-top: 1px solid var(--color-border); margin: 15px 0;"></div>
        <h3>Plant Zone Photo Assignments (Zones 1-16)</h3>
        <div id="photoGrid">
            </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
    </div>

    <div class="map-3d-panel panel">
        <h2>3D Soil Metric Visualization 📊</h2>
        <div id="threeDContainer"></div>
        <p><small>Bar Height = Soil Moisture %. Bar Color = Plant Health (Reflects AI/NPK Status).</small></p>
    </div>

    <div class="plant-analysis-panel panel">
        <h2>Plant-Specific Fused AI Analysis (16 Zones) 🔬</h2>
        <p>
            <small>
                **Fused analysis** combines visual data and soil data. **If only a photo is present, a PARTIAL recommendation is provided based on a Crop Health Assessment.**
            </small>
        </p>
        <div id="plantAnalysisGrid">
            </div>
    </div>
</div>

<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
        <h2>Saved Trial History</h2>
        <div id="trialHistoryList"></div>
        <div style="border-top: 1px solid var(--color-border); margin-top: 20px;"></div>
        <button onclick="clearAllHistory()" style="background-color: var(--color-status-bad);">🚨 Clear All Saved Trials</button>
    </div>
</div>

<div id="stockPhotoModal" class="modal">
    <div class="modal-content" style="max-width: 900px;">
        <span class="close-btn" onclick="closeStockPhotoModal()">&times;</span> 
        <h2>Stock Photo Gallery & Assignment for Zone <span id="currentStockZone">---</span></h2> 
        <div id="stockPhotoList" style="margin-top: 25px;">
            </div>
    </div>
</div>


<div class="footer" style="text-align: center; color: #5a5a5a; margin-top: 30px; font-size: 0.8em;">
    All Rights Reserved: BanScie RIM Team 2025 | Fused AI Logic v1.4
</div>

<script>
/* =============================================================================
=============================================================================
--- SECTION 10: CORE JAVASCRIPT LOGIC & CONFIGURATION (Detailed Implementation) ---
=============================================================================
=============================================================================
*/

// --- 10.1: CORE CONFIGURATION CONSTANTS ---

const ESP32_IP = '192.168.1.50'; 
const FIELD_SIZE = 4; 
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 480; 
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100; 
const MAX_TRIALS = 50; // New constant for the trial limit

// --- Plant Grid Definitions (16 Zones) ---
const PLANT_LOCATIONS_M = [];
for(let r = 0; r < FIELD_SIZE; r++) {
    for(let c = 0; c < FIELD_SIZE; c++) {
        // x and y coordinates are the center of the 1m x 1m zone
        PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5, id: (r * FIELD_SIZE) + c + 1});
    }
}

// --- Global State Variables ---
let loggedData = [];     
let photoData = {};      
let selectedZone = 0;    
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1; // Dynamic trial number

// Global element variables (Defined in window.onload for reliability)
let STATUS_ELEMENT;
let LAST_PHOTO_STATUS;

// Initial Rover Position
let currentRoverData = {
    latitude: '0.0000', 
    longitude: '0.0000',
    heading: 0,
    x_m: 2.0, // Start center of the 4x4 grid
    y_m: 2.0  
};

// --- 10.2: FUSED AI DIAGNOSTIC KNOWLEDGE BASE ---
const TOMATO_DIAGNOSTIC_LIBRARY = {
    DISEASE_TIERS: [
        { name: "Mottling/Mosaic Pattern (Viral)", severity: 95, class: 'rec-critical', 
          visual_rec: "***CRITICAL (Viral Threat)***: High certainty of viral disease. Requires immediate isolation and removal to prevent field contamination."
        },
        { name: "Dark Spots & Lesions (Fungal/Bact)", severity: 85, class: 'rec-critical', 
          visual_rec: "***ACTION REQUIRED (Fungal/Bacterial)***: High probability of Blight or Bacterial Spot. Apply appropriate anti-fungal/bacterial treatment immediately."
        },
        { name: "General Yellowing (Chlorosis)", severity: 50, class: 'rec-action', 
          visual_rec: "ACTION: Indicates potential nutrient deficiency (N, Mg, Fe) or pH imbalance. Soil data is essential to confirm the nutrient root cause."
        },
        { name: "No Visual Symptoms Detected", severity: 0, class: 'rec-optimal', 
          visual_rec: "OPTIMAL: No visual symptoms detected. Plant appears healthy visually."
        }
    ],
    NPK_GUIDELINES: {
        moisture: { ideal_min: 40, ideal_max: 60, low_crit: 25, high_crit: 75, penalty_major: 30, low_rec: "deep watering", high_rec: "review soil drainage" },
        N: { ideal_min: 60, ideal_max: 100, low_crit: 30, high_crit: 150, penalty_major: 40, low_rec: "apply high-Nitrogen (N) feed", high_crit: "stop N-fertilizer" },
        P: { ideal_min: 50, ideal_max: 80, low_crit: 20, high_crit: 120, penalty_major: 25, low_rec: "apply Phosphorus (P) booster", high_crit: "check P excess" },
        K: { ideal_min: 70, ideal_max: 120, low_crit: 40, high_crit: 180, penalty_major: 25, low_rec: "apply Potassium (K) supplement", high_rec: "check for K salt toxicity" },
    }
};

// --- 10.3: STOCK PHOTO DATA ---
const stockPhotoData = {
    'chlorosis': { 
        data: 'data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="#FFC000"/><text x="50" y="55" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">Chlorosis</text></svg>', 
        name: 'General Yellowing (Chlorosis)', 
        severity: 50, 
        class: 'rec-action',
        visual_rec: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(t => t.severity === 50).visual_rec 
    },
    'blight': { 
        data: 'data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="#C55050"/><text x="50" y="55" font-family="Arial" font-size="12" fill="#fff" text-anchor="middle">Blight/Fungal</text></svg>', 
        name: 'Dark Spots & Lesions (Fungal/Bact)', 
        severity: 85, 
        class: 'rec-critical',
        visual_rec: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(t => t.severity === 85).visual_rec 
    },
    'healthy': { 
        data: 'data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="#6AA84F"/><text x="50" y="55" font-family="Arial" font-size="12" fill="#fff" text-anchor="middle">Healthy</text></svg>', 
        name: 'No Visual Symptoms Detected', 
        severity: 0, 
        class: 'rec-optimal',
        visual_rec: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(t => t.severity === 0).visual_rec
    }
};

// --- 10.4: UTILITY & COMMAND FUNCTIONS ---

function getHealthColorHex(status) {
    switch (status) {
        case 'Good': return 0x6AA84F; 
        case 'Caution': return 0xFFC000; 
        case 'Bad': return 0xC55050; 
        default: return 0x5a5a5a;
    }
}

function updateRoverPositionUI(moisture = null, npk_n = null, npk_p = null, npk_k = null, heading = null) {
    document.getElementById('latitudeData').innerText = currentRoverData.latitude || '---';
    document.getElementById('longitudeData').innerText = currentRoverData.longitude || '---';
    document.getElementById('headingData').innerText = (heading !== null ? heading.toFixed(0) : currentRoverData.heading.toFixed(0)) + ' deg';
    
    if (moisture !== null) {
        document.getElementById('moistureData').innerText = moisture.toFixed(1) + '%';
        document.getElementById('npkData').innerText = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
    } else {
        document.getElementById('moistureData').innerText = '---';
        document.getElementById('npkData').innerText = '---';
    }
}

function getNearestPlant(x, y) {
    let nearest = null; 
    let minDistSq = Infinity;
    PLANT_LOCATIONS_M.forEach(plant => {
        let dx = plant.x - x; 
        let dy = plant.y - y; 
        let distSq = dx * dx + dy * dy;
        if (distSq < 0.707 * 0.707 && distSq < minDistSq) { // 0.707m is approx half the diagonal of a 1m square
            minDistSq = distSq; 
            nearest = plant; 
        }
    });
    return nearest;
}

async function checkConnectionStatus() {
     STATUS_ELEMENT.innerText = `Attempting to connect to Rover API at ${ESP32_IP}...`;
    try {
        // Mock connection check
        await new Promise(resolve => setTimeout(resolve, 500)); 
        STATUS_ELEMENT.innerText = `Connection successful (API responded). Ready for commands.`;
    } catch (error) {
        STATUS_ELEMENT.innerText = `ERROR: Connection to Rover API FAILED. Is the ESP32 at ${ESP32_IP} powered on and on the network?`;
        console.error('Connection Check Error:', error);
    }
}

/** * @function sendCommand
 * @description Sends a command to the Rover unit (includes arm controls and mock data acquisition).
 **/
function sendCommand(command) {
    
    // 1. Movement Commands (Simulated)
    if (['forward', 'backward', 'left', 'right', 'stop'].includes(command)) {
        const step = 0.25; 
        const rad = currentRoverData.heading * Math.PI / 180;
        let newX = parseFloat(currentRoverData.x_m);
        let newY = parseFloat(currentRoverData.y_m);
        let newHeading = currentRoverData.heading;

        if (command === 'forward') { newX += step * Math.cos(rad); newY += step * Math.sin(rad); }
        else if (command === 'backward') { newX -= step * Math.cos(rad); newY -= step * Math.sin(rad); }
        else if (command === 'left') { newHeading = (newHeading - 30 + 360) % 360; }
        else if (command === 'right') { newHeading = (newHeading + 30) % 360; }

        currentRoverData.x_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newX)).toFixed(2);
        currentRoverData.y_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newY)).toFixed(2);
        currentRoverData.heading = newHeading;
        
        updateRoverPositionUI();
        drawMap();
        updateRover3DPosition();
        STATUS_ELEMENT.innerText = `Command '${command}' Sent. Position simulated to (${currentRoverData.x_m}m, ${currentRoverData.y_m}m).`;
    }
    
    // 2. Data Acquisition Commands
    else if (command === 'extendArm') {
        STATUS_ELEMENT.innerText = `Arm **EXTEND** command sent. Preparing for probe sequence.`;
    }
    else if (command === 'retractArm') {
        STATUS_ELEMENT.innerText = `Arm **RETRACT** command sent. Stowing probe.`;
    }
    else if (command === 'probe') {
        STATUS_ELEMENT.innerText = `Probe command sent. Awaiting data push to ThingSpeak/Rover API...`;

        const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
        if (nearestPlant) {
            let dataIndex = loggedData.findIndex(d => d.zoneId === nearestPlant.id);

            // Case A: Log a placeholder if new
            if (dataIndex === -1) {
                loggedData.push({
                    zoneId: nearestPlant.id,
                    x_m: parseFloat(currentRoverData.x_m), 
                    y_m: parseFloat(currentRoverData.y_m), 
                    healthStatus: 'Initial',
                    moisture: 0, npk_n: 0, npk_p: 0, npk_k: 0, 
                    timestamp: new Date().toLocaleTimeString()
                });
                dataIndex = loggedData.length - 1;
            }

            // Case B: Simulate data reception for an existing or new placeholder
            const mockData = {
                moisture: 30 + Math.floor(Math.random() * 50), 
                npk_n: 40 + Math.floor(Math.random() * 80),
                npk_p: 30 + Math.floor(Math.random() * 60),
                npk_k: 50 + Math.floor(Math.random() * 90)
            };
            loggedData[dataIndex] = { ...loggedData[dataIndex], ...mockData };

            updateRoverPositionUI(mockData.moisture, mockData.npk_n, mockData.npk_p, mockData.npk_k);
            fetchAIResults(); 
            STATUS_ELEMENT.innerText = `SUCCESS: Zone ${nearestPlant.id} data received. NPK: ${mockData.npk_n}/${mockData.npk_p}/${mockData.npk_k}.`;

        } else {
            STATUS_ELEMENT.innerText = `Probe failed: Rover is not close enough to a marked plant zone center.`;
        }
    } 
    
    // 3. Image Capture Command (Simulated)
    else if (command === 'capture') {
        STATUS_ELEMENT.innerText = `Camera capture requested. Awaiting photo data transfer...`;
        LAST_PHOTO_STATUS.innerText = 'Request Sent (Awaiting image data)';
        
        const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
        if (nearestPlant) {
             STATUS_ELEMENT.innerText += ` Photo request tagged to Zone ${nearestPlant.id}.`;
             
             // Log a mock photo data (as a string to signify manual/live capture)
             const tempPhotoBase64 = 'data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="#3D3D3D"/><text x="50" y="55" font-family="Arial" font-size="12" fill="#9CDCFE" text-anchor="middle">LIVE PHOTO</text></svg>';
             // Store the data as a simple string for manual/live capture
             photoData[nearestPlant.id] = tempPhotoBase64;
             renderPhotoInCell(nearestPlant.id, tempPhotoBase64);
             fetchAIResults();
             LAST_PHOTO_STATUS.innerText = `Photo Received and Logged for Zone ${nearestPlant.id}`;
             selectedZone = 0; // Clear zone selection after capture
        } else {
             STATUS_ELEMENT.innerText += ` Photo request sent (Not close to any plant zone).`;
             LAST_PHOTO_STATUS.innerText = 'Request received, but no zone assigned.';
        }
    }
}

function clearMapData(resetRover = true) {
    loggedData = []; 
    photoData = {};
    if (resetRover) { 
        currentRoverData.x_m = 2.0; 
        currentRoverData.y_m = 2.0; 
        currentRoverData.heading = 0; 
    }
    drawMap(); 
    draw3DMap(); 
    loadCurrentPhotoData(); 
    fetchAIResults(); 
    updateRoverPositionUI();
    STATUS_ELEMENT.innerText = "Map data, rover logs, and photos cleared. System ready.";
}

// --- 10.5: 2D/3D MAP DRAWING FUNCTIONS (Verbose Implementation) ---

let scene, camera, renderer, rover3D, controls;
let dataCubes = {};

function initThreeD() {
    const container = document.getElementById('threeDContainer');
    scene = new THREE.Scene(); 
    scene.background = new THREE.Color(0x1a1a1a);
    camera = new THREE.PerspectiveCamera(75, 480 / 480, 0.1, 100); 
    camera.position.set(2, 6, 2); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(480, 480);
    container.innerHTML = ''; 
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.maxPolarAngle = Math.PI / 2.2;

    const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
    gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2); 
    scene.add(gridHelper);

    const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
    const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
    rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
    rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m); 
    scene.add(rover3D);
    
    scene.add(new THREE.AmbientLight(0x404040, 2)); 
    scene.add(new THREE.DirectionalLight(0xffffff, 1.5));
    
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    if(controls) controls.update(); 
    renderer.render(scene, camera);
}

function updateRover3DPosition() {
    if (rover3D) {
        rover3D.position.set(parseFloat(currentRoverData.x_m), 0.05, parseFloat(currentRoverData.y_m));
        rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
    }
}

function draw3DMap() {
    Object.values(dataCubes).forEach(cube => { 
        scene.remove(cube); 
        cube.geometry.dispose(); 
        cube.material.dispose(); 
    });
    dataCubes = {};

    loggedData.forEach((data, index) => {
        const { x_m, y_m, moisture, healthStatus } = data;
        
        const cubeHeight = Math.max(0.5, moisture / MAX_MOISTURE * 3); 
        const colorHex = getHealthColorHex(healthStatus);
        
        const geometry = new THREE.BoxGeometry(0.5, cubeHeight, 0.5);
        const material = new THREE.MeshPhongMaterial({ 
            color: colorHex, 
            opacity: 0.8, 
            transparent: true 
        });
        const cube = new THREE.Mesh(geometry, material);
        
        cube.position.set(x_m, cubeHeight / 2, y_m); 
        dataCubes[index] = cube; 
        scene.add(cube);
    });
    updateRover3DPosition();
}

function drawMap() { 
    CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE); 
    CTX.strokeStyle = '#5a5a5a'; 
    CTX.lineWidth = 1;
    // Draw Grid Lines
    for (let i = 0; i <= FIELD_SIZE; i++) {
        let p = i * PIXELS_PER_METER;
        CTX.beginPath(); CTX.moveTo(p, 0); CTX.lineTo(p, MAP_SIZE); CTX.stroke(); 
        CTX.beginPath(); CTX.moveTo(0, p); CTX.lineTo(MAP_SIZE, p); CTX.stroke(); 
    }
    // Draw Logged Data Points (Circles)
    loggedData.forEach(data => {
        let x_px = data.x_m * PIXELS_PER_METER;
        let y_px = MAP_SIZE - (data.y_m * PIXELS_PER_METER); 
        CTX.beginPath();
        CTX.arc(x_px, y_px, 12, 0, 2 * Math.PI);
        CTX.fillStyle = '#' + getHealthColorHex(data.healthStatus).toString(16).padStart(6, '0'); 
        CTX.fill(); 
        CTX.strokeStyle = 'white'; 
        CTX.lineWidth = 2; 
        CTX.stroke();
    });
    // Draw Rover Triangle
    let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
    let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
    let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180); 
    let size = 15;
    CTX.save(); CTX.translate(rover_x_px, rover_y_px); CTX.rotate(heading_rad);
    CTX.beginPath(); CTX.moveTo(size, 0); CTX.lineTo(-size * 0.5, -size * 0.7); CTX.lineTo(-size * 0.5, size * 0.7);
    CTX.closePath();
    CTX.fillStyle = 'var(--color-primary)'; CTX.fill(); CTX.strokeStyle = 'var(--color-text-highlight)'; CTX.lineWidth = 2; CTX.stroke(); CTX.restore();
}


// --- 10.6: FUSED AI ANALYSIS LOGIC (UPDATED for PARTIAL ANALYSIS) ---

function getNearestSensorData(x, y) {
    const nearest = getNearestPlant(x, y);
    if (nearest) {
        return loggedData.find(d => d.zoneId === nearest.id);
    }
    return null;
}

function getPhotoPrediction(photoEntry) {
    // Case 1: Stock Photo (object with predictionKey)
    if (typeof photoEntry === 'object' && photoEntry.predictionKey) {
        const data = stockPhotoData[photoEntry.predictionKey];
        return {
            name: data.name,
            severity: data.severity,
            class: data.class,
            visual_rec: data.visual_rec || TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(t => t.severity === data.severity).visual_rec
        };
    }
    
    // Case 2: Manual Upload (Base64 string) or Live Photo Capture
    // We treat it as a generic photo that has been uploaded but not yet AI-analyzed, use a default severity 
    return {
        name: "Photo Uploaded (AI Analysis Pending - Assumed Healthy for now)",
        severity: 10, // Default low severity for unanalyzed manual photo
        class: 'rec-initial',
        visual_rec: "Photo successfully logged. Visual analysis is PENDING the AI backend system response."
    };
}


/** * @function analyzePlant
 * @description Core logic for Fused Analysis, generating separate visual/partial and fused/final recommendations.
 **/
function analyzePlant(plant, sensorData, photoEntry) {
    let soilScore = 100; 
    let soilProblems = [];
    let sensorDiagnosis = "Soil: Sensor Data Missing"; 
    let visualDiagnosis = "Visual: No Photo Taken";
    let visualRecommendation = 'No photo provided. Visual diagnosis cannot be performed.'; 
    let fusedRecommendation = 'Awaiting both photo and soil sensor data for a comprehensive fused recommendation.'; 
    let healthClass = 'rec-initial';
    let finalScore = 5; 
    let photoExists = !!photoEntry;
    let visualPrediction = null;
    const realSensorDataAvailable = sensorData && sensorData.moisture > 0;

    // --- 1. Process Visual Data and Set Initial Score ---
    if (photoExists) {
        visualPrediction = getPhotoPrediction(photoEntry);
        visualDiagnosis = `Visual: ${visualPrediction.name}`;
        visualRecommendation = visualPrediction.visual_rec;
        // Start final score based on visual severity
        finalScore = Math.max(10, 100 - visualPrediction.severity); 
        healthClass = visualPrediction.class;
    }

    // --- 2. Fused Recommendation Logic ---
    if (!photoExists && !realSensorDataAvailable) {
        // Case A: No data at all (Default initial values are already set)
    }
    else if (photoExists && !realSensorDataAvailable) {
        // Case B: Photo exists, but no real sensor data (PARTIAL ANALYSIS - **Updated Logic**)
        const assessment = visualPrediction.name.split('(')[0].trim();
        const recClass = visualPrediction.class;
        
        // Set score based on visual severity
        finalScore = Math.max(20, 100 - visualPrediction.severity); 
        healthClass = recClass; 
        
        // Explicitly state partial analysis with the visual assessment and need for soil data
        fusedRecommendation = `***PARTIAL ANALYSIS (${finalScore}/100)***: **Crop Health Assessment:** Plant visually assessed as '${assessment}'. **ACTION REQUIRED:** To ensure diagnosis accuracy and provide a full recommendation, deploy the **Soil Probe** to fuse NPK and Moisture data.`;

    }
    else if (realSensorDataAvailable) {
        // Case C: Real Sensor Data is available (Run full Fused Analysis)
        
        // C1. Soil Scoring Logic
        const { moisture, npk_n, npk_p, npk_k } = sensorData;
        const data = { moisture, N: npk_n, P: npk_p, K: npk_k };
        const keys = ['moisture', 'N', 'P', 'K'];
        const guid = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES;

        keys.forEach(key => {
            const guideline = guid[key]; 
            const value = data[key]; 
            if (key !== 'moisture' && (value < guideline.low_crit || value > guideline.high_crit)) { 
                soilScore -= guideline.penalty_major; 
                soilProblems.push({ problem: `CRITICAL ${key}`, rec: value < guideline.low_crit ? guideline.low_rec : guideline.high_rec });
            } else if (key === 'moisture' && (value < guideline.low_crit || value > guideline.high_crit)) { 
                 soilScore -= (guideline.penalty_major / 2); // Less penalty for moisture
                 soilProblems.push({ problem: `Moisture CRITICAL`, rec: value < guideline.low_crit ? guideline.low_rec : guideline.high_rec });
            } else if (value < guideline.ideal_min || value > guideline.ideal_max) { 
                soilScore -= (guideline.penalty_major / 4); // Minor penalty
                soilProblems.push({ problem: `${key} Imbalance`, rec: value < guideline.ideal_min ? guideline.low_rec : guideline.high_rec });
            }
        });
        sensorDiagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;

        // C2. Combine Scores (Take the lower of the two systems: Visual vs. Soil)
        finalScore = photoExists ? Math.min(finalScore, soilScore) : soilScore;

        // C3. Final Fused Recommendation Logic
        if (photoExists && visualPrediction && visualPrediction.severity >= 80) {
            // High-Priority Override: Critical Visual Disease
            fusedRecommendation = `***FUSED CRITICAL***: ${visualPrediction.name}. **Soil check:** ${soilProblems.length > 0 ? soilProblems.map(p => p.problem).join(', ') : 'OK'}. VISUAL DIAGNOSIS OVERRIDES. Follow isolation protocol.`;
            healthClass = visualPrediction.class;
        } else if (soilProblems.length > 0) {
            // Secondary Priority: Soil Issues
            const recString = soilProblems.map(p => `${p.problem}: ${p.rec}`).join('; ');
            fusedRecommendation = `***FUSED ACTION REQUIRED***: ${recString}. **Visual check:** ${visualDiagnosis.replace('Visual:', '')}. Address soil imbalance first.`;
            healthClass = finalScore <= 60 ? 'rec-action' : 'rec-optimal';
        } else {
            // Default: Healthy/Optimal
            fusedRecommendation = "OPTIMAL: All sensor and visual metrics are within healthy parameters. Continue regular monitoring.";
            healthClass = 'rec-optimal';
            finalScore = 95;
        }
    }
    
    // Case D: Data exists, but no photo
    if (!photoExists && realSensorDataAvailable) {
        visualRecommendation = 'No photo provided. Visual diagnosis pending.';
        if (soilProblems.length > 0) {
            const recString = soilProblems.map(p => `${p.problem}: ${p.rec}`).join('; ');
            fusedRecommendation = `***FUSED ACTION REQUIRED (Soil Only)***: ${recString}. Deploy camera to check for visual symptoms.`;
            healthClass = finalScore <= 60 ? 'rec-action' : 'rec-optimal';
        } else {
            fusedRecommendation = "OPTIMAL: Soil sensor data is perfect. Deploy camera for visual confirmation.";
            healthClass = 'rec-optimal';
        }
    }

    // Set a minimum score
    finalScore = Math.max(10, finalScore);

    return { 
        id: plant.id, 
        score: finalScore.toFixed(0), 
        visualDiagnosis, 
        sensorDiagnosis, 
        visualRecommendation: visualRecommendation.trim(), 
        fusedRecommendation: fusedRecommendation.trim(), 
        healthClass 
    };
}

function fetchAIResults() {
    const analysisGrid = document.getElementById('plantAnalysisGrid');
    analysisGrid.innerHTML = '';
    
    PLANT_LOCATIONS_M.forEach(plant => {
        const sensorData = getNearestSensorData(plant.x, plant.y);
        const photoEntry = photoData[plant.id] || null;
        const analysis = analyzePlant(plant, sensorData, photoEntry);

        if (sensorData) {
            const loggedIndex = loggedData.findIndex(d => d.zoneId === plant.id);
            if (loggedIndex !== -1) {
                // Update health status on the map based on the analysis
                loggedData[loggedIndex].healthStatus = analysis.healthClass.replace('rec-', '').charAt(0).toUpperCase() + analysis.healthClass.slice(4);
            }
        }

        const card = `
        <div class="analysis-card">
            <div class="plant-id-label">Zone ${analysis.id}</div>
            <div class="data-row">
                <strong>Overall Health Score:</strong> <span>${analysis.score}/100</span>
            </div>
            <div class="data-row">
                <strong>Leaf AI Diagnosis:</strong> <span>${analysis.visualDiagnosis}</span>
            </div>
            <div class="data-row">
                <strong>Soil Sensor Data:</strong> <span>${analysis.sensorDiagnosis}</span>
            </div>
            <div style="margin-top: 15px;">
                <strong>1. VISUAL/PARTIAL REC:</strong> 
                <span class="rec-text rec-initial">${analysis.visualRecommendation}</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>2. FUSED/FINAL REC:</strong> 
                <span class="rec-text ${analysis.healthClass}">${analysis.fusedRecommendation}</span>
            </div>
        </div>
        `;
        analysisGrid.insertAdjacentHTML('beforeend', card);
    });
    drawMap();
    draw3DMap(); 
}

// --- 10.7: PHOTO & MODAL LOGIC (FIXED Stock Image Flow) ---

function generatePhotoGrid() {
    const grid = document.getElementById('photoGrid');
    for (let i = 1; i <= 16; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell'; 
        cell.id = `zone-${i}`;
        cell.innerHTML = `<span class="cell-label">${i}</span><button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>`;
        // Click sets zone AND triggers manual file input
        cell.setAttribute('onclick', `preparePhotoUpload(${i})`); 
        grid.appendChild(cell);
    }
}

function preparePhotoUpload(zoneId) { 
    selectedZone = zoneId; 
    STATUS_ELEMENT.innerText = `Zone ${zoneId} selected. Select a file for manual upload or click '📚 Stock Photo Gallery'.`;
    // Automatically trigger file input for manual upload flow
    document.getElementById('fileInput').click(); 
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file && selectedZone !== 0) {
        const reader = new FileReader();
        reader.onload = function(e) {
            // Store as string for manual/live upload
            photoData[selectedZone] = e.target.result;
            renderPhotoInCell(selectedZone, e.target.result);
            STATUS_ELEMENT.innerText = `Custom photo uploaded and assigned to Zone ${selectedZone}. Analysis running...`;
            selectedZone = 0; 
            event.target.value = ''; 
            fetchAIResults(); 
        };
        reader.readAsDataURL(file);
    } else {
        // File selection cancelled
        selectedZone = 0;
    }
}

function renderPhotoInCell(zoneId, photoEntry) {
    // Check if it's the object format (stock photo) or string format (manual/live)
    const base64Image = typeof photoEntry === 'object' ? photoEntry.base64 : photoEntry; 
    const cell = document.getElementById(`zone-${zoneId}`); 
    if (!cell) return;
    cell.querySelectorAll('.cell-photo').forEach(el => el.remove());
    
    const zoneLabel = cell.querySelector('.cell-label'); 
    const deleteBtn = cell.querySelector('.delete-photo-btn');
    
    if (base64Image) {
        const img = document.createElement('img'); 
        img.src = base64Image; 
        img.className = 'cell-photo';
        cell.appendChild(img);
        if (zoneLabel) zoneLabel.style.display = 'none'; 
        if (deleteBtn) deleteBtn.style.display = 'block';
    } else {
        if (zoneLabel) zoneLabel.style.display = 'block'; 
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
}

function deletePhoto(zoneId) { 
    delete photoData[zoneId]; 
    renderPhotoInCell(zoneId, null); 
    fetchAIResults(); 
    STATUS_ELEMENT.innerText = `Photo cleared from Zone ${zoneId}. Analysis updated to 'No Photo'.`;
}

function loadCurrentPhotoData() { 
    for (let i = 1; i <= 16; i++) { 
        renderPhotoInCell(i, photoData[i] || null); 
    } 
}

// --- Stock Photo/Gallery Functions (FIXED & Renamed) ---
function openStockPhotoModal() {
    
    // 1. Check/Set Selected Zone
    if (selectedZone === 0) {
        const nearest = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
        if (nearest) {
            selectedZone = nearest.id;
        } 
    }
    
    document.getElementById('currentStockZone').innerText = selectedZone !== 0 ? selectedZone : '---';
    const list = document.getElementById('stockPhotoList');
    list.innerHTML = '';
    
    // Update modal title to reflect the zone selection
    document.querySelector('#stockPhotoModal h2').innerHTML = `Stock Photo Gallery & Assignment for Zone ${selectedZone !== 0 ? selectedZone : '---'}`;
    
    // 2. Populate Stock Images
    list.innerHTML += '<h3>Stock Photo Library</h3><p style="font-size:0.9em; color:#9CDCFE;">(Click a photo below to assign its known diagnosis to the selected zone.)</p><div class="stock-image-container" style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 10px;">';
    
    const stockImageContainer = list.querySelector('.stock-image-container');

    Object.keys(stockPhotoData).forEach(key => {
        const data = stockPhotoData[key];

        const item = document.createElement('div');
        item.style.textAlign = 'center';
        item.style.cursor = 'pointer';
        item.style.width = '150px';
        item.style.border = '2px solid #5a5a5a';
        item.style.borderRadius = '10px';
        item.style.padding = '5px';
        item.innerHTML = `<img src="${data.data}" style="width: 140px; height: 140px; object-fit: cover; border-radius: 6px; border: 3px solid ${data.class === 'rec-action' ? '#FFC000' : (data.class === 'rec-critical' ? '#C55050' : '#6AA84F')};">
                          <p style="margin: 8px 0 0; font-size: 1.0em; font-weight: bold; color: var(--color-text-highlight);">${data.name.split('(')[0]}</p>`;
        item.onclick = () => {
            if (selectedZone !== 0) {
                assignStockPhoto(selectedZone, key);
            } else {
                STATUS_ELEMENT.innerText = '🚨 Please select a Zone (1-16) on the main grid first or move the rover closer to a plant zone!';
                alert('Please select a Zone (1-16) on the main grid first!');
            }
        };
        stockImageContainer.appendChild(item);
    });
    
    // 3. Display Currently Uploaded Photos in a 4x4 Grid (Requested format)
    list.innerHTML += '<h3 style="margin-top: 30px; border-top: 1px solid #3C3C3C; padding-top: 15px;">Currently Assigned Photos (Current Trial: Zones 1-16)</h3><p style="font-size:0.9em; color:#FF8C00;">(These are your live/manual uploads assigned to their zones, shown for reference in a 4x4 grid.)</p>';
    
    const assignedPhotoGallery = document.createElement('div');
    assignedPhotoGallery.className = 'assigned-photo-grid'; // STRICT 4x4 GRID
    
    PLANT_LOCATIONS_M.forEach(plant => {
        const zoneId = plant.id;
        const photoEntry = photoData[zoneId];
        const item = document.createElement('div');
        item.style.textAlign = 'center';
        item.style.backgroundColor = '#252526';
        item.style.borderRadius = '8px';
        item.style.padding = '5px';
        item.style.height = '100%'; // Ensure full height for grid cell
        item.style.position = 'relative';

        const base64Image = photoEntry ? (typeof photoEntry === 'object' ? photoEntry.base64 : photoEntry) : null;
        
        if (base64Image) {
            item.innerHTML = `<img src="${base64Image}" style="width: 100%; height: 80%; object-fit: cover; border-radius: 4px;">
                              <p style="margin: 3px 0 0; font-size: 0.8em; color: white;">Zone ${zoneId}</p>`;
        } else {
            item.innerHTML = `<p style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; color: #5a5a5a;">${zoneId}</p><p style="position: absolute; bottom: 5px; width: 100%; font-size: 0.8em; color: #5a5a5a;">No Photo</p>`;
        }
        assignedPhotoGallery.appendChild(item);
    });
    list.appendChild(assignedPhotoGallery);

    document.getElementById('stockPhotoModal').style.display = "flex";
}
function closeStockPhotoModal() { document.getElementById('stockPhotoModal').style.display = "none"; }

function assignStockPhoto(zoneId, photoKey) {
    const data = stockPhotoData[photoKey];
    if (data) {
        // Store the image data and the key for prediction lookup (as an object)
        photoData[zoneId] = {
            base64: data.data,
            predictionKey: photoKey
        };
        renderPhotoInCell(zoneId, photoData[zoneId]);
        STATUS_ELEMENT.innerText = `Stock photo '${data.name}' assigned to Zone ${zoneId}. Analysis running...`;
        selectedZone = 0; 
        closeStockPhotoModal();
        fetchAIResults();
    }
}


// --- 10.8: HISTORY LOGIC (Full implementation with 50 trial limit) ---

function saveCurrentTrial() {
    if (trialHistory.length >= MAX_TRIALS) {
        STATUS_ELEMENT.innerText = `Trial limit (${MAX_TRIALS}) reached. Please clear history to continue saving new trials.`;
        return; 
    }
    
    const trialId = trialHistory.length + 1;
    const trialData = {
        id: trialId, 
        date: new Date().toLocaleString(), 
        roverData: { ...currentRoverData },
        loggedData: [...loggedData], 
        // Photo data is saved and "redirected" with the trial
        photoData: JSON.parse(JSON.stringify(photoData)), 
        aiData: { analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML } 
    };
    trialHistory.push(trialData);
    localStorage.setItem('trialHistory', JSON.stringify(trialHistory));
    
    currentTrialNumber = trialId + 1;
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
    STATUS_ELEMENT.innerText = `Trial ${trialId} saved successfully! Starting new trial...`;
    
    loggedData = []; 
    photoData = {}; 
    clearMapData(false); // Reset map data for the new trial
}

function openHistoryModal() {
    const modal = document.getElementById('historyModal'); 
    const list = document.getElementById('trialHistoryList');
    list.innerHTML = '';
    
    if (trialHistory.length === 0) { 
        list.innerHTML = `<p style="color: #FFC000; font-style: italic;">No trial data saved yet. Run some tests and press "Save & New Trial". (${MAX_TRIALS} slots available)</p>`; 
    } else {
        list.innerHTML += `<p style="color: var(--color-text-highlight);">Showing ${trialHistory.length} of ${MAX_TRIALS} possible trial slots:</p>`;
        [...trialHistory].reverse().forEach(trial => { 
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.style.marginBottom = '12px';
            item.style.padding = '12px';
            item.style.borderBottom = '1px solid #3C3C3C';
            item.style.backgroundColor = '#1a1a1a';
            item.style.borderRadius = '6px';
            item.innerHTML = `<span><strong>Trial ${trial.id}:</strong> ${trial.date} (${Object.keys(trial.photoData).length} photos, ${trial.loggedData.length} sensor readings)</span>
                <button onclick="loadPastTrial(${trial.id})" style="float:right; background-color:#FF8C00; color:white; padding: 6px 10px; font-size: 0.8em; margin: 0;">Load Trial ${trial.id}</button>`;
            list.appendChild(item);
        });
        
        if (trialHistory.length < MAX_TRIALS) {
             list.innerHTML += `<p style="margin-top: 20px; color: #5a5a5a; font-size:0.9em;">**${MAX_TRIALS - trialHistory.length}** trial slots are still available out of **${MAX_TRIALS}** total slots.</p>`;
        }
    }
    modal.style.display = "flex";
}
function closeHistoryModal() { document.getElementById('historyModal').style.display = "none"; }

function loadPastTrial(trialId) {
    const trial = trialHistory.find(t => t.id === trialId); 
    if (!trial) return;
    
    currentRoverData = trial.roverData;
    updateRoverPositionUI(null, null, null, null, currentRoverData.heading); 
    loggedData = trial.loggedData; 
    photoData = trial.photoData; 
    
    document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;
    drawMap(); 
    draw3DMap(); 
    loadCurrentPhotoData();

    STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
    document.getElementById('currentTrialNumber').innerText = `${currentTrialNumber} (Viewing Trial ${trialId})`;
    closeHistoryModal();
}

function clearAllHistory() {
    if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
        localStorage.removeItem('trialHistory');
        trialHistory = []; 
        currentTrialNumber = 1;
        document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
        closeHistoryModal();
        STATUS_ELEMENT.innerText = "All trial history cleared.";
    }
}


// --- 10.9: INITIALIZATION ---

window.onload = function() {
    // 1. Define global element variables
    STATUS_ELEMENT = document.getElementById('status');
    LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');
    
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;

    // 2. Initialize 3D renderer
    initThreeD(); 
    
    // 3. Draw the 2D field map
    drawMap(); 
    
    // 4. Build the 4x4 photo upload grid
    generatePhotoGrid(); 
    
    // 5. Load any previously saved photos (if loading history)
    loadCurrentPhotoData();
    
    // 6. Run the first analysis (populates 'No Data' cards or analysis from loaded trial)
    fetchAIResults(); 
    
    // 7. Ensure UI placeholders are set
    updateRoverPositionUI(); 
    
    STATUS_ELEMENT.innerText = "System Initialized. No live connection. Ready for Movement, Data Acquisition, and Photo Logging.";
};
</script>
</body>
</html>
