<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.C.O.U.T. Rover Mapping & Control (3D Enabled)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* BASE STYLING (Dark Theme) */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #1e1e1e; color: #d4d4d4; }
        .container { max-width: 1700px; margin: auto; background: #2d2d30; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); display: flex; flex-wrap: wrap; }
        
        /* LAYOUT PANELS - Adjusted widths for 3D map */
        .controls-panel { flex: 1; min-width: 350px; padding-right: 20px; }
        .map-panel { flex: 1; min-width: 450px; }
        .photo-panel { flex: 1; min-width: 450px; padding-left: 20px; border-left: 1px solid #3c3c3c; } 
        .map-3d-panel { flex: 1; min-width: 450px; margin-top: 20px; }
        
        /* TYPOGRAPHY & HEADERS */
        h1 { color: #569cd6; border-bottom: 3px solid #3c3c3c; padding-bottom: 10px; }
        h2 { color: #4ec9b0; margin-top: 20px; }
        h3 { color: #c8c8c8; margin-top: 10px; }
        #status { font-weight: bold; color: #ffcc00; }

        /* BUTTONS */
        button { padding: 12px 18px; margin: 8px 5px; cursor: pointer; border: none; border-radius: 6px; font-weight: bold; transition: background-color 0.2s; }
        .move-controls button { background-color: #569cd6; color: white; }
        .arm-controls button { background-color: #6a9955; color: white; }
        .camera-control button { background-color: #ce4257; color: white; }
        
        /* DATA DISPLAY */
        .data-display { margin-top: 20px; padding: 15px; border: 1px solid #3c3c3c; border-radius: 6px; background-color: #252526; }
        .data-row strong { display: inline-block; width: 140px; color: #9cdcfe; }
        
        /* CANVAS MAP (2D) */
        #roverMap { border: 3px solid #6a9955; background-color: #3d3d3d; display: block; margin: 20px auto 0; }

        /* 3D MAP CANVAS */
        #threeDContainer { 
            width: 450px; 
            height: 450px; 
            border: 3px solid #569cd6; 
            background-color: #1a1a1a; 
            margin: 20px auto 0;
            display: block;
        }

        /* 4x4 PHOTO GRID STYLES */
        #photoGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 5px;
            border: 2px solid #569cd6;
            max-width: 450px;
            margin: 20px auto;
            aspect-ratio: 1 / 1; 
            background-color: #252526;
        }
        .grid-cell {
            background-color: #3d3d3d;
            border: 1px solid #4ec9b0;
            position: relative;
            /* ... other styles remain ... */
        }
        .cell-photo {
             /* ... other styles remain ... */
        }
    </style>
</head>
<body>

<div class="container">
    <div class="controls-panel">
        <h1>S.C.O.U.T. Rover Control</h1>
        <p>System Status: <span id="status">Connecting...</span></p>

        <div id="ai-analysis">
            <h2>Comprehensive Analysis üß†</h2>
            <p><strong>Last Update Time:</strong> <span id="ai-time">N/A</span></p>
            
            <h3>Image Analysis</h3>
            <p><strong>Crop Health Score:</strong> <span id="ai-health">N/A</span></p>
            
            <h3>Overall Recommendation</h3>
            <p><strong>Action Required:</strong> <span id="ai-recommendation">N/A</span></p>
        </div>

        <div class="move-controls">
            <h2>Rover Movement</h2>
            <button onclick="sendCommand('forward')">Forward (‚Üë)</button>
            <button onclick="sendCommand('stop')">üõë STOP</button>
            <button onclick="sendCommand('backward')">Backward (‚Üì)</button><br>
            <button onclick="sendCommand('left')">Left (‚Üê)</button>
            <button onclick="sendCommand('right')">Right (‚Üí)</button>
        </div>

        <hr style="border-top: 1px solid #3c3c3c;">

        <div class="arm-controls">
            <h2>Data Acquisition</h2>
            <button onclick="sendCommand('probe')">üî¨ Probe Soil (Arm Down)</button>
            <button onclick="sendCommand('read_sensors')">üíß Read Soil Data</button>
            <button onclick="sendCommand('read_nav')">üß≠ Get GPS/Heading</button>
        </div>

        <hr style="border-top: 1px solid #3c3c3c;">

        <div class="data-display">
            <h2>Live Sensor Data</h2>
            
            <h3>Navigation Data</h3>
            <div class="data-row"><strong>Latitude:</strong> <span id="latitudeData">N/A</span></div>
            <div class="data-row"><strong>Longitude:</strong> <span id="longitudeData">N/A</span></div>
            <div class="data-row"><strong>GPS Fix:</strong> <span id="gpsFix">No Fix</span></div>
            <div class="data-row"><strong>Heading:</strong> <span id="headingData">N/A</span></div>

            <h3>Soil Data</h3>
            <div class="data-row"><strong>Moisture:</strong> <span id="moistureData">N/A</span></div>
            <div class="data-row"><strong>NPK (N, P, K):</strong> <span id="npkData">N/A</span></div>
        </div>
    </div>

    <div class="map-panel">
        <h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
        <canvas id="roverMap" width="450" height="450"></canvas>
        <p>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Health}$. $\text{Triangle} = \text{Rover}$.</p>
        <button onclick="clearMapData()">üóëÔ∏è Clear Map Data</button>
    </div>

    <div class="map-3d-panel">
        <h2>3D Photo Map Viewer (Requires Mouse Drag)</h2>
        <div id="threeDContainer"></div>
        <p>Drag mouse to rotate. Scroll to zoom. Photos mapped to grid planes.</p>
    </div>

    <div class="photo-panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')">üì∏ Take Photo (to Dell Wyse)</button>
            <p>Last photo status: <span id="lastPhotoStatus">N/A</span>. Sent to Dell Wyse server at <span id="server-ip">192.168.X.X:5000</span>.</p>
        </div>

        <hr style="border-top: 1px solid #3c3c3c;">

        <h2>Manual Photo Upload Map (Zones 1-16)</h2>
        <p>Click a zone below to manually upload a photo for that $\mathbf{1\text{m} \times 1\text{m}}$ area.</p>
        <div id="photoGrid">
            </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
        <p><small>Note: Uploaded photos are stored locally in your browser's memory/cache.</small></p>
    </div>
</div>

<script>
    // JAVASCRIPT LOGIC
    
    // !!! CONFIGURE YOUR IPs HERE !!!
    const ESP32_IP = '192.168.1.50'; 
    const DELL_WYSE_IP = 'http://192.168.X.X:5000'; 
    
    const ESP32_URL_BASE = `http://${ESP32_IP}`;
    const STATUS_ELEMENT = document.getElementById('status');
    const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');
    
    document.getElementById('server-ip').innerText = DELL_WYSE_IP.replace('http://', ''); 

    // --- MAP CONSTANTS (4m x 4m) ---
    const FIELD_SIZE = 4; // 4 meters
    const MAP_CANVAS = document.getElementById('roverMap');
    const CTX = MAP_CANVAS.getContext('2d');
    const MAP_SIZE = 450; 
    const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
    
    // Plant locations in meters
    const PLANT_LOCATIONS_M = [];
    for(let r=0; r<FIELD_SIZE; r++) for(let c=0; c<FIELD_SIZE; c++) PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5});

    let loggedData = []; 
    let selectedZone = 0; 
    const ZONE_COORDS = {}; // Maps Zone ID (1-16) to 3D position (x, z)
    for(let i=1; i<=16; i++) {
        let row = Math.floor((i - 1) / FIELD_SIZE);
        let col = (i - 1) % FIELD_SIZE;
        // Coordinates in meters (0,0 is bottom-left, matching 2D map logic)
        ZONE_COORDS[i] = { x: col + 0.5, z: row + 0.5 }; 
    }

    let currentRoverData = {
        latitude: 'N/A', 
        longitude: 'N/A', 
        heading: 0, 
        x_m: 2.0, 
        y_m: 2.0 
    };

    // --- 3D RENDERING SETUP (THREE.JS) ---
    let scene, camera, renderer, rover3D, controls;
    let photoPlanes = {}; // Stores the 3D planes for each zone

    function initThreeD() {
        const container = document.getElementById('threeDContainer');
        const width = container.clientWidth;
        const height = container.clientHeight;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Camera setup (Looking down the field)
        camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
        camera.position.set(2, 6, 2); // Initial view above the 4m field
        camera.lookAt(2, 0, 2);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        // Add basic orbit controls for interaction
        const OrbitControls = THREE.OrbitControls || THREE.TrackballControls; // Use a basic fallback if necessary
        if (typeof THREE.OrbitControls === 'function') {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI / 2.2; // Prevent camera going under the ground
        }

        // Field Grid (Ground Plane)
        const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
        gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2);
        scene.add(gridHelper);

        // Rover Model (Simple Cube for now)
        const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
        const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
        rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
        rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m); // Y is up
        scene.add(rover3D);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if(controls) controls.update(); 
        renderer.render(scene, camera);
    }
    
    function updateRover3DPosition() {
        if (rover3D) {
            // Rover Y coordinate is aligned with the Z-axis in the 2D map, so we map 2D Y to 3D Z
            rover3D.position.set(
                parseFloat(currentRoverData.x_m), 
                0.05, 
                parseFloat(currentRoverData.y_m) 
            ); 
            rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180); // Rotate based on heading
        }
    }
    
    function addPhotoTo3DMap(zoneId, base64Image) {
        if (!scene) return;

        const { x, z } = ZONE_COORDS[zoneId];
        
        // Remove old plane if it exists
        if (photoPlanes[zoneId]) {
            scene.remove(photoPlanes[zoneId]);
            photoPlanes[zoneId].geometry.dispose();
            photoPlanes[zoneId].material.dispose();
        }

        // Create a new texture from the base64 image
        const img = new Image();
        img.onload = () => {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;

            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            // Plane dimensions (1m x 1m on the field)
            const geometry = new THREE.PlaneGeometry(1, 1); 
            const plane = new THREE.Mesh(geometry, material);

            // Position the plane to cover the 1m x 1m zone
            // Rotate X by -90 degrees to lay it flat on the X-Z plane (the ground)
            plane.rotation.x = -Math.PI / 2; 
            // Position: 2D map (0,0) is top-left, 3D map (0,0) is back-left.
            // Our 2D map uses (x, y) where y increases downwards (visually), 
            // but the underlying model has (x, y) coordinates where y increases towards the rover path.
            // We use the same (x_m, y_m) coordinates for 3D: x = x_m, z = y_m (ground plane is x-z).
            plane.position.set(x, 0.001, z); // Set slightly above the grid to prevent z-fighting

            photoPlanes[zoneId] = plane;
            scene.add(plane);
        };
        img.src = base64Image;
    }


    // ------------------------------------
    // --- PHOTO GRID FUNCTIONS ---
    // ------------------------------------
    
    function generatePhotoGrid() {
        const grid = document.getElementById('photoGrid');
        for (let i = 1; i <= 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.id = 'zone-' + i;
            cell.innerHTML = '<span class="cell-label">' + i + '</span>';
            
            cell.addEventListener('click', function() {
                selectedZone = i;
                document.getElementById('fileInput').click(); 
            });
            
            grid.appendChild(cell);
            loadPhoto(i); 
        }
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file || selectedZone === 0) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const base64Image = e.target.result;
            localStorage.setItem('zonePhoto' + selectedZone, base64Image);
            loadPhoto(selectedZone, base64Image);
            addPhotoTo3DMap(selectedZone, base64Image); // *** NEW: Add to 3D map ***
            selectedZone = 0; 
        };
        reader.readAsDataURL(file); 
    }

    function loadPhoto(zoneId, base64Image) {
        const cell = document.getElementById('zone-' + zoneId);
        if (!cell) return;
        
        if (!base64Image) {
            base64Image = localStorage.getItem('zonePhoto' + zoneId);
        }
        
        const existingPhoto = cell.querySelector('.cell-photo');
        if (existingPhoto) existingPhoto.remove();

        if (base64Image) {
            const img = document.createElement('img');
            img.src = base64Image;
            img.className = 'cell-photo';
            cell.appendChild(img);
            
            // Initial load for 3D map (on page load)
            addPhotoTo3DMap(zoneId, base64Image); 
        }
    }

    // ------------------------------------
    // --- AI and COMMUNICATION FUNCTIONS ---
    // ------------------------------------
    
    // fetchAIResults, sendCommand, and fetchData remain largely the same,
    // but fetchData now includes a call to updateRover3DPosition.

    function fetchAIResults() {
        // ... (AI results fetching logic remains the same) ...
        fetch(DELL_WYSE_IP + '/ai_results')
            .then(response => {
                if (!response.ok) { throw new Error('Dell Wyse Server returned error ' + response.status); }
                return response.json();
            })
            .then(data => {
                document.getElementById('ai-time').innerText = data.last_analysis_time || 'N/A';
                document.getElementById('ai-health').innerText = data.image_health_score || 'N/A';
                document.getElementById('ai-recommendation').innerText = data.overall_recommendation || 'N/A';
                // ... (moisture/npk data updates) ...
            })
            .catch(error => {
                // ... (error handling remains the same) ...
            });
    }

    function sendCommand(command) {
        // ... (sending command logic remains the same) ...
        let url = (command === 'capture') ? `${ESP32_URL_BASE}/capture` : `${ESP32_URL_BASE}/move?dir=${command}`;
        
        STATUS_ELEMENT.innerText = `Sending command: ${command}...`;

        fetch(url)
            .then(response => {
                if (!response.ok) { throw new Error(`HTTP Error: ${response.status}`); }
                return response.text();
            })
            .then(data => {
                STATUS_ELEMENT.innerText = `Command '${command}' Success.`;
                if (command.startsWith('read_') || command === 'probe') {
                    setTimeout(() => fetchData(command), 500); 
                    setTimeout(() => fetchAIResults(), 1000); 
                }
            })
            .catch(error => {
                STATUS_ELEMENT.innerText = `ERROR: Command ${command} failed. Is ESP32 at ${ESP32_IP} online?`;
                console.error('Error sending command:', error);
            });
    }
    
    // --- MOCK/SIMULATED DATA FETCH (Called manually by 'read' buttons) ---
    function fetchData(lastCommand = null) {
        
        STATUS_ELEMENT.innerText = "Fetching latest data...";
        
        setTimeout(() => {
            // Simulate GPS/Nav Data
             let headingStr = (Math.random() * 360).toFixed(1) + ' deg';
             currentRoverData.heading = parseFloat(headingStr.split(' ')[0]) || 0; 
             document.getElementById('latitudeData').innerText = "40.7128"; 
             document.getElementById('longitudeData').innerText = "-74.0060";
             document.getElementById('gpsFix').innerText = "3D Fix";
             document.getElementById('headingData').innerText = headingStr;

             // Simulate Rover Movement (random walk)
             if (lastCommand !== 'read_nav' && lastCommand !== 'stop') {
                 currentRoverData.x_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.x_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
                 currentRoverData.y_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.y_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
             }

             // Simulate Soil Data
             let moistureStr = (Math.random() * 80 + 10).toFixed(1) + '%';
             let npkStr = `N:${Math.floor(Math.random() * 100)}, P:${Math.floor(Math.random() * 100)}, K:${Math.floor(Math.random() * 100)}`;
             document.getElementById('moistureData').innerText = moistureStr;
             document.getElementById('npkData').innerText = npkStr;
            
             if (lastCommand === 'probe' || lastCommand === 'read_sensors') {
                 // ... (data logging logic remains the same) ...
             }

             drawMap();
             updateRover3DPosition(); // *** NEW: Update Rover position in 3D scene ***
             STATUS_ELEMENT.innerText = "Data update complete.";

        }, 500); 
    }
    
    // ------------------------------------
    // --- 2D MAP LOGIC ---
    // ------------------------------------

    function analyzeHealth(moisture, npk_n, npk_p, npk_k) {
        // ... (Health analysis logic remains the same) ...
        let issues = 0;
        const MIN_MOISTURE = 30;
        const IDEAL_NPK_SUM = 150; 
        const NPK_TOLERANCE = 50;

        if (moisture < MIN_MOISTURE || moisture > 80) { issues++; } 
        
        let npk_sum = npk_n + npk_p + npk_k;
        if (Math.abs(npk_sum - IDEAL_NPK_SUM) > NPK_TOLERANCE) { issues++; } 

        if (issues >= 2) return 'Bad';
        if (issues === 1) return 'Caution';
        return 'Good';
    }
    
    function drawMap() {
        // ... (2D drawing logic remains the same) ...
        CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE);
        
        // 1. Draw the 4x4 Grid
        CTX.strokeStyle = '#5a5a5a'; 
        CTX.lineWidth = 1;
        for (let i = 1; i < FIELD_SIZE; i++) { 
            let px = i * PIXELS_PER_METER;
            CTX.beginPath(); CTX.moveTo(px, 0); CTX.lineTo(px, MAP_SIZE); CTX.stroke();
            CTX.beginPath(); CTX.moveTo(0, px); CTX.lineTo(MAP_SIZE, px); CTX.stroke();
        }

        // 2. Map Soil Condition (Background Squares)
        // ... (Soil condition mapping logic remains the same) ...

        // 3. Draw Plant Health Circles
        // ... (Plant health drawing logic remains the same) ...

        // 4. Draw Rover Position and Heading (Triangle)
        let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
        let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER); // Inverse Y for 2D map

        // ... (Rover drawing logic remains the same) ...
        let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);

        CTX.fillStyle = '#9cdcfe';
        CTX.save();
        CTX.translate(rover_x_px, rover_y_px);
        CTX.rotate(heading_rad); 

        CTX.beginPath();
        CTX.moveTo(10, 0);  
        CTX.lineTo(-10, -8); 
        CTX.lineTo(-10, 8);  
        CTX.closePath();
        CTX.fill();

        CTX.restore();

        CTX.fillStyle = 'white';
        CTX.beginPath();
        CTX.arc(rover_x_px, rover_y_px, 3, 0, 2 * Math.PI);
        CTX.fill();
    }
    
    // --- Initialization ---
    window.onload = function() {
        initThreeD();       // Initialize the 3D map
        drawMap();          // Initialize the 2D map
        generatePhotoGrid();// Initialize the photo grid
        fetchAIResults();   // Check AI server status
        setInterval(fetchAIResults, 5000); 
        LAST_PHOTO_STATUS.innerText = 'No photos taken yet.';
    };

</script>

</body>
</html>
