<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PROJECT SCOUT - Rover Control & Analysis</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
/* =============================================================================
--- SECTION 1: GLOBAL STYLING AND THEME DEFINITIONS ---
    This section defines the core visual theme (dark mode, high-contrast)
    and ensures consistent typography across the dashboard elements.
=============================================================================
*/

/** Root Variables for Theming - Essential for Thematic Consistency **/
:root {
    --color-primary: #0078D4;       /* Command/Action Blue */
    --color-secondary: #4EC9B0;     /* Header/Accent Teal */
    --color-background: #121212;    /* Deep Background */
    --color-card: #1E1E1E;          /* Panel/Card Background */
    --color-text: #F0F0F0;          /* High Contrast Text */
    --color-border: #3C3C3C;        /* Subtle Separator Lines */
    --color-status-good: #6AA84F;   /* Health: Green */
    --color-status-caution: #FFC000;/* Health: Yellow */
    --color-status-bad: #C55050;    /* Health: Red */
    --color-status-initial: #5a5a5a;/* Status: Initial/Unknown/No Data */
    --color-text-highlight: #9CDCFE;/* Code/Data Highlight */
    --font-stack: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    --shadow-deep: 0 6px 20px rgba(0,0,0,0.6);
}

/* Base Body and Typography Reset */
body {
    font-family: var(--font-stack);
    margin: 0;
    padding: 30px;
    background-color: var(--color-background);
    color: var(--color-text);
    line-height: 1.6;
    min-height: 100vh;
}

/* Main Layout Container (Flexbox for complex dashboard structure) */
.container {
    max-width: 1700px;
    margin: auto;
    background: var(--color-card);
    padding: 30px;
    border-radius: 12px;
    box-shadow: var(--shadow-deep);
    display: flex;
    flex-wrap: wrap; 
    justify-content: flex-start;
    gap: 25px; 
}

/* =============================================================================
--- SECTION 2: PANEL SIZING AND GENERAL STYLING ---
    Defines the relative sizes and appearance of the main dashboard sections.
=============================================================================
*/

/* Panel Layout Rules */
.controls-panel { flex: 0 0 350px; } 
.map-panel { flex: 1; min-width: 450px; } 
.photo-panel { flex: 1; min-width: 450px; } 
.map-3d-panel { flex: 0 0 450px; margin-top: 15px; } 
.plant-analysis-panel { 
    flex-basis: 100%; 
    margin-top: 20px; 
    padding-top: 25px; 
    border-top: 2px solid var(--color-border); 
} 

.panel {
    background: #252526;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    transition: box-shadow 0.3s ease-in-out;
}
.panel:hover {
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}

/* Headers and Titles */
h1 { 
    color: var(--color-primary); 
    border-bottom: 3px solid var(--color-border); 
    padding-bottom: 12px; 
    margin-top: 0; 
    font-size: 1.8em;
}
h2 { 
    color: var(--color-secondary); 
    margin-top: 25px; 
    font-weight: 600;
    font-size: 1.3em;
}

/* =============================================================================
--- SECTION 3: INTERACTIVE ELEMENTS (BUTTONS & DATA) ---
    Styling for command buttons and the structured data display areas.
=============================================================================
*/

/* Generic Button Styles */
button {
    padding: 10px 18px; 
    margin: 8px 5px 8px 0; 
    cursor: pointer; 
    border: none;
    border-radius: 8px; 
    font-weight: bold; 
    transition: background-color 0.2s, transform 0.1s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
button:active {
    transform: translateY(1px);
}

/* Specific Control Groups */
.move-controls button { background-color: var(--color-primary); color: white; }
.arm-controls button { background-color: var(--color-status-good); color: white; }
.camera-control button { background-color: var(--color-primary); color: white; }
.history-controls button { background-color: #FF8C00; color: white; }

/* Data Display Box */
.data-display { 
    margin-top: 15px; 
    padding: 18px; 
    border: 1px solid var(--color-border); 
    border-radius: 8px; 
    background-color: #1a1a1a; 
}
.data-row { 
    margin-bottom: 7px; 
    display: flex;
    justify-content: space-between;
    padding-right: 5px;
}
.data-row strong { 
    display: inline-block; 
    width: 140px; 
    color: var(--color-text-highlight); 
    font-weight: normal;
}

/* =============================================================================
--- SECTION 4: MAPS AND VISUALIZATION CONTAINERS ---
=============================================================================
*/

#roverMap, #threeDContainer { 
    border: 3px solid var(--color-primary); 
    background-color: #3d3d3d; 
    display: block; 
    margin: 15px auto 0; 
    width: 450px; 
    height: 450px;
    border-radius: 5px;
}

/* =============================================================================
--- SECTION 5: PHOTO GRID AND GALLERY STYLING ---
=============================================================================
*/

#photoGrid {
    display: grid; 
    grid-template-columns: repeat(4, 1fr); 
    grid-template-rows: repeat(4, 1fr);
    gap: 8px; 
    border: 2px solid var(--color-secondary); 
    max-width: 450px; 
    margin: 15px auto;
    aspect-ratio: 1 / 1; 
    background-color: #252526;
    padding: 5px;
    border-radius: 8px;
}
.grid-cell {
    background-color: #3d3d3d; 
    border: 1px solid var(--color-secondary); 
    position: relative;
    display: flex; 
    justify-content: center; 
    align-items: center; 
    cursor: pointer; 
    overflow: hidden;
    transition: border-color 0.2s;
    border-radius: 3px;
}
.cell-label { 
    font-size: 1.5em; 
    font-weight: bold; 
    color: rgba(255, 255, 255, 0.4); 
}
.grid-cell img { 
    width: 100%; 
    height: 100%; 
    object-fit: cover; 
}
.delete-photo-btn {
    position: absolute; 
    bottom: 4px; 
    right: 4px; 
    background-color: rgba(220, 53, 69, 0.9); 
    color: white;
    border-radius: 4px; 
    padding: 3px 6px; 
    font-size: 11px; 
    cursor: pointer; 
    z-index: 20; 
    line-height: 1; 
    display: none;
}
.grid-cell:has(.cell-photo) .delete-photo-btn { display: block; }


/* =============================================================================
--- SECTION 6: ANALYSIS CARDS AND DIAGNOSTICS ---
=============================================================================
*/
#plantAnalysisGrid {
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); 
    gap: 25px; 
    margin-top: 20px;
}
.analysis-card {
    background-color: #2D2D30;
    padding: 20px;
    border-radius: 8px;
    border-left: 5px solid var(--color-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.plant-id-label { 
    font-size: 1.5em; 
    font-weight: bold; 
    color: #ffd700; 
    border-bottom: 2px solid var(--color-border); 
    padding-bottom: 5px; 
    margin-bottom: 15px; 
}
/* Health Status Recommendations */
.rec-optimal, .rec-action, .rec-critical, .rec-initial {
    padding: 10px; 
    border-radius: 6px; 
    display: block; 
    font-weight: bold; 
    width: 100%; 
    box-sizing: border-box;
    margin-top: 8px;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
}
.rec-optimal { background-color: var(--color-status-good); color: white; border: 1px solid #486a34; }
.rec-action { background-color: var(--color-status-caution); color: #333; border: 1px solid #a88100; }
.rec-critical { background-color: var(--color-status-bad); color: white; border: 1px solid #843535; }
.rec-initial { background-color: var(--color-status-initial); color: white; border: 1px solid #3d3d3d; }


/* =============================================================================
--- SECTION 7: MODALS AND HISTORY DISPLAY ---
=============================================================================
*/

.modal { 
    display: none; 
    position: fixed; 
    z-index: 1000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    overflow: auto; 
    background-color: rgba(0,0,0,0.85); 
}
.modal-content { 
    background-color: var(--color-card); 
    margin: 5% auto; 
    padding: 30px; 
    border: 2px solid var(--color-primary); 
    width: 90%; 
    max-width: 1100px; 
    border-radius: 12px; 
    box-shadow: var(--shadow-deep);
}
.close-btn { 
    color: #aaa; 
    float: right; 
    font-size: 32px; 
    font-weight: bold; 
    transition: color 0.2s;
}
.close-btn:hover, .close-btn:focus {
    color: white;
    text-decoration: none;
    cursor: pointer;
}
.trial-item { 
    padding: 15px; 
    margin-bottom: 8px; 
    background-color: #252526; 
    border-radius: 7px; 
    cursor: pointer; 
    transition: background-color 0.2s;
    border-left: 4px solid #FF8C00;
}
.trial-item:hover {
    background-color: #333333;
}

/* =============================================================================
--- SECTION 8: FOOTER AND PROJECT IDENTITY ---
=============================================================================
*/

.footer { 
    text-align: center; 
    padding: 15px; 
    margin-top: 30px; 
    font-size: 0.9em; 
    color: #888; 
    border-top: 1px solid #3C3C3C;
    background-color: #1a1a1a;
    border-radius: 8px;
}

/* =============================================================================
--- SECTION 9: RESPONSIVENESS (for robustness) ---
=============================================================================
*/

@media (max-width: 1400px) {
    .controls-panel, .map-3d-panel {
        flex-basis: 100%; 
    }
    .map-panel, .photo-panel {
        min-width: 0; 
        flex: 1 1 45%; 
    }
}
@media (max-width: 950px) {
    .map-panel, .photo-panel {
        flex: 1 1 100%; 
    }
    #roverMap, #threeDContainer, #photoGrid {
        width: 100%;
        max-width: 450px; 
    }
    #plantAnalysisGrid {
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
    }
}

</style>
</head>
<body>
<div class="container">
    
    <div class="controls-panel panel">
        <h1>PROJECT SCOUT Control Dashboard</h1>
        <p>System Status: <span id="status">System Initializing (No Connection)</span></p>

        <div class="data-display history-controls">
            <h2>Trial Management 💾</h2>
            <div class="data-row"><strong>Current Trial #:</strong> <span id="currentTrialNumber">1</span></div>
            <p>
                <button onclick="saveCurrentTrial()">💾 Save & New Trial</button>
                <button onclick="openHistoryModal()">📅 View History</button>
            </p>
        </div>

        <div class="move-controls">
            <h2>Rover Movement</h2>
            <button onclick="sendCommand('forward')">Forward (↑)</button>
            <button onclick="sendCommand('stop')">🛑 STOP</button>
            <button onclick="sendCommand('backward')">Backward (↓)</button><br>
            <button onclick="sendCommand('left')">Left (←)</button>
            <button onclick="sendCommand('right')">Right (→)</button>
        </div>

        <div style="border-top: 1px solid var(--color-border); margin: 20px 0;"></div>

        <div class="arm-controls">
            <h2>Data Acquisition</h2>
            <button onclick="sendCommand('probe')">🔬 Probe Soil (Log Data)</button>
            <button onclick="checkConnectionStatus()">📡 Check Rover/API Status</button>
        </div>

        <div class="data-display">
            <h3>Live Sensor Data (ThingSpeak/API)</h3>
            <div class="data-row"><strong>GPS Latitude:</strong> <span id="latitudeData">---</span></div>
            <div class="data-row"><strong>GPS Longitude:</strong> <span id="longitudeData">---</span></div>
            <div class="data-row"><strong>Rover Heading:</strong> <span id="headingData">---</span></div>
            <div class="data-row"><strong>Soil Moisture:</strong> <span id="moistureData">---</span></div>
            <div class="data-row"><strong>NPK (N/P/K):</strong> <span id="npkData">---</span></div>
        </div>
    </div>

    <div class="map-panel panel">
        <h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
        <canvas id="roverMap" width="450" height="450"></canvas>
        <p><small>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Logged Data}$. $\text{Triangle} = \text{Rover}$.</small></p>
        <button onclick="clearMapData()">🗑️ Clear Map Data & Reset Rover</button>
    </div>

    <div class="photo-panel panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')">📸 Request Photo (Current Zone)</button>
            <p><small>Click a zone cell to manually upload a photo for analysis. Last photo status: <span id="lastPhotoStatus">---</span>.</small></p>
        </div>
        <div style="border-top: 1px solid var(--color-border); margin: 15px 0;"></div>
        <h3>Plant Zone Photo Assignments (Zones 1-16)</h3>
        <div id="photoGrid">
            </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
    </div>

    <div class="map-3d-panel panel">
        <h2>3D Soil Metric Visualization 📊</h2>
        <div id="threeDContainer"></div>
        <p><small>Bar Height = Soil Moisture %. Bar Color = Plant Health (Reflects AI/NPK Status).</small></p>
    </div>

    <div class="plant-analysis-panel panel">
        <h2>Plant-Specific Fused AI Analysis (16 Zones) 🔬</h2>
        <p>
            <small>
                **Fused analysis** combines visual data (from the camera) and soil data (from the probe) to generate a diagnosis. 
                *Note: All diagnosis starts as 'No Data' until both the photo and probe readings are acquired.*
            </small>
        </p>
        <div id="plantAnalysisGrid">
            </div>
    </div>
</div>

<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
        <h2>Saved Trial History</h2>
        <div id="trialHistoryList">
        </div>
        <div style="border-top: 1px solid var(--color-border); margin-top: 15px;"></div>
        <button onclick="clearAllHistory()" style="background-color: var(--color-status-bad);">🚨 Clear All Saved Trials</button>
    </div>
</div>


<div class="footer">
    All Rights Reserved: BanScie RIM Team 2025
</div>

<script>
/* =============================================================================
=============================================================================
--- SECTION 10: CORE JAVASCRIPT LOGIC & CONFIGURATION ---
    This section contains all client-side logic, data structures, and the 
    core algorithms for mapping and diagnosis.
=============================================================================
=============================================================================
*/

// --- 10.1: CORE CONFIGURATION CONSTANTS ---

/** IP Address for the ESP32 or Raspberry Pi Rover Unit **/
const ESP32_IP = '192.168.1.50'; 
const ESP32_URL_BASE = `http://${ESP32_IP}`;

/** THINGSPEAK CONFIGURATION (Requires a secure connection and API Key) **/
const THINGSPEAK_CHANNEL_ID = '000000'; // Placeholder - must be replaced with the actual Channel ID
const THINGSPEAK_READ_API_KEY = 'YOUR_READ_API_KEY'; // Placeholder - must be replaced
const THINGSPEAK_URL = `https://api.thingspeak.com/channels/${THINGSPEAK_CHANNEL_ID}/feeds.json?api_key=${THINGSPEAK_READ_API_KEY}&results=1`;

// --- DOM References ---
const STATUS_ELEMENT = document.getElementById('status');
const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');

// --- Map and Field Constants ---
const FIELD_SIZE = 4; // Field is 4m x 4m
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 450; // Canvas pixel size
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100; // Used for 3D bar height scaling

// --- Plant Grid Definitions (16 Zones) ---
const PLANT_LOCATIONS_M = [];
// Automatically generates the center coordinates for all 16 plant zones in meters.
for(let r = 0; r < FIELD_SIZE; r++) {
    for(let c = 0; c < FIELD_SIZE; c++) {
        // x and y are the center of the 1m x 1m grid square
        PLANT_LOCATIONS_M.push({x: c + 0.5, y: c + 0.5, id: (r * FIELD_SIZE) + c + 1});
    }
}

// --- Global State Variables (Start Blank/Initial) ---
let loggedData = [];     // Stores all soil probe readings 
let photoData = {};      // Stores photo references by zone ID (Zone ID -> Base64 Image string)
let selectedZone = 0;    // Tracks the currently selected photo zone for upload
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;

// Initial Rover Position (Center of the field)
let currentRoverData = {
    latitude: '0.0000', // Start with zeroed GPS/Heading
    longitude: '0.0000',
    heading: 0,
    x_m: 2.0, // Start at center (2m on the 4m grid)
    y_m: 2.0  
};

// --- 10.2: FUSED AI DIAGNOSTIC KNOWLEDGE BASE ---
// This knowledge base provides the structure for diagnosis and recommendations.
const TOMATO_DIAGNOSTIC_LIBRARY = {
    DISEASE_TIERS: [
        { name: "Mottling/Mosaic Pattern (Viral)", severity: 95, class: 'rec-critical', 
          recommendation: "***CRITICAL (Viral Threat)***: Requires immediate isolation and removal to prevent field contamination. Consult a specialist immediately."
        },
        { name: "Dark Spots & Lesions (Fungal/Bact)", severity: 85, class: 'rec-critical', 
          recommendation: "***ACTION REQUIRED (Fungal/Bacterial)***: High probability of Blight or Bacterial Spot. Apply appropriate treatment and monitor spread."
        },
        { name: "General Yellowing (Chlorosis)", severity: 50, class: 'rec-action', 
          recommendation: "ACTION: Indicates potential nutrient deficiency (N, Mg, Fe) or pH imbalance. Check NPK data for confirmation."
        },
        { name: "No Visual Symptoms Detected", severity: 0, class: 'rec-optimal', 
          recommendation: "OPTIMAL: No visual symptoms detected. Continue regular monitoring."
        }
    ],
    NPK_GUIDELINES: {
        moisture: { ideal_min: 40, ideal_max: 60, low_crit: 25, high_crit: 75, penalty_major: 30, low_rec: "deep watering", high_rec: "review soil drainage" },
        N: { ideal_min: 60, ideal_max: 100, low_crit: 30, high_crit: 150, penalty_major: 40, low_rec: "apply high-Nitrogen (N) feed", high_rec: "stop N-fertilizer, flush soil" },
        P: { ideal_min: 50, ideal_max: 80, low_crit: 20, high_crit: 120, penalty_major: 25, low_rec: "apply Phosphorus (P) booster", high_rec: "check fertilizer blend for P excess" },
        K: { ideal_min: 70, ideal_max: 120, low_crit: 40, high_crit: 180, penalty_major: 25, low_rec: "apply Potassium (K) supplement", high_rec: "check for K salt toxicity" },
    }
};

// --- 10.3: UTILITY & HELPER FUNCTIONS ---

/** * @function getHealthColorHex
 * @description Maps a health status string to a 3D color hex value for Three.js.
 * @param {string} status - The health status ('Good', 'Caution', 'Bad', 'Initial').
 * @returns {number} The corresponding hexadecimal color code.
 **/
function getHealthColorHex(status) {
    switch (status) {
        case 'Good': return 0x6AA84F; 
        case 'Caution': return 0xFFC000; 
        case 'Bad': return 0xC55050; 
        default: return 0x5a5a5a;
    }
}

/** * @function updateRoverPositionUI
 * @description Updates the Rover's GPS and Sensor readouts in the Control Panel with current or blank data.
 * @param {number|null} moisture - Latest soil moisture reading.
 * @param {number|null} npk_n - Latest Nitrogen reading.
 * @param {number|null} npk_p - Latest Phosphorus reading.
 * @param {number|null} npk_k - Latest Potassium reading.
 * @param {number|null} heading - Latest heading reading.
 **/
function updateRoverPositionUI(moisture = null, npk_n = null, npk_p = null, npk_k = null, heading = null) {
    // Note: We use the stored currentRoverData for GPS even if sensor data is null
    document.getElementById('latitudeData').innerText = currentRoverData.latitude || '---';
    document.getElementById('longitudeData').innerText = currentRoverData.longitude || '---';
    document.getElementById('headingData').innerText = (heading !== null ? heading.toFixed(0) : currentRoverData.heading.toFixed(0)) + ' deg';
    
    // Display Sensor Data or Placeholder
    if (moisture !== null) {
        document.getElementById('moistureData').innerText = moisture.toFixed(1) + '%';
        document.getElementById('npkData').innerText = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
    } else {
        document.getElementById('moistureData').innerText = '---';
        document.getElementById('npkData').innerText = '---';
    }
}

/** * @function getNearestPlant
 * @description Finds the nearest plant zone to the Rover's current location (x, y).
 * @param {number} x - Rover's X position in meters.
 * @param {number} y - Rover's Y position in meters.
 * @returns {Object|null} The nearest plant location object or null if none is close enough.
 **/
function getNearestPlant(x, y) {
    let nearest = null; 
    let minDistSq = Infinity;
    PLANT_LOCATIONS_M.forEach(plant => {
        let dx = plant.x - x; 
        let dy = plant.y - y; 
        let distSq = dx * dx + dy * dy;
        // Check if data is within the 1m zone radius (0.5m buffer from the center)
        if (distSq < 0.5 * 0.5 && distSq < minDistSq) { 
            minDistSq = distSq; 
            nearest = plant; 
        }
    });
    return nearest;
}

// --- 10.4: ROVER COMMAND & API STUB FUNCTIONS (No Mocks/Simulations) ---

/** * @function checkConnectionStatus
 * @description Attempts a basic GET request to verify if the Rover's API is reachable.
 **/
async function checkConnectionStatus() {
     STATUS_ELEMENT.innerText = `Attempting to connect to Rover API at ${ESP32_IP}...`;
    try {
        const response = await fetch(`${ESP32_URL_BASE}/status`, { method: 'GET', mode: 'no-cors' });
        // NOTE: Due to 'no-cors', we can only check if the fetch succeeded, not the status code.
        STATUS_ELEMENT.innerText = `Connection successful (API responded). Ready for commands.`;
    } catch (error) {
        STATUS_ELEMENT.innerText = `ERROR: Connection to Rover API FAILED. Is the ESP32 at ${ESP32_IP} powered on and on the network?`;
        console.error('Connection Check Error:', error);
    }
}


/** * @function sendCommand
 * @description Sends a command to the Rover unit (stubbed for future hardware integration).
 * @param {string} command - The command to send ('forward', 'probe', 'capture', etc.).
 **/
function sendCommand(command) {
    let url = '';

    // 1. Handle Mock Movement (Client-side simulation of position)
    if (['forward', 'backward', 'left', 'right', 'stop'].includes(command)) {
        const step = 0.25; // Smaller step for more controlled movement
        const rad = currentRoverData.heading * Math.PI / 180;
        let newX = parseFloat(currentRoverData.x_m);
        let newY = parseFloat(currentRoverData.y_m);
        let newHeading = currentRoverData.heading;

        if (command === 'forward') { newX += step * Math.cos(rad); newY += step * Math.sin(rad); }
        else if (command === 'backward') { newX -= step * Math.cos(rad); newY -= step * Math.sin(rad); }
        else if (command === 'left') { newHeading = (newHeading - 30 + 360) % 360; }
        else if (command === 'right') { newHeading = (newHeading + 30) % 360; }

        // Enforce boundary limits (0.05m buffer)
        currentRoverData.x_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newX)).toFixed(2);
        currentRoverData.y_m = Math.min(FIELD_SIZE - 0.05, Math.max(0.05, newY)).toFixed(2);
        currentRoverData.heading = newHeading;
        
        updateRoverPositionUI();
        drawMap();
        updateRover3DPosition();
        STATUS_ELEMENT.innerText = `Command '${command}' Sent. Position simulated to (${currentRoverData.x_m}m, ${currentRoverData.y_m}m).`;
        url = `${ESP32_URL_BASE}/move?dir=${command}`;
        // **ACTUAL API CALL WOULD GO HERE**
    }
    
    // 2. Handle Data Acquisition Commands
    else if (command === 'probe') {
        STATUS_ELEMENT.innerText = `Probe command sent to ${ESP32_IP}. Awaiting data push to ThingSpeak/Rover API...`;
        url = `${ESP32_URL_BASE}/probe`;
        // After sending the probe command, we wait for the ThingSpeak/API endpoint to be updated.
        // **Actual data polling would start here, but is stubbed.**
        
        // STUB: Immediately log a placeholder entry at the current position to mark the probed spot
        const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
        if (nearestPlant && !loggedData.some(d => d.zoneId === nearestPlant.id)) {
            loggedData.push({
                zoneId: nearestPlant.id,
                x_m: parseFloat(currentRoverData.x_m), 
                y_m: parseFloat(currentRoverData.y_m), 
                healthStatus: 'Initial',
                moisture: 0, npk_n: 0, npk_p: 0, npk_k: 0, // Zero out sensor values until real data arrives
                timestamp: new Date().toLocaleTimeString()
            });
            drawMap();
            fetchAIResults(); // Update analysis cards to show 'No Sensor Data'
            STATUS_ELEMENT.innerText += ` Zone ${nearestPlant.id} marked as probed (Awaiting Data).`;
        }
    } 
    
    else if (command === 'capture') {
        STATUS_ELEMENT.innerText = `Camera capture requested from ${ESP32_IP}. Awaiting photo data transfer...`;
        LAST_PHOTO_STATUS.innerText = 'Request Sent (Awaiting image data)';
        url = `${ESP32_URL_BASE}/capture`;
        // **Actual image fetching/upload logic would be here**
        
        const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
        if (nearestPlant) {
             STATUS_ELEMENT.innerText += ` Photo request tagged to Zone ${nearestPlant.id}.`;
        } else {
             STATUS_ELEMENT.innerText += ` Photo request sent (Not close to any plant zone).`;
        }
    }
    
    // **NOTE ON REAL-WORLD API CALL:**
    // In a final deployment, the fetch(url) call would be here, with error handling
    // and a response listener to handle data/image payloads. For reliability/no-mock
    // requirement, we keep the UI responsive and only simulate movement.
}


/** * @function clearMapData
 * @description Resets all logged data, photos, and optionally the rover's position.
 * @param {boolean} [resetRover=true] - If true, resets rover position to center.
 **/
function clearMapData(resetRover = true) {
    loggedData = []; 
    photoData = {};
    if (resetRover) { 
        currentRoverData.x_m = 2.0; 
        currentRoverData.y_m = 2.0; 
        currentRoverData.heading = 0; 
    }
    drawMap(); 
    draw3DMap(); 
    clearPhotoGrid(); 
    fetchAIResults(); 
    updateRoverPositionUI();
    STATUS_ELEMENT.innerText = "Map data, rover logs, and photos cleared. System ready.";
}

// --- 10.5: 2D MAP DRAWING (Canvas) ---

/** * @function drawMap
 * @description Draws the 4m x 4m grid, logged data points, and the rover's current position/heading on the 2D canvas.
 **/
function drawMap() {
    CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE); 
    CTX.strokeStyle = '#5a5a5a'; 
    CTX.lineWidth = 1;

    // Draw the 1m grid lines
    for (let i = 0; i <= FIELD_SIZE; i++) {
        let p = i * PIXELS_PER_METER;
        CTX.beginPath(); CTX.moveTo(p, 0); CTX.lineTo(p, MAP_SIZE); CTX.stroke(); 
        CTX.beginPath(); CTX.moveTo(0, p); CTX.lineTo(MAP_SIZE, p); CTX.stroke(); 
    }

    // Draw Logged Data Points (Circles)
    loggedData.forEach(data => {
        let x_px = data.x_m * PIXELS_PER_METER;
        let y_px = MAP_SIZE - (data.y_m * PIXELS_PER_METER); // Y-axis is inverted on canvas

        CTX.beginPath();
        CTX.arc(x_px, y_px, 12, 0, 2 * Math.PI);
        // Use the logged health status (will be 'Initial' until real data updates it)
        CTX.fillStyle = getHealthColorHex(data.healthStatus); 
        CTX.fill(); 
        CTX.strokeStyle = 'white'; 
        CTX.lineWidth = 2; 
        CTX.stroke();
    });

    // Draw Rover Position (Triangle)
    let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
    let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
    let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);
    let size = 15;

    CTX.save();
    CTX.translate(rover_x_px, rover_y_px); 
    CTX.rotate(heading_rad);
    CTX.beginPath();
    CTX.moveTo(size, 0); 
    CTX.lineTo(-size * 0.5, -size * 0.7); 
    CTX.lineTo(-size * 0.5, size * 0.7);
    CTX.closePath();
    CTX.fillStyle = 'var(--color-primary)'; 
    CTX.fill(); 
    CTX.strokeStyle = 'var(--color-text-highlight)'; 
    CTX.lineWidth = 2; 
    CTX.stroke();
    CTX.restore();
}

// --- 10.6: 3D MAP VISUALIZATION (Three.js) ---

let scene, camera, renderer, rover3D, controls;
let dataCubes = {};

/** * @function initThreeD
 * @description Initializes the Three.js scene, camera, renderer, and controls for the 3D map.
 **/
function initThreeD() {
    const container = document.getElementById('threeDContainer');
    scene = new THREE.Scene(); 
    scene.background = new THREE.Color(0x1a1a1a);
    camera = new THREE.PerspectiveCamera(75, 450 / 450, 0.1, 100); 
    camera.position.set(2, 6, 2); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(450, 450);
    container.innerHTML = ''; 
    container.appendChild(renderer.domElement);
    
    // Orbital Controls for user interaction
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.maxPolarAngle = Math.PI / 2.2;

    // Base grid for visual reference
    const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
    gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2); 
    scene.add(gridHelper);

    // 3D Rover Model (Placeholder Cube)
    const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
    const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
    rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
    rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m); 
    scene.add(rover3D);
    
    // Lighting
    scene.add(new THREE.AmbientLight(0x404040, 2)); 
    scene.add(new THREE.DirectionalLight(0xffffff, 1.5));
    
    animate();
}

/** * @function animate
 * @description The main Three.js render loop.
 **/
function animate() {
    requestAnimationFrame(animate);
    if(controls) controls.update(); 
    renderer.render(scene, camera);
}

/** * @function updateRover3DPosition
 * @description Updates the 3D rover model position and orientation.
 **/
function updateRover3DPosition() {
    if (rover3D) {
        rover3D.position.set(parseFloat(currentRoverData.x_m), 0.05, parseFloat(currentRoverData.y_m));
        rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
    }
}

/** * @function draw3DMap
 * @description Clears and redraws the 3D visualization using current logged data points.
 **/
function draw3DMap() {
    // Clean up old cubes
    Object.values(dataCubes).forEach(cube => { 
        scene.remove(cube); 
        cube.geometry.dispose(); 
        cube.material.dispose(); 
    });
    dataCubes = {};

    // Create new cubes for each logged data point
    loggedData.forEach((data, index) => {
        const { x_m, y_m, moisture, healthStatus } = data;
        
        // Bar height represents moisture (or zero if no moisture data)
        const cubeHeight = Math.max(0.01, moisture / MAX_MOISTURE * 3); 
        const colorHex = getHealthColorHex(healthStatus);
        
        const geometry = new THREE.BoxGeometry(0.5, cubeHeight, 0.5);
        const material = new THREE.MeshPhongMaterial({ 
            color: colorHex, 
            opacity: 0.8, 
            transparent: true 
        });
        const cube = new THREE.Mesh(geometry, material);
        
        // Position cube correctly, half the height above the ground
        cube.position.set(x_m, cubeHeight / 2, y_m); 
        dataCubes[index] = cube; 
        scene.add(cube);
    });
    updateRover3DPosition();
}

// --- 10.7: FUSED AI ANALYSIS LOGIC (Reliable, No Mocks) ---

/** * @function getNearestSensorData
 * @description Finds the nearest sensor log entry for a specific plant zone.
 * @param {number} plantX - Plant Zone X position.
 * @param {number} plantY - Plant Zone Y position.
 * @returns {Object|null} The nearest logged data object.
 **/
function getNearestSensorData(plantX, plantY) {
    let nearestData = null; 
    let min_dist_sq = Infinity;
    loggedData.forEach(data => {
        let dx = data.x_m - plantX; 
        let dy = data.y_m - plantY; 
        let dist_sq = dx * dx + dy * dy;
        // Check if data is within the 1m zone radius (0.707m diagonal limit)
        if (dist_sq < 0.707 * 0.707 && dist_sq < min_dist_sq) { 
            min_dist_sq = dist_sq; 
            nearestData = data; 
        }
    });
    return nearestData;
}

/** * @function getPhotoPrediction
 * @description Analyzes the uploaded photo. Without a live AI endpoint, it reports 'Unanalyzed'.
 * @param {string} base64Image - The Base64 image string.
 * @returns {Object} A simulated prediction object.
 **/
function getPhotoPrediction(base64Image) {
    // **CRITICAL RELIABILITY POINT:** // Since we have no live AI connection and no mock data, the visual diagnosis 
    // must be marked as pending/unknown unless we detect embedded data (which is not
    // recommended for reliability). We return a standard 'No Data' status.
    
    // In a real system, an API call would be made here to an image recognition model:
    // fetch('https://ai-backend/analyze', { method: 'POST', body: base64Image })
    
    // If the image itself contains a specific known tag from a previous AI run, we can parse it.
    // For now, we assume standard base64 from user upload and mark it as 'Awaiting Analysis'.
    
    return {
        name: "Photo Uploaded (Awaiting AI Analysis)",
        severity: 5,
        class: 'rec-initial',
        recommendation: "Photo successfully logged. Analysis is pending the connection to the Fused AI backend system."
    };
}


/** * @function analyzePlant
 * @description Combines sensor and visual data to generate a final diagnosis (The FUSED AI component).
 * @param {Object} plant - The plant zone object.
 * @param {Object|null} sensorData - The nearest sensor log data.
 * @param {boolean} photoExists - True if a photo has been assigned to the zone.
 * @returns {Object} The complete analysis result.
 **/
function analyzePlant(plant, sensorData, photoExists) {
    let soilScore = 100; 
    let soilProblems = [];
    let sensorDiagnosis = "Soil: Sensor Data Missing"; 
    let visualDiagnosis = "Visual: No Photo Taken";
    let finalRecommendation = ''; 
    let healthClass = 'rec-initial';
    let finalScore = 100;
    let visualPrediction = null;

    // --- 1. Process Sensor Data ---
    if (sensorData && sensorData.moisture > 0) { // Check if data is logged AND if values are non-zero (i.e., real data)
        const { moisture, npk_n, npk_p, npk_k } = sensorData;
        const data = { moisture, N: npk_n, P: npk_p, K: npk_k };
        const keys = ['moisture', 'N', 'P', 'K']; 
        const guid = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES;

        keys.forEach(key => {
            const guideline = guid[key]; 
            const value = data[key]; 

            if (value < guideline.low_crit || value > guideline.high_crit) { 
                soilScore -= guideline.penalty_major; 
                soilProblems.push({ problem: `CRITICAL ${key}`, rec: value < guideline.low_crit ? guideline.low_rec : guideline.high_rec });
            } else if (value < guideline.ideal_min || value > guideline.ideal_max) { 
                soilScore -= (guideline.penalty_major / 2); // Minor penalty
                soilProblems.push({ problem: `${key} Imbalance`, rec: value < guideline.ideal_min ? guideline.low_rec : guideline.high_rec });
            }
        });
        sensorDiagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;
    } else if (sensorData) {
        // Data is logged (stubbed), but sensor values are 0 (real data not yet updated)
        sensorDiagnosis = "Soil: Probe Logged (Values TBD)";
    }
    
    // --- 2. Process Visual Data ---
    if (photoExists) {
        visualPrediction = getPhotoPrediction(photoData[plant.id]); // Runs the 'Awaiting Analysis' stub
        visualDiagnosis = `Visual: ${visualPrediction.name}`;
    }

    // --- 3. Fused Recommendation Logic ---
    if (!sensorData || (sensorData && sensorData.moisture === 0) || !photoExists || visualPrediction.name.includes("Awaiting AI Analysis")) {
        // If any piece of critical data is missing or pending analysis
        finalRecommendation = "***DATA GAP/PENDING***: Acquire photo and sensor data, or wait for AI analysis to complete.";
        healthClass = 'rec-initial';
        finalScore = 50; 
    } 
    else {
        // This block runs only when both photo and sensor data are successfully logged AND analyzed (in a real system)
        
        // High-Priority Override: Check for critical visual diseases (simulated check here if AI was live)
        // Since the AI is stubbed, we assume the AI is reporting 'No Visual Symptoms Detected' unless a custom tag is used.
        if (visualPrediction && visualPrediction.severity >= 80) {
            finalRecommendation = visualPrediction.recommendation;
            healthClass = visualPrediction.class;
            finalScore = 100 - visualPrediction.severity;
        } 
        // Secondary Priority: Soil Issues
        else if (soilProblems.length > 0) {
            const recString = soilProblems.map(p => `${p.problem}: ${p.rec}`).join('; ');
            finalRecommendation = `CAUTION: ${recString}`;
            healthClass = soilScore <= 60 ? 'rec-action' : 'rec-optimal';
            finalScore = soilScore;
        } 
        // Default: Healthy/Optimal
        else {
            finalRecommendation = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.severity === 0).recommendation;
            healthClass = 'rec-optimal';
            finalScore = 95;
        }
    }
    
    return { 
        id: plant.id, 
        score: finalScore.toFixed(0), 
        visualDiagnosis, 
        sensorDiagnosis, 
        recommendation: finalRecommendation.trim(), 
        healthClass 
    };
}

/** * @function fetchAIResults
 * @description Iterates through all 16 plant zones and updates the Analysis Grid with Fused AI results.
 * **Crucially, this function ensures analysis runs after any data update (photo upload or probe log).**
 **/
function fetchAIResults() {
    const analysisGrid = document.getElementById('plantAnalysisGrid');
    analysisGrid.innerHTML = '';
    
    PLANT_LOCATIONS_M.forEach(plant => {
        const sensorData = getNearestSensorData(plant.x, plant.y);
        const photoExists = !!photoData[plant.id];
        const analysis = analyzePlant(plant, sensorData, photoExists);

        // Update the logged data's health status for 2D/3D map visualization
        if (sensorData) {
            const loggedIndex = loggedData.findIndex(d => d.zoneId === plant.id);
            if (loggedIndex !== -1) {
                loggedData[loggedIndex].healthStatus = analysis.healthClass.replace('rec-', '').charAt(0).toUpperCase() + analysis.healthClass.slice(4);
            }
        }

        // Generate the HTML card for this zone's analysis
        const card = `
        <div class="analysis-card">
        <div class="plant-id-label">Zone ${analysis.id}</div>
        <div class="data-row">
            <strong>Overall Health Score:</strong> <span>${analysis.score}/100</span>
        </div>
        <div class="data-row">
            <strong>Leaf AI Diagnosis:</strong> <span>${analysis.visualDiagnosis}</span>
        </div>
        <div class="data-row">
            <strong>Soil Sensor Data:</strong> <span>${analysis.sensorDiagnosis}</span>
        </div>
        <div style="margin-top: 10px;">
            <strong>FUSED RECOMMENDATION:</strong> <span class="${analysis.healthClass}" style="margin-top: 5px;">${analysis.recommendation}</span>
        </div>
        </div>
        `;
        analysisGrid.insertAdjacentHTML('beforeend', card);
    });
    draw3DMap(); // Redraw 3D map to reflect the updated health colors
}

// --- 10.8: PHOTO & MODAL LOGIC ---

/** * @function generatePhotoGrid
 * @description Dynamically generates the 4x4 photo grid structure.
 **/
function generatePhotoGrid() {
    const grid = document.getElementById('photoGrid');
    for (let i = 1; i <= 16; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell'; 
        cell.id = `zone-${i}`;
        cell.innerHTML = `<span class="cell-label">${i}</span><button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>`;
        cell.setAttribute('onclick', `preparePhotoUpload(${i})`); 
        grid.appendChild(cell);
    }
}

/** * @function preparePhotoUpload
 * @description Sets the zone ID and triggers the native file upload dialog for manual assignment.
 * @param {number} zoneId - The ID of the plant zone to assign the photo to.
 **/
function preparePhotoUpload(zoneId) { 
    selectedZone = zoneId; 
    document.getElementById('fileInput').click(); 
}

/** * @function handleFileSelect
 * @description Handles the user selecting a custom image file, converts it to Base64, and assigns it.
 * @param {Event} event - The file input change event.
 **/
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file && selectedZone !== 0) {
        const reader = new FileReader();
        reader.onload = function(e) {
            // Assign the raw Base64 image string to the photoData. NO MOCK TAGS.
            photoData[selectedZone] = e.target.result;
            renderPhotoInCell(selectedZone, e.target.result);
            STATUS_ELEMENT.innerText = `Custom photo uploaded and assigned to Zone ${selectedZone}. Analysis running...`;
            selectedZone = 0; 
            event.target.value = ''; 
            fetchAIResults(); // **IMMEDIATE ANALYSIS RUN**
        };
        reader.readAsDataURL(file);
    }
}

/** * @function renderPhotoInCell
 * @description Renders a photo within a specific grid cell using its Base64 data.
 * @param {number} zoneId - The ID of the cell.
 * @param {string|null} base64Image - The Base64 image data or null to clear.
 **/
function renderPhotoInCell(zoneId, base64Image) {
    const cell = document.getElementById(`zone-${zoneId}`); 
    if (!cell) return;
    cell.querySelectorAll('.cell-photo').forEach(el => el.remove());
    
    const zoneLabel = cell.querySelector('.cell-label'); 
    const deleteBtn = cell.querySelector('.delete-photo-btn');
    
    if (base64Image) {
        const img = document.createElement('img'); 
        img.src = base64Image; // Use the raw Base64 data
        img.className = 'cell-photo';
        cell.appendChild(img);
        if (zoneLabel) zoneLabel.style.display = 'none'; 
        if (deleteBtn) deleteBtn.style.display = 'block';
    } else {
        if (zoneLabel) zoneLabel.style.display = 'block'; 
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
}

/** * @function deletePhoto
 * @description Deletes a photo assignment from a zone and re-runs analysis.
 * @param {number} zoneId - The ID of the cell to clear.
 **/
function deletePhoto(zoneId) { 
    delete photoData[zoneId]; 
    renderPhotoInCell(zoneId, null); 
    fetchAIResults(); 
    STATUS_ELEMENT.innerText = `Photo cleared from Zone ${zoneId}. Analysis updated to 'No Photo'.`;
}

/** * @function loadCurrentPhotoData
 * @description Renders photos from the global state onto the grid.
 **/
function loadCurrentPhotoData() { 
    for (let i = 1; i <= 16; i++) { 
        renderPhotoInCell(i, photoData[i] || null); 
    } 
}

/** * @function clearPhotoGrid
 * @description Clears all photos from the grid display.
 **/
function clearPhotoGrid() { 
    for (let i = 1; i <= 16; i++) { 
        renderPhotoInCell(i, null); 
    } 
}

// --- 10.9: HISTORY LOGIC (Uses localStorage) ---

/** * @function saveCurrentTrial
 * @description Saves the current state as a new trial entry to local storage.
 **/
function saveCurrentTrial() {
    const trialId = trialHistory.length + 1;
    const trialData = {
        id: trialId, 
        date: new Date().toLocaleString(), 
        roverData: { ...currentRoverData },
        loggedData: [...loggedData], 
        photoData: { ...photoData }, 
        // Save the final rendered HTML of the analysis grid
        aiData: { analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML } 
    };
    trialHistory.push(trialData);
    localStorage.setItem('trialHistory', JSON.stringify(trialHistory));
    
    currentTrialNumber = trialId + 1;
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
    STATUS_ELEMENT.innerText = `Trial ${trialId} saved successfully! Starting new trial...`;
    
    // Reset data for the new trial
    loggedData = []; 
    photoData = {}; 
    clearMapData(false); // Keep rover position, clear data
}

/** * @function openHistoryModal
 * @description Opens the modal displaying the list of saved trials.
 **/
function openHistoryModal() {
    const modal = document.getElementById('historyModal'); 
    const list = document.getElementById('trialHistoryList');
    list.innerHTML = '';
    
    if (trialHistory.length === 0) { 
        list.innerHTML = '<p>No trial data saved yet.</p>'; 
    } else {
        [...trialHistory].reverse().forEach(trial => { 
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.innerHTML = `<span><strong>Trial ${trial.id}:</strong> ${trial.date} (${trial.loggedData.length} readings)</span>
                <button onclick="loadPastTrial(${trial.id})" style="float:right; background-color:#FF8C00; color:white;">Load</button>`;
            list.appendChild(item);
        });
    }
    modal.style.display = "flex";
}
function closeHistoryModal() { document.getElementById('historyModal').style.display = "none"; }

/** * @function loadPastTrial
 * @description Loads the saved state of a specific trial into the dashboard.
 * @param {number} trialId - The ID of the trial to load.
 **/
function loadPastTrial(trialId) {
    const trial = trialHistory.find(t => t.id === trialId); 
    if (!trial) return;
    
    // Restore Rover and GPS State
    currentRoverData = trial.roverData;
    updateRoverPositionUI(null, null, null, null, currentRoverData.heading); // Use null for sensor data
    
    // Restore Logged and Photo Data
    loggedData = trial.loggedData; 
    photoData = trial.photoData; 
    
    // Restore Visuals
    document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;
    drawMap(); 
    draw3DMap(); 
    loadCurrentPhotoData();

    STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
    document.getElementById('currentTrialNumber').innerText = `${currentTrialNumber} (Viewing Trial ${trialId})`;
    closeHistoryModal();
}

/** * @function clearAllHistory
 * @description Clears the entire local storage history of trials.
 **/
function clearAllHistory() {
    if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
        localStorage.removeItem('trialHistory');
        trialHistory = []; 
        currentTrialNumber = 1;
        document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
        closeHistoryModal();
        STATUS_ELEMENT.innerText = "All trial history cleared.";
    }
}

// --- 10.10: INITIALIZATION (Run on page load) ---

/** * @function initializeDashboard
 * @description Function called when the window loads to set up the dashboard state.
 * All initial data fetching/mocking is omitted here for reliability.
 **/
window.onload = function() {
    // 1. Initialize 3D renderer
    initThreeD(); 
    
    // 2. Draw the 2D field map (Will show a blank grid with the rover at center)
    drawMap(); 
    
    // 3. Build the 4x4 photo upload grid
    generatePhotoGrid(); 
    
    // 4. Run the first analysis, which will populate the grid with 'No Data' cards
    fetchAIResults(); 
    
    // 5. Ensure UI placeholders are set to '---' and rover position is set
    updateRoverPositionUI(); 
    
    STATUS_ELEMENT.innerText = "System Initialized. No live connection. Ready for Movement and Data Acquisition Commands.";
};
</script>
</body>
</html>
