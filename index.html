<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>S.C.O.U.T. Rover Mapping & Control (Data-Driven 3D)</title>
<!-- Three.js for 3D visualization -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<!-- TensorFlow.js for CNN photo analysis -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
<!-- Google Fonts for Modern UI -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@600&display=swap" rel="stylesheet">
<style>
/* MODERNIZED UI */
body {
    font-family: 'Roboto', 'Montserrat', Arial, sans-serif;
    background: linear-gradient(135deg,#1e1e1e 60%,#232d3f 100%);
    color: #eaeaea;
    margin: 0;
    padding: 0;
}
.container {
    max-width: 1800px;
    margin: 40px auto;
    background: rgba(36,44,55,0.97);
    padding: 40px 35px 30px 35px;
    border-radius: 18px;
    box-shadow: 0 8px 32px 0 rgba(0,0,0,0.28);
    display: flex;
    flex-wrap: wrap;
    gap: 35px;
}
.controls-panel, .map-panel, .photo-panel, .map-3d-panel, .plant-analysis-panel {
    background: rgba(30,36,43,0.92);
    border-radius: 14px;
    box-shadow: 0 2px 18px 0 rgba(0,0,0,0.14);
    padding: 28px;
    min-width: 340px;
    flex: 1 1 450px;
    margin-bottom: 0;
}
.plant-analysis-panel {
    margin-top: 35px;
}
h1, h2, h3 {
    font-family: 'Montserrat', 'Roboto', Arial, sans-serif;
    font-weight: 600;
    letter-spacing: 1px;
}
h1 {
    color: #3ec6e0;
    font-size: 2.4em;
    border-bottom: 2px solid #2f495e;
    padding-bottom: 12px;
    margin: 0 0 28px 0;
}
h2 {
    color: #65e39c;
    font-size: 1.3em;
    margin-top: 0;
}
h3 {
    color: #eaeaea;
    margin-top: 18px;
    font-size: 1.08em;
}
#status {
    font-weight: 700;
    color: #ffcc00;
    font-size: 1.08em;
    margin-bottom: 10px;
}
/* BUTTONS */
button {
    padding: 12px 22px;
    margin: 10px 6px 10px 0;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    font-weight: 700;
    font-size: 1.05em;
    letter-spacing: 0.5px;
    background: linear-gradient(90deg,#3ec6e0 60%,#65e39c 100%);
    color: #232d3f;
    box-shadow: 0 1px 8px rgba(64,128,128,0.10);
    transition: background 0.22s, color 0.22s;
}
button:hover {
    background: linear-gradient(90deg,#65e39c 60%,#3ec6e0 100%);
    color: #fff;
}
/* SPECIAL BUTTONS */
.arm-controls button { background: linear-gradient(90deg,#4ec9b0 50%,#39a26a 100%);}
.camera-control button { background: linear-gradient(90deg,#f67280 50%,#c06c84 100%);}
.history-controls button { background: linear-gradient(90deg,#ffd166 50%,#ff9900 100%);}
button.delete-photo-btn { background: #e84545; color: #fff;}
[data-theme="critical"] { background: #e84545; color: #fff;}
[data-theme="action"] { background: #ffd166; color: #232d3f;}
[data-theme="optimal"] { background: #3ec6e0; color: #fff;}
/* DATA DISPLAY */
.data-display {
    margin-top: 18px;
    padding: 18px;
    border-radius: 8px;
    background: rgba(36,44,55,0.97);
    box-shadow: 0 1px 8px rgba(64,128,128,0.06);
}
.data-row strong {
    display: inline-block;
    width: 150px;
    color: #65e39c;
    font-weight: 600;
}
.data-row span {
    font-family: 'Roboto', Arial, sans-serif;
    font-weight: 500;
}
#roverMap {
    border: 2px solid #65e39c;
    background-color: #232d3f;
    display: block;
    margin: 25px auto 0;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(30,36,43,0.13);
}
#threeDContainer {
    width: 500px;
    height: 500px;
    border: 2px solid #3ec6e0;
    background-color: #202b3f;
    margin: 26px auto 0;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(30,36,43,0.13);
    display: block;
}
/* Photo Grid Modern */
#photoGrid, #stockImageGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 8px;
    border: 2px solid #3ec6e0;
    max-width: 500px;
    margin: 18px auto;
    aspect-ratio: 1 / 1;
    background-color: #232d3f;
    border-radius: 12px;
    box-shadow: 0 1px 8px rgba(30,36,43,0.08);
}
.grid-cell {
    background-color: #313e54;
    border: 1px solid #65e39c;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    overflow: hidden;
    border-radius: 10px;
    transition: background 0.1s;
}
.grid-cell:hover {
    background-color: #3ec6e0;
}
.cell-label {
    position: absolute;
    top: 5px;
    left: 5px;
    background: rgba(62,198,224,0.85);
    color: #232d3f;
    padding: 3px 8px;
    font-size: 13px;
    font-weight: 700;
    border-radius: 6px;
    z-index: 8;
}
.cell-photo {
    max-width: 94%;
    max-height: 94%;
    border-radius: 8px;
    object-fit: cover;
    box-shadow: 0 1px 8px 0 rgba(62,198,224,0.08);
}
.delete-photo-btn {
    position: absolute;
    bottom: 7px;
    right: 7px;
    background-color: #e84545;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    z-index: 20;
    line-height: 1;
    display: none;
}
.grid-cell:has(.cell-photo) .delete-photo-btn {
    display: block;
}
/* Plant Analysis Modern */
#plantAnalysisGrid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 24px;
    margin-top: 18px;
}
.analysis-card {
    padding: 22px 18px;
    border-radius: 10px;
    background: linear-gradient(135deg,#232d3f 80%,#2f495e 100%);
    box-shadow: 0 2px 12px rgba(36,44,55,0.13);
    transition: box-shadow 0.2s;
}
.plant-id-label {
    font-size: 1.22em;
    font-weight: 700;
    color: #ffd700;
    border-bottom: 2px solid #3ec6e0;
    padding-bottom: 7px;
    margin-bottom: 12px;
    letter-spacing: 1px;
}
.status-good { color: #3ec6e0; font-weight: 700;}
.rec-optimal, .rec-action, .rec-critical {
    padding: 7px 10px;
    border-radius: 7px;
    display: inline-block;
    font-weight: bold;
    white-space: normal;
    word-break: break-word;
    width: 100%;
    box-sizing: border-box;
}
.rec-optimal { background-color: #3ec6e0; color: white; }
.rec-action { background-color: #ffd166; color: #232d3f; }
.rec-critical { background-color: #e84545; color: white; }
/* Modal Modern */
.modal {
    display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(30,44,55,0.88);
}
.modal-content {
    background-color: #232d3f;
    margin: 7% auto;
    padding: 30px;
    border: 1px solid #3ec6e0;
    width: 85%;
    max-width: 1000px;
    border-radius: 14px;
    box-shadow: 0 2px 22px rgba(36,44,55,0.23);
}
.close-btn {
    color: #3ec6e0;
    float: right;
    font-size: 32px;
    font-weight: bold;
    cursor: pointer;
}
.close-btn:hover, .close-btn:focus {
    color: #ffd166; text-decoration: none;
}
.trial-item {
    padding: 14px;
    margin-bottom: 8px;
    background-color: #313e54;
    border-radius: 9px;
    cursor: pointer;
    transition: background-color 0.18s;
    font-size: 1.08em;
}
.trial-item:hover { background-color: #3ec6e0; color:#232d3f;}
/* Responsive */
@media (max-width: 1050px) {
    .container { flex-direction: column; }
    .controls-panel, .map-panel, .photo-panel, .map-3d-panel, .plant-analysis-panel { min-width: unset; }
    #threeDContainer, #roverMap { width: 98vw; max-width: 99vw; }
}
</style>
</head>
<body>
<div class="container">
    <div class="controls-panel">
        <h1>S.C.O.U.T. Rover Control</h1>
        <p id="status">Connecting...</p>
        <div class="data-display history-controls">
            <h2>Trial Management üíæ</h2>
            <div class="data-row"><strong>Current Trial:</strong> <span id="currentTrialNumber">1</span></div>
            <p>
                <button onclick="saveCurrentTrial()">üíæ Save Trial Data</button>
                <button onclick="openHistoryModal()">üìÖ View History</button>
            </p>
            <p><small>Saved trials are stored in your browser's local storage.</small></p>
        </div>
        <div class="move-controls">
            <h2>Rover Movement</h2>
            <button onclick="sendCommand('forward')">Forward (‚Üë)</button>
            <button onclick="sendCommand('stop')">üõë STOP</button>
            <button onclick="sendCommand('backward')">Backward (‚Üì)</button><br>
            <button onclick="sendCommand('left')">Left (‚Üê)</button>
            <button onclick="sendCommand('right')">Right (‚Üí)</button>
        </div>
        <hr style="border-top: 1px solid #2f495e;">
        <div class="arm-controls">
            <h2>Data Acquisition</h2>
            <button onclick="sendCommand('probe')">üî¨ Probe Soil (Arm Down)</button>
            <button onclick="sendCommand('read_sensors')">üíß Read Soil Data</button>
            <button onclick="sendCommand('read_nav')">üß≠ Get GPS/Heading</button>
        </div>
        <hr style="border-top: 1px solid #2f495e;">
        <div class="data-display">
            <h2>Live Sensor Data</h2>
            <h3>Navigation Data</h3>
            <div class="data-row"><strong>Latitude:</strong> <span id="latitudeData">N/A</span></div>
            <div class="data-row"><strong>Longitude:</strong> <span id="longitudeData">N/A</span></div>
            <div class="data-row"><strong>GPS Fix:</strong> <span id="gpsFix">No Fix</span></div>
            <div class="data-row"><strong>Heading:</strong> <span id="headingData">N/A</span></div>
            <h3>Soil Data</h3>
            <div class="data-row"><strong>Moisture:</strong> <span id="moistureData">N/A</span></div>
            <div class="data-row"><strong>NPK (N, P, K):</strong> <span id="npkData">N/A</span></div>
        </div>
    </div>
    <div class="map-panel">
        <h2>2D Field Map (4m x 4m Grid)</h2>
        <canvas id="roverMap" width="500" height="500"></canvas>
        <p>Map Key: Grid = 1m x 1m. Circles = Health. Triangle = Rover.</p>
        <button onclick="clearMapData()">üóëÔ∏è Clear Map Data</button>
    </div>
    <div class="map-3d-panel">
        <h2>3D Soil Metric Visualization üìä</h2>
        <div id="threeDContainer"></div>
        <div class="three-d-controls">
            <p>Bar Height = Soil Moisture %. Bar Color = Plant Health (Green/Yellow/Red).</p>
        </div>
    </div>
    <div class="photo-panel">
        <div class="camera-control">
            <h2>Image Capture & Gallery</h2>
            <button onclick="sendCommand('capture')">üì∏ Take Photo (to Dell Wyse)</button>
            <button onclick="openStockImageModal()">üñºÔ∏è View/Load Stock Photos</button>
            <p>Last photo status: <span id="lastPhotoStatus">N/A</span>. Sent to Dell Wyse server at <span id="server-ip">192.168.X.X:5000</span>.</p>
        </div>
        <hr style="border-top: 1px solid #2f495e;">
        <h2>Plant Zone Photo Assignments (Zones 1-16)</h2>
        <p>Click a zone to upload a photo. Photos assigned here are used for the AI analysis.</p>
        <div id="photoGrid">
        </div>
        <input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
    </div>
    <div class="plant-analysis-panel">
        <h2>Plant-Specific AI Analysis (16 Zones) üî¨</h2>
        <p>This grid shows fused analysis of <b>Leaf Photo (AI)</b> + <b>Local Soil Data (NPK/Moisture)</b> for all zones.</p>
        <div id="plantAnalysisGrid">
        </div>
    </div>
</div>
<!-- MODALS -->
<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
        <h2>Saved Trial History</h2>
        <div id="trialHistoryList"></div>
        <hr style="border-top: 1px solid #3ec6e0; margin-top: 15px;">
        <button onclick="clearAllHistory()" style="background-color: #e84545;">üö® Clear All Saved Trials</button>
    </div>
</div>
<div id="stockImageModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeStockImageModal()">&times;</span>
        <h2>Stock Image Gallery (Pre-Diagnosed Leaves)</h2>
        <p>Click a stock photo to assign it to your currently selected plant zone.<br>
        Note: Stock photo hash ensures consistent diagnosis.</p>
        <div id="stockImageGrid">
        </div>
    </div>
</div>
<script>
// --- CONFIGURATION ---
const DETECT_MODEL_URL = ''; // Provide actual TensorFlow.js model URL if available
const THINGSPEAK_API_KEY = '6OXH3SUQ4VNSOJX1';
const THINGSPEAK_URL = 'https://api.thingspeak.com/update';
const ESP32_IP = '192.168.1.50';
const DELL_WYSE_IP = 'http://192.168.X.X:5000';
const ESP32_URL_BASE = `http://${ESP32_IP}`;
const STATUS_ELEMENT = document.getElementById('status');
const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');
document.getElementById('server-ip').innerText = DELL_WYSE_IP.replace('http://', '');
const FIELD_SIZE = 4;
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 500;
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100;
const PLANT_LOCATIONS_M = [];
for(let r=0; r<FIELD_SIZE; r++) for(let c=0; c<FIELD_SIZE; c++) PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5, id: (r * FIELD_SIZE) + c + 1});
let loggedData = [];
let photoData = {};
let stockPhotoData = {};
let selectedZone = 0;
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
let currentRoverData = { latitude: 'N/A', longitude: 'N/A', heading: 0, x_m: 2.0, y_m: 2.0 };

// --- TOMATO DIAGNOSTIC LIBRARY ---
const TOMATO_DIAGNOSTIC_LIBRARY = {
    DISEASE_TIERS: [
        { name: "Mottling/Mosaic Pattern (Viral)", severity: 95, probability: 0.10, class: 'rec-critical', recommendation: "***ISOLATION REQUIRED***: Strong indicator of Tobacco Mosaic Virus (TMV) or similar. Incurable. Remove plant immediately to prevent field-wide contamination." },
        { name: "Dark Spots & Lesions (Fungal/Bact)", severity: 85, probability: 0.15, class: 'rec-critical', recommendation: "***FUNGICIDE/BACTERICIDE***: Likely Early Blight or Bacterial Spot. Apply broad-spectrum fungicide and improve air circulation/reduce leaf wetness." },
        { name: "Leaf Curl & Wilting (Stress/Viral)", severity: 75, probability: 0.10, class: 'rec-critical', recommendation: "WILTING: Could be severe water stress, root rot, or Tomato Yellow Leaf Curl Virus (TYLCV). Check moisture urgently. If moisture is good, isolate for potential virus." },
        { name: "General Yellowing (Chlorosis)", severity: 50, probability: 0.25, class: 'rec-action', recommendation: "GENERAL YELLOWING: A common sign of nutrient deficiency (N, Mg, Fe) or pH imbalance. Check NPK data for confirmation." },
        { name: "Healthy, Deep Green", severity: 0, probability: 0.40, class: 'rec-optimal', recommendation: "OPTIMAL: No visual symptoms detected. Continue regular monitoring." }
    ],
    NPK_GUIDELINES: {
        moisture: { ideal_min: 40, ideal_max: 60, low_crit: 25, high_crit: 75, penalty_minor: 10, penalty_major: 30, low_rec: "deep watering", high_rec: "review soil drainage/stop irrigation" },
        N: { ideal_min: 60, ideal_max: 100, low_crit: 30, high_crit: 150, penalty_minor: 15, penalty_major: 40, low_rec: "high-Nitrogen (N) liquid feed", high_rec: "stop all N-fertilizer, flush soil" },
        P: { ideal_min: 50, ideal_max: 80, low_crit: 20, high_crit: 120, penalty_minor: 10, penalty_major: 25, low_rec: "Phosphorus (P) booster for root development", high_rec: "check fertilizer blend for P excess" },
        K: { ideal_min: 70, ideal_max: 120, low_crit: 40, high_crit: 180, penalty_minor: 10, penalty_major: 25, low_rec: "Potassium (K) to boost resistance/fruit set", high_rec: "check for K salt toxicity" },
    }
};

// --- CNN PHOTO ANALYSIS (SIMULATED) ---
let tomatoModel = null;
async function loadTomatoModel() {
    if (!DETECT_MODEL_URL) {
        tomatoModel = null;
        STATUS_ELEMENT.innerText = "Warning: AI Model not loaded (using mock analysis).";
        return;
    }
    try {
        tomatoModel = await tf.loadLayersModel(DETECT_MODEL_URL);
        STATUS_ELEMENT.innerText = "AI Model Loaded.";
    } catch (err) {
        tomatoModel = null;
        STATUS_ELEMENT.innerText = "Warning: AI Model load failed (using mock analysis).";
    }
}
// Simulated CNN or fallback deterministic analysis
async function getPhotoPredictionCNN(base64Image) {
    if (!tomatoModel) {
        return getPhotoPrediction(base64Image);
    }
    return new Promise((resolve) => {
        const img = new window.Image();
        img.onload = async () => {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            context.drawImage(img, 0, 0, 128, 128);
            let input = tf.browser.fromPixels(canvas).toFloat().div(255.0).expandDims(0);
            let preds = tomatoModel.predict(input).arraySync()[0];
            let maxIdx = preds.indexOf(Math.max(...preds));
            let diseaseTier = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS[maxIdx % TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.length];
            resolve(diseaseTier);
        };
        img.onerror = () => resolve(getPhotoPrediction(base64Image));
        img.src = base64Image;
    });
}
function simpleStringHash(str) {
    let hash = 0;
    for (let i = 0; i < Math.min(str.length, 1000); i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash |= 0;
    }
    return Math.abs(hash);
}
function deterministicPseudoRandom(seed) {
    const a = 1664525, c = 1013904223, m = 4294967296;
    let state = (Math.abs(Math.floor(seed)) * 101) % m;
    state = (a * state + c) % m;
    return state / m;
}
function getPhotoPrediction(base64Image) {
    const photoHash = simpleStringHash(base64Image);
    const randomRoll = deterministicPseudoRandom(photoHash);
    let cumulativeProb = 0;
    let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS[4];
    for (const disease of TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS) {
        cumulativeProb += disease.probability;
        if (randomRoll <= cumulativeProb) {
            prediction = disease;
            break;
        }
    }
    return prediction;
}

// --- 3D RENDERING ---
let scene, camera, renderer, rover3D, controls;
let dataCubes = {};
function initThreeD() {
    const container = document.getElementById('threeDContainer');
    const width = container.clientWidth;
    const height = container.clientHeight;
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202b3f);
    camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
    camera.position.set(2, 6, 2);
    camera.lookAt(2, 0, 2);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 10;
    controls.maxPolarAngle = Math.PI / 2.2;
    const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
    gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2);
    scene.add(gridHelper);
    const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
    const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x3ec6e0 });
    rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
    rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m);
    scene.add(rover3D);
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);
    animate();
}
function animate() {
    requestAnimationFrame(animate);
    if(controls) controls.update();
    renderer.render(scene, camera);
}
function updateRover3DPosition() {
    if (rover3D) {
        rover3D.position.set(
            parseFloat(currentRoverData.x_m),
            0.05,
            parseFloat(currentRoverData.y_m)
        );
        rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
    }
}
function clear3DDataCubes() {
    Object.values(dataCubes).forEach(cube => {
        scene.remove(cube);
        cube.geometry.dispose();
        cube.material.dispose();
    });
    dataCubes = {};
}
function getHealthColorHex(status) {
    switch (status) {
        case 'Good': return 0x3ec6e0;
        case 'Caution': return 0xffd166;
        case 'Bad': return 0xe84545;
        default: return 0x5a5a5a;
    }
}
function draw3DMap() {
    clear3DDataCubes();
    loggedData.forEach((data, index) => {
        const { x_m, y_m, moisture, healthStatus } = data;
        const cubeWidth = 0.5;
        const cubeDepth = 0.5;
        const cubeHeight = Math.max(0.01, moisture / MAX_MOISTURE);
        const colorHex = getHealthColorHex(healthStatus);
        const geometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
        const material = new THREE.MeshPhongMaterial({
            color: colorHex,
            opacity: 0.85,
            transparent: true
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(
            x_m,
            cubeHeight / 2,
            y_m
        );
        cube.name = `data-cube-${index}`;
        dataCubes[index] = cube;
        scene.add(cube);
    });
    updateRover3DPosition();
}

// --- PHOTO GRID & MODAL FUNCTIONS ---
function populateStockPhotos() {
    if (Object.keys(stockPhotoData).length === 16) return;
    const diseaseList = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS;
    for (let i = 1; i <= 16; i++) {
        const diseaseIndex = i % diseaseList.length;
        const base64 = `data:image/svg+xml;base64,mocked_stock_photo_hash_${i}_diag:${diseaseList[diseaseIndex].name.replace(/\s/g, '_')}`;
        stockPhotoData[i] = base64;
    }
}
function openStockImageModal() {
    populateStockPhotos();
    renderStockImageGrid();
    document.getElementById('stockImageModal').style.display = "block";
    if (selectedZone === 0) {
        STATUS_ELEMENT.innerText = "Select a stock photo, then click a zone (1-16) in the main photo grid to assign it.";
    }
}
function closeStockImageModal() {
    document.getElementById('stockImageModal').style.display = "none";
}
function renderStockImageGrid() {
    const grid = document.getElementById('stockImageGrid');
    grid.innerHTML = '';
    for (let i = 1; i <= 16; i++) {
        const base64Image = stockPhotoData[i];
        const prediction = getPhotoPrediction(base64Image);
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.style.maxWidth = '150px';
        cell.style.aspectRatio = '1/1';
        const img = document.createElement('img');
        img.src = base64Image;
        img.className = 'cell-photo';
        const label = document.createElement('div');
        label.style.position = 'absolute';
        label.style.bottom = '0';
        label.style.backgroundColor = 'rgba(62,198,224,0.82)';
        label.style.color = '#232d3f';
        label.style.padding = '5px';
        label.style.fontSize = '11px';
        label.innerText = `ID ${i}: ${prediction.name.split('(')[0].trim()}`;
        cell.appendChild(img);
        cell.appendChild(label);
        cell.onclick = () => assignStockPhotoToZone(i);
        grid.appendChild(cell);
    }
}
async function assignStockPhotoToZone(stockId) {
    if (selectedZone === 0) {
        STATUS_ELEMENT.innerText = "ERROR: Please click a zone (1-16) in the main grid first, then select a stock photo.";
        return;
    }
    const base64Image = stockPhotoData[stockId];
    photoData[selectedZone] = base64Image;
    renderPhotoInCell(selectedZone, base64Image);
    STATUS_ELEMENT.innerText = `Stock Photo ID ${stockId} assigned to Zone ${selectedZone}.`;
    closeStockImageModal();
    selectedZone = 0;
    await fetchAIResults();
}
function deletePhoto(zoneId) {
    if (!photoData[zoneId]) return;
    delete photoData[zoneId];
    renderPhotoInCell(zoneId, null);
    STATUS_ELEMENT.innerText = `Photo deleted from Zone ${zoneId}.`;
    fetchAIResults();
}
function generatePhotoGrid() {
    const grid = document.getElementById('photoGrid');
    for (let i = 1; i <= 16; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.id = 'zone-' + i;
        cell.innerHTML = `
            <span class="cell-label">${i}</span>
            <button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>
        `;
        cell.addEventListener('click', function(e) {
            if (e.target.className !== 'delete-photo-btn') {
                selectedZone = i;
                document.getElementById('fileInput').click();
            }
        });
        grid.appendChild(cell);
    }
    loadCurrentPhotoData();
}
async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file || selectedZone === 0) return;
    const reader = new FileReader();
    reader.onload = async function(e) {
        const base64Image = e.target.result;
        photoData[selectedZone] = base64Image;
        renderPhotoInCell(selectedZone, base64Image);
        selectedZone = 0;
        event.target.value = '';
        await fetchAIResults();
    };
    reader.readAsDataURL(file);
}
function renderPhotoInCell(zoneId, base64Image) {
    const cell = document.getElementById('zone-' + zoneId);
    if (!cell) return;
    const existingPhoto = cell.querySelector('.cell-photo');
    if (existingPhoto) existingPhoto.remove();
    if (base64Image) {
        const img = document.createElement('img');
        img.src = base64Image;
        img.className = 'cell-photo';
        cell.appendChild(img);
    }
}
function clearPhotoGrid() {
    for (let i = 1; i <= 16; i++) {
        renderPhotoInCell(i, null);
    }
}
function loadCurrentPhotoData() {
    clearPhotoGrid();
    for (const [zoneId, base64Image] of Object.entries(photoData)) {
        renderPhotoInCell(parseInt(zoneId), base64Image);
    }
}

// --- AI ANALYSIS LOGIC ---
function getNearestSensorData(plantX, plantY) {
    let nearestData = null;
    let min_dist_sq = Infinity;
    loggedData.forEach(data => {
        let dx = data.x_m - plantX;
        let dy = data.y_m - plantY;
        let dist_sq = dx * dx + dy * dy;
        if (dist_sq < 0.707 * 0.707 && dist_sq < min_dist_sq) {
            min_dist_sq = dist_sq;
            nearestData = data;
        }
    });
    return nearestData;
}
async function analyzePlant(plant, sensorData, photoExists) {
    let soilScore = 100;
    let soilProblems = [];
    let sensorDiagnosis = '';
    if (sensorData) {
        const { moisture, npk_n, npk_p, npk_k } = sensorData;
        const data = { moisture, N: npk_n, P: npk_p, K: npk_k };
        const keys = ['moisture', 'N', 'P', 'K'];
        keys.forEach(key => {
            const guideline = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES[key];
            const value = data[key];
            let problem = '';
            if (value < guideline.low_crit) { soilScore -= guideline.penalty_major; problem = `CRITICAL LOW ${key}`; }
            else if (value < guideline.ideal_min) { soilScore -= guideline.penalty_minor; problem = `LOW ${key}`; }
            else if (value > guideline.high_crit) { soilScore -= guideline.penalty_major; problem = `CRITICAL HIGH ${key}`; }
            else if (value > guideline.ideal_max) { soilScore -= guideline.penalty_minor; problem = `HIGH ${key}`; }
            if (problem) {
                let rec = (problem.includes('CRITICAL') ? "Urgent " : "") +
                    (value < guideline.low_crit ? guideline.low_rec : guideline.high_rec);
                soilProblems.push({ key, value, problem, rec });
            }
        });
        sensorDiagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;
    } else {
        return {
            id: plant.id, score: 20, visualDiagnosis: "Visual: N/A (Data Missing)", sensorDiagnosis: "Soil: Sensor Data Missing (Cannot Analyze)",
            recommendation: "***CRITICAL ERROR: DATA GAP***. Conduct soil probe at Zone " + plant.id + " immediately to enable fused analysis.",
            healthClass: 'rec-critical'
        };
    }
    let visualDiagnosis = "Visual: No Photo Taken";
    let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Healthy"));
    let finalRecommendation = '';
    let healthClass = 'rec-optimal';
    if (photoExists) {
        prediction = await getPhotoPredictionCNN(photoData[plant.id]);
        visualDiagnosis = `Visual: ${prediction.name}`;
    }
    const isYellow = prediction.name.includes('Yellowing');
    const isLesions = prediction.name.includes('Dark Spots');
    const isMottling = prediction.name.includes('Mottling');
    const isWilting = prediction.name.includes('Leaf Curl');
    const isLowN = soilProblems.some(p => p.problem.includes('CRITICAL LOW N'));
    const isLowP = soilProblems.some(p => p.problem.includes('CRITICAL LOW P'));
    const isLowK = soilProblems.some(p => p.problem.includes('CRITICAL LOW K'));
    const isCritMoisture = soilProblems.some(p => p.problem.includes('CRITICAL LOW moisture') || p.problem.includes('CRITICAL HIGH moisture'));
    if (isMottling || isWilting) {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
        soilScore = 5;
    } else if (isLesions) {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
        soilScore = Math.min(25, soilScore);
    } else if (isCritMoisture) {
        const critMoisture = soilProblems.find(p => p.problem.includes('CRITICAL'));
        finalRecommendation = `***CRITICAL WATER STRESS***: ${critMoisture.problem} (${critMoisture.value}%). ${critMoisture.rec}.`;
        healthClass = 'rec-critical';
        soilScore = Math.min(35, soilScore);
    } else if (isYellow && isLowN) {
        const critN = soilProblems.find(p => p.key === 'N');
        finalRecommendation = `***CONFIRMED PRIMARY N-DEFICIENCY***: Visual yellowing (Chlorosis) is strongly correlated with critical low Nitrogen (${critN.value} ppm). Action: Apply ${critN.rec}.`;
        healthClass = 'rec-action';
        soilScore = Math.min(50, soilScore);
    } else if (isLowP) {
        const critP = soilProblems.find(p => p.key === 'P');
        finalRecommendation = `CRITICAL P-DEFICIENCY ALERT: Soil data shows critically low Phosphorus (${critP.value} ppm). This limits energy transfer and root growth. Action: Apply ${critP.rec}.`;
        healthClass = 'rec-action';
        soilScore = Math.min(55, soilScore);
    } else if (isYellow && isLowK) {
        const critK = soilProblems.find(p => p.key === 'K');
        finalRecommendation = `CONFIRMED K-DEFICIENCY: Yellowing present. Critically low Potassium (${critK.value} ppm) is compromising fruit quality and disease resistance. Action: Apply ${critK.rec}.`;
        healthClass = 'rec-action';
        soilScore = Math.min(50, soilScore);
    } else if (isYellow) {
        finalRecommendation = `VISUAL ALERT (UNCONFIRMED): ${prediction.name}. Soil NPK is optimal. This suggests a **micro-nutrient deficiency** (Mg, Fe) or pH issue not measured. Consider supplementing micronutrients.`;
        healthClass = 'rec-action';
        soilScore = Math.min(75, soilScore);
    } else if (soilProblems.length > 0) {
        const problemString = soilProblems.map(p => `${p.problem} (${p.value}%)`).join(', ');
        const recString = soilProblems.map(p => p.rec).join('; ');
        finalRecommendation = `CAUTION: Soil Imbalance Detected (No Major Visual Symptoms): ${problemString}. Recommended action: ${recString}`;
        healthClass = soilScore <= 65 ? 'rec-action' : 'rec-optimal';
    } else {
        finalRecommendation = prediction.recommendation;
        healthClass = prediction.class;
    }
    const finalScore = Math.max(0, Math.round(soilScore - prediction.severity * 0.2));
    // Relay data to ThingSpeak for monitoring
    relayToThingSpeak({
        zone: plant.id,
        score: finalScore,
        diagnosis: visualDiagnosis,
        recommendation: finalRecommendation,
        moisture: sensorData.moisture,
        npk_n: sensorData.npk_n,
        npk_p: sensorData.npk_p,
        npk_k: sensorData.npk_k
    });
    return {
        id: plant.id, score: finalScore.toFixed(0), visualDiagnosis, sensorDiagnosis,
        recommendation: finalRecommendation.trim(), healthClass
    };
}
// RELAY TO THINGSPEAK (reliable, async)
function relayToThingSpeak(data) {
    // Use only important fields (ThingSpeak supports up to 8 fields per channel)
    fetch(`${THINGSPEAK_URL}?api_key=${THINGSPEAK_API_KEY}` +
        `&field1=${data.zone}` +
        `&field2=${data.score}` +
        `&field3=${encodeURIComponent(data.diagnosis)}` +
        `&field4=${encodeURIComponent(data.recommendation)}` +
        `&field5=${data.moisture}` +
        `&field6=${data.npk_n}` +
        `&field7=${data.npk_p}` +
        `&field8=${data.npk_k}`, { method: 'GET' })
    .then(response => response.text())
    .then(res => { /* Optionally display status */ })
    .catch(err => { /* Optionally log error for reliability */ });
}
async function fetchAIResults() {
    const analysisGrid = document.getElementById('plantAnalysisGrid');
    analysisGrid.innerHTML = '';
    for (const plant of PLANT_LOCATIONS_M) {
        const sensorData = getNearestSensorData(plant.x, plant.y);
        const photoExists = !!photoData[plant.id];
        const analysis = await analyzePlant(plant, sensorData, photoExists);
        const recLabel = analysis.recommendation;
        const card = `
            <div class="analysis-card">
                <div class="plant-id-label">Zone ${analysis.id} (P${Math.ceil(plant.id/4)}R${(plant.id-1)%4 + 1})</div>
                <div class="analysis-row">
                    <strong>Composite Score:</strong> <span class="status-good">${analysis.score}/100</span>
                </div>
                <div class="analysis-row">
                    <strong>Leaf Analysis:</strong> ${analysis.visualDiagnosis}
                </div>
                <div class="analysis-row">
                    <strong>Soil Analysis:</strong> ${analysis.sensorDiagnosis}
                </div>
                <div class="analysis-row" style="margin-top: 10px;">
                    <strong>Recommendation:</strong> <span class="${analysis.healthClass}">${recLabel}</span>
                </div>
            </div>
        `;
        analysisGrid.insertAdjacentHTML('beforeend', card);
    }
    STATUS_ELEMENT.innerText = `AI Analysis Complete: ${PLANT_LOCATIONS_M.length} plants analyzed.`;
}

// --- COMMUNICATION, MAP, AND HISTORY FUNCTIONS ---
function sendCommand(command) {
    let url = (command === 'capture') ? `${ESP32_URL_BASE}/capture` : `${ESP32_URL_BASE}/move?dir=${command}`;
    STATUS_ELEMENT.innerText = `Sending command: ${command}...`;
    fetch(url)
    .then(response => {
        if (!response.ok) { throw new Error(`HTTP Error: ${response.status}`); }
        return response.text();
    })
    .then(data => {
        STATUS_ELEMENT.innerText = `Command '${command}' Success.`;
        if (command.startsWith('read_') || command === 'probe') {
            setTimeout(() => fetchData(command), 500);
        } else if (command === 'capture') {
            LAST_PHOTO_STATUS.innerText = 'Photo captured and sent to server.';
            const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
            if (nearestPlant) {
                photoData[nearestPlant.id] = `data:image/jpeg;base64,mocked_rover_capture_zone_${nearestPlant.id}_${Date.now()}`;
                renderPhotoInCell(nearestPlant.id, photoData[nearestPlant.id]);
            }
            setTimeout(() => fetchAIResults(), 1000);
        }
    })
    .catch(error => {
        STATUS_ELEMENT.innerText = `ERROR: Command ${command} failed. Is ESP32 at ${ESP32_IP} online?`;
        console.error('Error sending command:', error);
    });
}
function getNearestPlant(x, y) {
    let nearest = null;
    let minDistSq = Infinity;
    PLANT_LOCATIONS_M.forEach(plant => {
        let dx = plant.x - x;
        let dy = plant.y - y;
        let distSq = dx * dx + dy * dy;
        if (distSq < minDistSq) {
            minDistSq = distSq;
            nearest = plant;
        }
    });
    return nearest;
}
function fetchData(lastCommand = null) {
    STATUS_ELEMENT.innerText = "Fetching latest data...";
    setTimeout(() => {
        let headingStr = (Math.random() * 360).toFixed(1) + ' deg';
        currentRoverData.heading = parseFloat(headingStr.split(' ')[0]) || 0;
        currentRoverData.latitude = "40.7128";
        currentRoverData.longitude = "-74.0060";
        document.getElementById('latitudeData').innerText = currentRoverData.latitude;
        document.getElementById('longitudeData').innerText = currentRoverData.longitude;
        document.getElementById('gpsFix').innerText = "3D Fix";
        document.getElementById('headingData').innerText = headingStr;
        if (lastCommand !== 'read_nav' && lastCommand !== 'stop') {
            currentRoverData.x_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.x_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
            currentRoverData.y_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.y_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
        }
        let moistureVal = (Math.random() * 80 + 10).toFixed(1);
        let npk_n = Math.floor(Math.random() * 100);
        let npk_p = Math.floor(Math.random() * 100);
        let npk_k = Math.floor(Math.random() * 100);
        let moistureStr = moistureVal + '%';
        let npkStr = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
        document.getElementById('moistureData').innerText = moistureStr;
        document.getElementById('npkData').innerText = npkStr;
        if (lastCommand === 'probe' || lastCommand === 'read_sensors') {
            let healthStatus = analyzeHealth(parseFloat(moistureVal), npk_n, npk_p, npk_k);
            loggedData.push({
                x_m: parseFloat(currentRoverData.x_m),
                y_m: parseFloat(currentRoverData.y_m),
                healthStatus: healthStatus,
                moisture: parseFloat(moistureVal),
                npk_n: npk_n, npk_p: npk_p, npk_k: npk_k
            });
            STATUS_ELEMENT.innerText = `Data logged! Status: ${healthStatus}`;
            fetchAIResults();
        }
        drawMap();
        draw3DMap();
        STATUS_ELEMENT.innerText = "Data update complete.";
    }, 500);
}
function analyzeHealth(moisture, npk_n, npk_p, npk_k) {
    let issues = 0;
    const MIN_MOISTURE = 30;
    const IDEAL_NPK_SUM = 150;
    const NPK_TOLERANCE = 50;
    if (moisture < MIN_MOISTURE || moisture > 80) { issues++; }
    let npk_sum = npk_n + npk_p + npk_k;
    if (Math.abs(npk_sum - IDEAL_NPK_SUM) > NPK_TOLERANCE) { issues++; }
    if (issues >= 2) return 'Bad';
    if (issues === 1) return 'Caution';
    return 'Good';
}
function clearMapData(resetRover = true) {
    loggedData = [];
    photoData = {};
    if (resetRover) {
        currentRoverData.x_m = 2.0;
        currentRoverData.y_m = 2.0;
        currentRoverData.heading = 0;
    }
    drawMap();
    draw3DMap();
    clearPhotoGrid();
    fetchAIResults();
    STATUS_ELEMENT.innerText = "Map and photo data cleared.";
}
function drawMap() {
    CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE);
    CTX.strokeStyle = '#2f495e';
    CTX.lineWidth = 1;
    for (let i = 1; i < FIELD_SIZE; i++) {
        let px = i * PIXELS_PER_METER;
        CTX.beginPath(); CTX.moveTo(px, 0); CTX.lineTo(px, MAP_SIZE); CTX.stroke();
        CTX.beginPath(); CTX.moveTo(0, px); CTX.lineTo(MAP_SIZE, px); CTX.stroke();
    }
    const GRID_SIZE_M = 1.0;
    for (let row = 0; row < FIELD_SIZE; row++) {
        for (let col = 0; col < FIELD_SIZE; col++) {
            let center_x_m = col * GRID_SIZE_M + 0.5;
            let center_y_m = row * GRID_SIZE_M + 0.5;
            let nearestData = getNearestSensorData(center_x_m, center_y_m);
            if (nearestData) {
                let moistureColor;
                if (nearestData.moisture < 20) { moistureColor = '#3ec6e060'; }
                else if (nearestData.moisture > 70) { moistureColor = '#e8454560'; }
                else { moistureColor = '#65e39c60'; }
                CTX.fillStyle = moistureColor;
                CTX.fillRect(
                    col * PIXELS_PER_METER,
                    MAP_SIZE - ((row + 1) * PIXELS_PER_METER),
                    PIXELS_PER_METER,
                    PIXELS_PER_METER
                );
            }
        }
    }
    PLANT_LOCATIONS_M.forEach((plant, index) => {
        let px = plant.x * PIXELS_PER_METER;
        let py = MAP_SIZE - (plant.y * PIXELS_PER_METER);
        let nearestData = getNearestSensorData(plant.x, plant.y);
        let plantColor = nearestData ? getHealthColor(nearestData.healthStatus) : '#5a5a5a';
        CTX.fillStyle = plantColor;
        CTX.beginPath();
        CTX.arc(px, py, 7, 0, 2 * Math.PI);
        CTX.fill();
        if (nearestData && nearestData.healthStatus) {
            CTX.fillStyle = 'white';
            CTX.font = '13px Montserrat';
            CTX.fillText(nearestData.healthStatus.charAt(0), px - 4, py + 5);
        }
    });
    let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
    let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
    let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);
    CTX.fillStyle = '#3ec6e0';
    CTX.save();
    CTX.translate(rover_x_px, rover_y_px);
    CTX.rotate(heading_rad);
    CTX.beginPath();
    CTX.moveTo(12, 0);
    CTX.lineTo(-12, -10);
    CTX.lineTo(-12, 10);
    CTX.closePath();
    CTX.fill();
    CTX.restore();
    CTX.fillStyle = 'white';
    CTX.beginPath();
    CTX.arc(rover_x_px, rover_y_px, 4, 0, 2 * Math.PI);
    CTX.fill();
}
function getHealthColor(status) {
    switch (status) {
        case 'Good': return '#3ec6e0';
        case 'Caution': return '#ffd166';
        case 'Bad': return '#e84545';
        default: return '#5a5a5a';
    }
}

// --- HISTORY & DATA SAVING FUNCTIONS ---
function saveCurrentTrial() {
    populateStockPhotos();
    const trialData = {
        id: currentTrialNumber,
        date: new Date().toLocaleString(),
        roverData: { ...currentRoverData },
        loggedData: [...loggedData],
        photoData: { ...photoData },
        stockPhotoData: { ...stockPhotoData },
        aiData: {
            analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML
        }
    };
    trialHistory.push(trialData);
    localStorage.setItem('trialHistory', JSON.stringify(trialHistory));
    STATUS_ELEMENT.innerText = `Trial ${currentTrialNumber} saved successfully! Starting new trial...`;
    loggedData = [];
    photoData = {};
    currentTrialNumber++;
    document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
    clearMapData(false);
    clearPhotoGrid();
    clear3DDataCubes();
    fetchAIResults();
    updateRover3DPosition();
}
function openHistoryModal() {
    const modal = document.getElementById('historyModal');
    const list = document.getElementById('trialHistoryList');
    list.innerHTML = '';
    if (trialHistory.length === 0) {
        list.innerHTML = '<p>No trials saved yet.</p>';
    } else {
        trialHistory.forEach(trial => {
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.innerHTML = `<strong>Trial ${trial.id}:</strong> ${trial.date} (${trial.loggedData.length} readings)`;
            item.onclick = () => loadPastTrial(trial.id);
            list.appendChild(item);
        });
    }
    modal.style.display = "block";
}
function closeHistoryModal() {
    document.getElementById('historyModal').style.display = "none";
}
function loadPastTrial(trialId) {
    const trial = trialHistory.find(t => t.id === trialId);
    if (!trial) return;
    currentRoverData = trial.roverData;
    document.getElementById('latitudeData').innerText = trial.roverData.latitude;
    document.getElementById('longitudeData').innerText = trial.roverData.longitude;
    document.getElementById('headingData').innerText = trial.roverData.heading + ' deg';
    document.getElementById('gpsFix').innerText = 'Historical';
    loggedData = trial.loggedData;
    drawMap();
    draw3DMap();
    photoData = trial.photoData;
    stockPhotoData = trial.stockPhotoData || {};
    loadCurrentPhotoData();
    document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;
    STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
    document.getElementById('currentTrialNumber').innerText = `${currentTrialNumber} (Viewing Trial ${trialId})`;
    closeHistoryModal();
}
function clearAllHistory() {
    if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
        localStorage.removeItem('trialHistory');
        trialHistory = [];
        currentTrialNumber = 1;
        document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
        closeHistoryModal();
        STATUS_ELEMENT.innerText = "All trial history cleared.";
    }
}

// --- Initialization ---
window.onload = async function() {
    await loadTomatoModel();
    initThreeD();
    drawMap();
    generatePhotoGrid();
    populateStockPhotos();
    await fetchAIResults();
};
</script>
</body>
</html>
