<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>S.C.O.U.T. Rover Full-Spectrum Data Fusion & Control Console (V21.0 - Flood Analysis, Fair Score & Viz Fix)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<style>
/* =================================================================
   SECTION 0.1: CRITICAL SYSTEM-WIDE CSS STYLES (Highly Detailed Dark Theme)
   ================================================================= */
body { 
    font-family: 'Consolas', 'Segoe UI', monospace; 
    margin: 0; 
    padding: 25px; 
    background-color: #0c1015; /* Deeper background for the ultimate dark mode */
    color: #c9d1d9; 
    transition: background-color 0.5s;
    line-height: 1.5; 
}
.container {
    max-width: 1920px; /* Maximizing width for high-resolution displays */
    margin: auto;
    background: #161b22; 
    padding: 40px;
    border-radius: 18px;
    box-shadow: 0 15px 40px rgba(0,0,0,1.0); /* Increased shadow depth */
    display: flex;
    flex-wrap: wrap;
    border: 3px solid #30363d; /* Thicker border for structural definition */
}
/* LAYOUT AND PANEL DEFINITION (Ensuring Robust Flex Behavior) */
.controls-panel { flex: 1; min-width: 400px; padding-right: 35px; border-right: 1px dashed #30363d; }
.map-panel { flex: 1; min-width: 480px; padding: 0 35px; }
.photo-panel { flex: 1; min-width: 480px; padding-left: 35px; border-left: 1px dashed #30363d; }
.map-3d-panel { flex-basis: 100%; min-width: 100%; margin-top: 40px; padding-top: 20px; border-top: 3px solid #30363d; }
.plant-analysis-panel {
    flex-basis: 100%;
    margin-top: 50px;
    padding-top: 30px;
    border-top: 3px solid #30363d;
}
/* Typography and Status Indicators (Enhanced Visual Feedback) */
h1 { color: #58a6ff; border-bottom: 5px double #30363d; padding-bottom: 15px; margin-bottom: 30px; font-size: 2.6em; font-weight: 800; }
h2 { color: #79c0ff; margin-top: 35px; margin-bottom: 15px; font-size: 1.9em; border-bottom: 1px solid #30363d; padding-bottom: 5px; }
h3 { color: #4ac9b0; margin-top: 20px; font-size: 1.4em; }
#status { font-weight: 900; color: #f08047; font-size: 1.25em; display: block; margin-top: 10px; }
.data-display {
    margin-top: 30px;
    padding: 25px;
    border: 2px solid #30363d;
    border-radius: 12px;
    background-color: #0f131a;
    transition: box-shadow 0.3s;
}
.data-display:hover { box-shadow: 0 0 18px rgba(88, 166, 255, 0.3); }
/* Data Rows (Alignment Control) */
.data-row { margin: 12px 0; }
.data-row strong {
    display: inline-block;
    width: 220px; /* Increased for clean alignment */
    color: #4ac9b0;
}
/* Control Buttons (Explicit Color Coding & Code Clean-up) */
button {
    padding: 16px 24px;
    margin: 8px 6px;
    cursor: pointer;
    border: none;
    border-radius: 10px;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.1s, box-shadow 0.3s;
    letter-spacing: 1.2px;
    font-size: 1.08em;
    text-transform: uppercase;
    box-shadow: 0 5px 8px rgba(0,0,0,0.5);
    white-space: nowrap;
}
button:hover { transform: translateY(-3px); box-shadow: 0 8px 12px rgba(0,0,0,0.8); }
.move-controls button { background-color: #58a6ff; color: #0d1117; }
.arm-controls button { background-color: #3fb950; color: #0d1117; }
.history-controls button { background-color: #e3b341; color: #0d1117; }
.photo-controls button { background-color: #f08047; color: #0d1117; }
/* MAP STYLES */
#roverMap {
    border: 4px solid #58a6ff;
    border-radius: 5px;
    background-color: #0f131a;
}
/* GRID STYLES (4x4 Zones) */
#photoGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 8px;
    border: 3px solid #58a6ff;
    max-width: 480px;
    margin: 25px auto;
    aspect-ratio: 1 / 1;
    background-color: #0f131a;
    position: relative;
}
.grid-cell {
    background-color: #21262d;
    border: 1px solid #3fb950;
    position: relative;
    cursor: pointer;
    overflow: hidden;
    aspect-ratio: 1/1;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9em;
    font-weight: bold;
    color: #4ac9b0;
    transition: border 0.2s, background-color 0.2s;
}
.grid-cell:hover { border: 3px solid #79c0ff; background-color: #2a3038; }
/* Styles for delete button for embedded file input to work */
.delete-photo-btn { position: absolute;
    top: 5px; right: 5px; padding: 2px 5px; font-size: 0.8em; z-index: 10;
    /* Ensure button is on top of the transparent input */ background-color: #f85149; color: #0d1117; border-radius: 50%;
}
/* ANALYSIS CARD STYLING */
#plantAnalysisGrid { 
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(550px, 1fr)); 
    gap: 40px; 
    margin-top: 30px;
}
.analysis-card { 
    padding: 35px; 
    border-radius: 20px; 
    background-color: #21262d; 
    box-shadow: 0 10px 25px rgba(0,0,0,0.8); 
    display: flex; 
    flex-direction: column;
}
.plant-id-label { 
    font-size: 2.2em;
    font-weight: 900; 
    color: #ffd700; 
    border-bottom: 5px double #30363d; 
    padding-bottom: 15px; 
    margin-bottom: 25px; 
}
.assessment-section { 
    margin-bottom: 30px; 
    padding: 25px;
    border-radius: 12px; 
    flex-grow: 1; /* Make all cards fill the vertical space */
}
/* Recommendation Coloring (Updated for Three-Part Structure) */
.rec-optimal, .rec-action, .rec-critical, .rec-no-data, .partial-analysis { 
    padding: 15px; 
    border-radius: 10px; 
    display: block; 
    margin-top: 18px; 
    font-size: 1.05em; 
    line-height: 1.4; 
}
.partial-analysis {
    background-color: #0f131a; /* Darker background for partials */
    border: 1px solid #30363d;
    margin-bottom: 15px;
}
.rec-optimal { background-color: #3fb950; color: #0d1117; font-weight: bold;} 
.rec-action { background-color: #e3b341; color: #0d1117; font-weight: bold;}
.rec-critical { background-color: #f85149; color: #0d1117; font-weight: bold;}
.rec-no-data { background-color: #58a6ff; color: #0d1117; }

/* MODAL AND HISTORY LIST STYLES */
.modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0;
    width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.98); }
.modal-content { background-color: #161b22; margin: 3% auto; padding: 50px;
    border: 3px solid #30363d; width: 95%; max-width: 1600px; border-radius: 20px; }
.close-btn { color: #aaa; float: right; font-size: 50px;
    font-weight: bold; }
.trial-item { padding: 20px; margin-bottom: 12px; background-color: #0f131a; border-left: 6px solid #e3b341; border-radius: 12px; cursor: pointer;
    transition: background-color 0.3s; }
.trial-item:hover { background-color: #21262d; border-left: 6px solid #79c0ff; }
#stockImageGrid { display: grid;
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 15px; margin-top: 20px; }
.stock-image-preview { width: 100%; height: 100px; object-fit: cover; border-radius: 8px; cursor: pointer; transition: transform 0.2s; }
.stock-image-preview:hover { transform: scale(1.05); }

/* Utility Styles */
.control-group { margin-bottom: 25px; padding: 10px; border: 1px dashed #30363d; border-radius: 8px;}
.control-group h3 { margin-top: 0; }
</style>
</head>
<body>

<div class="container">
    <h1>SCOUT Rover Data Fusion & Control Console (V21.0)</h1>

    <div class="controls-panel">
        <h2>System Controls & Real-Time Data</h2>
        <div class="control-group move-controls">
            <h3>Rover Movement</h3>
            <button onclick="moveRover('F')">Forward</button>
            <button onclick="moveRover('L')">Left</button>
            <button onclick="moveRover('R')">Right</button>
            <button onclick="moveRover('B')">Backward</button>
        </div>
        
        <div class="control-group arm-controls">
            <h3>Sampling & Analysis</h3>
            <button onclick="collectSensorData()">Collect Sensor Data</button>
            <button onclick="startVisualScan()">Start Visual Scan</button>
        </div>
        
        <div class="control-group history-controls">
            <h3>System Management</h3>
            <button onclick="showHistoryModal()">View History</button>
            <button onclick="resetSensorAndMapData(true)">Reset All Data</button>
        </div>

        <div class="data-display">
            <h3>ROVER STATUS</h3>
            <span id="status">System Boot: Initializing...</span>
            <div class="data-row"><strong>Current Grid Position:</strong> <span id="currentPosition">A1</span></div>
            <div class="data-row"><strong>Battery Level:</strong> <span id="batteryLevel">100%</span></div>
            <div class="data-row"><strong>Last Scan Timestamp:</strong> <span id="lastScanTime">N/A</span></div>
        </div>
        
        <div class="data-display">
            <h3>LAST SENSOR READING</h3>
            <div class="data-row"><strong>Moisture:</strong> <span id="moistureData">N/A</span></div>
            <div class="data-row"><strong>Nitrogen (N) [ppm]:</strong> <span id="nitrogenData">N/A</span></div>
            <div class="data-row"><strong>Phosphorus (P) [ppm]:</strong> <span id="phosphorusData">N/A</span></div>
            <div class="data-row"><strong>Potassium (K) [ppm]:</strong> <span id="potassiumData">N/A</span></div>
        </div>
    </div>
    
    <div class="map-panel">
        <h2>Field Map & Sampling Zones (4x4)</h2>
        <canvas id="roverMap" width="480" height="480"></canvas>
        <p style="margin-top: 15px;">**Map Legend**: Blue circle = Sensor Data Collected. Colors reflect the Fused Health Score.</p>
    </div>

    <div class="photo-panel">
        <h2>Visual Field Data & Computer Vision (CV)</h2>
        <div class="photo-controls">
            <button onclick="showStockPhotosModal()">Select Stock Photo (Mock CV)</button>
        </div>
        <div id="photoGrid">
            </div>
    </div>
    
    <div class="map-3d-panel">
        <h2>3D Terrain & Plant Health Visualization</h2>
        <div id="threeDContainer" style="width: 100%; height: 500px; border: 4px solid #3fb950; border-radius: 5px; background-color: #0f131a;"></div>
    </div>

    <div class="plant-analysis-panel">
        <h2>Data Fusion & Plant Health Analysis (V21.0)</h2>
        <button onclick="triggerComprehensiveAnalysisCycle()" class="arm-controls" style="width: 100%; margin: 15px 0 30px 0;">RUN COMPREHENSIVE FUSION ANALYSIS</button>
        <div id="plantAnalysisGrid">
            </div>
    </div>

</div>

<div id="historyModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
        <h2>System History Log</h2>
        <div id="historyList">
            </div>
    </div>
</div>

<div id="stockPhotosModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeStockPhotosModal()">&times;</span>
        <h2>Assign Visual Data (Stock Photos for Mock CV)</h2>
        <p>Click an image to assign it to the current grid position (<span id="currentAssignmentPosition">A1</span>).</p>
        <div id="stockImageGrid">
            </div>
    </div>
</div>

<script>
/* =================================================================
   SECTION 1: GLOBAL VARIABLES & CONSTANTS
   ================================================================= */
const GRID_SIZE = 4;
const STATUS_ELEMENT = document.getElementById('status');
const MAP_CANVAS = document.getElementById('roverMap');
const MAP_CONTEXT = MAP_CANVAS.getContext('2d');
const HISTORY_MODAL = document.getElementById('historyModal');
const STOCK_PHOTOS_MODAL = document.getElementById('stockPhotosModal');
const ANALYSIS_GRID = document.getElementById('plantAnalysisGrid');

// Data structures
let currentPosition = { row: 0, col: 0 }; // 0-indexed (0,0) = A1
let systemLoggedSensorDataArray = []; // Stores {id: string, timestamp: string, data: object, analysis: object}
let currentPhotoAssignmentData = {}; // Stores {id: url/path}
let openCvLibraryIsReady = false; // Flag for OpenCV.js

// Optimal Ranges for fair scoring (used in V21.0)
const OPTIMAL_MOISTURE_RANGE = [45, 65]; // %
const N_OPTIMAL = [100, 250]; // ppm
const P_OPTIMAL = [30, 60]; // ppm
const K_OPTIMAL = [80, 150]; // ppm

// THREE.js Globals
let SCENE, CAMERA, RENDERER, CONTROLS;
const systemAnalysisResultsMap = {}; // Key: Grid ID (A1, B2...), Value: {score: int, color: hex, etc.}


/* =================================================================
   SECTION 2: ROVER MOVEMENT & GRID LOGIC
   ================================================================= */

/**
 * Converts 0-indexed (row, col) to Grid ID (A1, B2, etc.)
 * @param {number} r - Row index (0-3)
 * @param {number} c - Column index (0-3)
 * @returns {string} Grid ID
 */
function toGridId(r, c) {
    const rowChar = String.fromCharCode('A'.charCodeAt(0) + r);
    const colNum = c + 1;
    return `${rowChar}${colNum}`;
}

/**
 * Converts Grid ID (A1, B2, etc.) to 0-indexed (row, col)
 * @param {string} id - Grid ID
 * @returns {{row: number, col: number}} 0-indexed coordinates
 */
function fromGridId(id) {
    const rowChar = id.charAt(0);
    const colNum = parseInt(id.substring(1));
    const row = rowChar.charCodeAt(0) - 'A'.charCodeAt(0);
    const col = colNum - 1;
    return { row, col };
}

/**
 * Moves the rover in the specified direction.
 * @param {string} direction - 'F', 'B', 'L', 'R'
 */
function moveRover(direction) {
    let { row, col } = currentPosition;
    
    switch (direction) {
        case 'F': row = Math.max(0, row - 1); break;
        case 'B': row = Math.min(GRID_SIZE - 1, row + 1); break;
        case 'L': col = Math.max(0, col - 1); break;
        case 'R': col = Math.min(GRID_SIZE - 1, col + 1); break;
    }
    
    currentPosition = { row, col };
    const newId = toGridId(row, col);
    
    document.getElementById('currentPosition').innerText = newId;
    STATUS_ELEMENT.innerText = `ROVER MOVEMENT: Moved ${direction}. New position: ${newId}.`;

    // Highlight the new position on the photo grid
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('active-cell');
        if (cell.id === `cell-${newId}`) {
            cell.classList.add('active-cell');
        }
    });

    // Update data display if data exists for the new cell
    const sensorData = systemLoggedSensorDataArray.find(d => d.id === newId);
    updateSensorDisplay(sensorData ? sensorData.data : null);

    // Update map to show the rover's current location (optional, implicit in the circle color change)
    updateMapVisualization(); 
}

/**
 * Generates the HTML grid for photos and assigns click handlers.
 */
function generatePhotoGrid() {
    const photoGrid = document.getElementById('photoGrid');
    photoGrid.innerHTML = '';
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const id = toGridId(r, c);
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.id = `cell-${id}`;
            cell.textContent = id;
            cell.onclick = () => moveRover(null); // Move rover to clicked cell (simplification)
            photoGrid.appendChild(cell);
        }
    }
    // Initial movement to A1
    moveRover(null); 
}

/* =================================================================
   SECTION 3: DATA LOGGING & MOCK DATA GENERATION (V21.0 - Fixing Bias)
   ================================================================= */

/**
 * Generates randomized mock sensor data based on a defined health bias.
 * V21.0: Implements a 60% chance of non-optimal state (Flood, Drought, Deficiency)
 * @param {string} id - Grid ID (A1, B2, etc.)
 * @returns {{moisture: number, N: number, P: number, K: number, cvDiagnosis: string[]}} Sensor and CV Data
 */
function generateRandomMockSensorDataV21(id) {
    let moisture, N, P, K;
    let cvDiagnosis = ['Healthy Growth', 'Optimal Leaf Structure'];
    
    const idIndex = fromGridId(id).row * GRID_SIZE + fromGridId(id).col;
    const isPostFlood = (idIndex % 4) === 0; // 25% chance of severe flood scenario
    const isStressScenario = Math.random() < 0.6; // 60% chance of non-optimal state

    if (isPostFlood) {
        // Severe Post-Flood Scenario: High moisture, low mobile nutrients (N, K)
        moisture = Math.floor(Math.random() * (95 - 80 + 1)) + 80; // 80-95% (Waterlogged)
        N = Math.floor(Math.random() * (40 - 10 + 1)) + 10; // 10-40 ppm (N Leached)
        P = Math.floor(Math.random() * (70 - 40 + 1)) + 40; // P retention might be higher
        K = Math.floor(Math.random() * (70 - 20 + 1)) + 20; // 20-70 ppm (K Leached)
        cvDiagnosis = ['Severe Chlorosis', 'Water Soaked Lesions', 'Wilting'];
    } else if (isStressScenario) {
        // General Stress Scenario: (Mix of Drought, Deficiency, Toxicity)
        if (Math.random() < 0.3) { // Drought
            moisture = Math.floor(Math.random() * (35 - 10 + 1)) + 10; // 10-35%
            N = Math.floor(Math.random() * (150 - 80 + 1)) + 80;
            P = Math.floor(Math.random() * (50 - 30 + 1)) + 30;
            K = Math.floor(Math.random() * (120 - 60 + 1)) + 60;
            cvDiagnosis = ['Leaf Curling', 'Wilting'];
        } else { // Deficiency/Toxicity
            moisture = Math.floor(Math.random() * (70 - 40 + 1)) + 40;
            if (idIndex % 3 === 0) { // Severe N Deficiency
                N = Math.floor(Math.random() * (50 - 10 + 1)) + 10;
                cvDiagnosis = ['Severe Yellowing', 'Stunted Growth'];
            } else if (idIndex % 3 === 1) { // P Deficiency
                P = Math.floor(Math.random() * (20 - 5 + 1)) + 5;
                cvDiagnosis = ['Purple Veining', 'Necrotic Spots'];
            } else { // K Deficiency/Over-fertilization
                K = Math.floor(Math.random() * (40 - 10 + 1)) + 10;
                cvDiagnosis = ['Scorching (K deficiency)', 'Mottling'];
            }
        }
    } else {
        // Healthy Scenario (40% chance)
        moisture = Math.floor(Math.random() * (70 - 40 + 1)) + 40;
        N = Math.floor(Math.random() * (250 - 100 + 1)) + 100;
        P = Math.floor(Math.random() * (60 - 30 + 1)) + 30;
        K = Math.floor(Math.random() * (150 - 80 + 1)) + 80;
    }
    
    return { moisture, N, P, K, cvDiagnosis };
}

/**
 * Handles the sensor data collection and logging process.
 */
function collectSensorData() {
    const id = toGridId(currentPosition.row, currentPosition.col);
    const mockData = generateRandomMockSensorDataV21(id);
    const now = new Date().toLocaleString();

    // Log the data (or overwrite if already exists for this position)
    const existingIndex = systemLoggedSensorDataArray.findIndex(d => d.id === id);
    const newEntry = {
        id: id,
        timestamp: now,
        data: mockData,
        analysis: {} // Placeholder for future analysis result
    };

    if (existingIndex !== -1) {
        systemLoggedSensorDataArray[existingIndex] = newEntry;
    } else {
        systemLoggedSensorDataArray.push(newEntry);
    }
    
    saveStateToLocalStorage();
    updateSensorDisplay(mockData);
    STATUS_ELEMENT.innerText = `DATA LOGGED: Sensor data collected for ${id}. Ready for analysis.`;
    updateMapVisualization(); // Update map after logging new data
}

/**
 * Updates the real-time sensor data display panel.
 * @param {object | null} data - The sensor data object or null.
 */
function updateSensorDisplay(data) {
    document.getElementById('lastScanTime').innerText = data ? new Date().toLocaleTimeString() : 'N/A';
    document.getElementById('moistureData').innerText = data ? `${data.moisture}%` : 'N/A';
    document.getElementById('nitrogenData').innerText = data ? `${data.N} ppm` : 'N/A';
    document.getElementById('phosphorusData').innerText = data ? `${data.P} ppm` : 'N/A';
    document.getElementById('potassiumData').innerText = data ? `${data.K} ppm` : 'N/A';
    
    document.getElementById('batteryLevel').innerText = `${Math.max(10, Math.floor(Math.random() * 90) + 10)}%`; // Mock battery drain
}

/* =================================================================
   SECTION 4: COMPUTER VISION (CV) & PHOTO GRID LOGIC
   ================================================================= */

/**
 * Placeholder function for mock stock photo data.
 */
function populateStockPhotos() {
    window.stockPhotoData = [
        { url: 'https://i.imgur.com/8Qp4Z0c.png', diagnosis: ['Healthy Growth', 'Optimal Leaf Structure'] },
        { url: 'https://i.imgur.com/k9b8fN0.png', diagnosis: ['Severe Yellowing', 'Stunted Growth'] }, // N Deficiency
        { url: 'https://i.imgur.com/N7b0D9y.png', diagnosis: ['Leaf Curling', 'Wilting', 'Severe Drought'] }, // Drought
        { url: 'https://i.imgur.com/HqP3P3d.png', diagnosis: ['Scorching (K deficiency)', 'Necrotic Lesions'] }, // K Deficiency
        { url: 'https://i.imgur.com/j4G5hRk.png', diagnosis: ['Purple Veining', 'Small Leaf Size'] }, // P Deficiency
        { url: 'https://i.imgur.com/0dY7r5F.png', diagnosis: ['Water Soaked Lesions', 'Fungal Growth'] }, // Post-Flood Damage
    ];
}

/**
 * Opens the modal to assign a stock photo to the current grid cell.
 */
function showStockPhotosModal() {
    if (!openCvLibraryIsReady) {
        STATUS_ELEMENT.innerText = "ERROR: OpenCV.js is still initializing. Please wait. (Full CV capability disabled.)";
        // Continue to show modal, but warn.
    }
    
    const id = toGridId(currentPosition.row, currentPosition.col);
    document.getElementById('currentAssignmentPosition').innerText = id;
    
    const grid = document.getElementById('stockImageGrid');
    grid.innerHTML = '';

    window.stockPhotoData.forEach(photo => {
        const img = document.createElement('img');
        img.src = photo.url;
        img.className = 'stock-image-preview';
        img.title = `Diagnosis: ${photo.diagnosis.join(', ')}`;
        img.onclick = () => assignPhotoToCell(id, photo.url, photo.diagnosis);
        grid.appendChild(img);
    });

    STOCK_PHOTOS_MODAL.style.display = 'block';
}

/**
 * Assigns the selected photo/diagnosis to the current cell and updates the grid.
 * @param {string} id - Grid ID
 * @param {string} url - Image URL
 * @param {string[]} diagnosis - Mock CV diagnosis
 */
function assignPhotoToCell(id, url, diagnosis) {
    currentPhotoAssignmentData[id] = { url, diagnosis };

    // Update the visual grid cell
    const cell = document.getElementById(`cell-${id}`);
    cell.innerHTML = ''; // Clear ID text

    const img = document.createElement('img');
    img.src = url;
    img.className = 'grid-cell-img'; // Use CSS to make it cover
    cell.appendChild(img);
    cell.innerHTML += `<div style="position:absolute; bottom:5px; background: rgba(0,0,0,0.7); padding: 3px; border-radius: 5px;">${id}</div>`;

    // Add delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-photo-btn';
    deleteBtn.textContent = 'X';
    deleteBtn.onclick = (e) => {
        e.stopPropagation(); // Prevent cell click/moveRover
        deletePhotoFromCell(id);
    };
    cell.appendChild(deleteBtn);

    // Save the CV Diagnosis directly into the sensor log, if it exists
    const sensorEntry = systemLoggedSensorDataArray.find(d => d.id === id);
    if (sensorEntry) {
        sensorEntry.data.cvDiagnosis = diagnosis;
    } else {
        // If no sensor data, create a minimal entry just for the CV data
        systemLoggedSensorDataArray.push({
            id: id,
            timestamp: new Date().toLocaleString(),
            data: { moisture: NaN, N: NaN, P: NaN, K: NaN, cvDiagnosis: diagnosis },
            analysis: {}
        });
    }

    saveStateToLocalStorage();
    closeStockPhotosModal();
    STATUS_ELEMENT.innerText = `VISUAL DATA LOGGED: Photo assigned to ${id}. CV Diagnosis: ${diagnosis.join(', ')}.`;
}

/**
 * Removes the photo and its data from the specified cell.
 * @param {string} id - Grid ID
 */
function deletePhotoFromCell(id) {
    delete currentPhotoAssignmentData[id];

    // Remove CV diagnosis from sensor data, if it exists
    const sensorEntry = systemLoggedSensorDataArray.find(d => d.id === id);
    if (sensorEntry) {
        delete sensorEntry.data.cvDiagnosis;
    }

    const cell = document.getElementById(`cell-${id}`);
    cell.innerHTML = id; // Restore ID text
    cell.classList.remove('active-cell');

    saveStateToLocalStorage();
    STATUS_ELEMENT.innerText = `DATA CLEANUP: Visual data removed from ${id}.`;
}


/**
 * Placeholder function for starting a mock visual scan (triggers modal).
 */
function startVisualScan() {
    showStockPhotosModal();
}

/* =================================================================
   SECTION 5: DATA FUSION & ANALYSIS (V21.0 - Fixing Bias, Flood, Recommendations)
   ================================================================= */

/**
 * V21.0: Calculates a health score and comprehensive summary from sensor and CV data.
 * The logic is designed to be punitive/fair and strongly link high moisture/low NPK to flood damage.
 * @param {object} sensorData 
 * @param {string[]} cvDiagnosis 
 * @returns {{score: number, color: string, isPostFlood: boolean, sensorSummary: string, cvSummary: string}} Analysis Result
 */
function calculateFusedHealthScoreV21(sensorData) {
    const { moisture, N, P, K, cvDiagnosis = [] } = sensorData;
    let totalPenalty = 0;
    let isPostFloodStatus = false;
    let sensorSummary = 'Sensor data indicates near-optimal conditions for the root zone. ';
    let cvSummary = 'Visual analysis shows no significant distress. Plant is aesthetically healthy. ';

    // --- 1. Moisture & Flood Impact Assessment ---
    let moisturePenalty = 0;
    if (moisture >= 80) {
        moisturePenalty = 40;
        isPostFloodStatus = true;
        sensorSummary = `**CRITICAL WATERLOGGING (${moisture}%)**: Soil is severely saturated. This poses an immediate risk of **Root Zone Hypoxia (Oxygen Deprivation)**, which will inhibit nutrient uptake and cause root death. `;
    } else if (moisture > OPTIMAL_MOISTURE_RANGE[1]) {
        moisturePenalty = 15;
        sensorSummary = `**HIGH MOISTURE (${moisture}%)**: Over-saturation is detected. Maintain drainage to prevent early-stage root stress. `;
    } else if (moisture < OPTIMAL_MOISTURE_RANGE[0]) {
        moisturePenalty = 25;
        sensorSummary = `**SEVERE DROUGHT STRESS (${moisture}%)**: Moisture is critically low. Photosynthesis and turgor pressure are compromised, leading to wilting. `;
    }
    totalPenalty += moisturePenalty;


    // --- 2. NPK Nutrient Leaching/Deficiency Assessment ---
    let npkPenalty = 0;
    
    // N (Nitrogen - Highly Mobile, Leaches easily after flood)
    if (N < N_OPTIMAL[0]) {
        npkPenalty += (N_OPTIMAL[0] - N) * 0.2; // Heavier penalty for N deficiency
        if (N < 50) sensorSummary += `<br>**CRITICAL N DEFICIENCY (${N} ppm)**: Nitrogen is severely depleted. This is the **hallmark sign of nutrient leaching after a flood event**. Immediate action is required. `;
        else sensorSummary += `<br>**N DEFICIENCY (${N} ppm)**: Nitrogen is sub-optimal, leading to widespread chlorosis (yellowing). `;
    } else if (N > N_OPTIMAL[1]) {
        npkPenalty += (N - N_OPTIMAL[1]) * 0.05; // Light penalty for excess
    }

    // P (Phosphorus)
    if (P < P_OPTIMAL[0]) {
        npkPenalty += (P_OPTIMAL[0] - P) * 0.4; // P is less mobile, lower penalty
        if (P < 15) sensorSummary += `<br>**P DEFICIENCY (${P} ppm)**: Low P levels affect energy transfer and cell division (root/flower growth). `;
    }

    // K (Potassium - Mobile, Leaches after flood)
    if (K < K_OPTIMAL[0]) {
        npkPenalty += (K_OPTIMAL[0] - K) * 0.15;
        if (K < 40) sensorSummary += `<br>**SEVERE K DEFICIENCY (${K} ppm)**: Low K impairs water regulation and causes leaf scorch, often exacerbated by waterlogging. `;
    }
    totalPenalty += npkPenalty;


    // --- 3. Computer Vision (CV) Assessment ---
    let cvPenalty = 0;
    if (cvDiagnosis.length > 0 && !cvDiagnosis.includes('Healthy Growth')) {
        cvDiagnosis.forEach(diag => {
            switch (diag) {
                case 'Water Soaked Lesions': 
                    cvPenalty += 30;
                    cvSummary = `**CONFIRMED FLOOD DAMAGE:** Visual evidence of water-soaked lesions and potential fungal infection. This correlates directly with high moisture readings.`;
                    break;
                case 'Severe Yellowing': 
                    cvPenalty += 15;
                    cvSummary = `**VISUAL N DEFICIENCY (Chlorosis):** Widespread leaf yellowing is visible, confirming low Nitrogen readings from the sensor. `;
                    break;
                case 'Wilting': 
                    cvPenalty += 10;
                    cvSummary = `**STRESS CONFIRMED:** Visible wilting indicates severe water imbalance (either drought or root death from waterlogging). `;
                    break;
                case 'Purple Veining':
                    cvPenalty += 12;
                    cvSummary = `**VISUAL P DEFICIENCY:** Purple coloration, especially on undersides, strongly suggests a Phosphorus deficiency. `;
                    break;
                default:
                    cvPenalty += 5;
                    cvSummary = `**MINOR ANOMALY:** Detected leaf curling or mottling. Requires further inspection but suggests nutrient or pest stress. `;
            }
        });
    }
    totalPenalty += cvPenalty;
    
    // --- 4. Final Score & Color Mapping ---
    let finalScore = Math.max(0, 100 - Math.floor(totalPenalty));

    let color;
    if (finalScore >= 80) {
        color = '#3fb950'; // Green: Optimal
    } else if (finalScore >= 50) {
        color = '#e3b341'; // Yellow/Amber: Action Required
    } else {
        color = '#f85149'; // Red: Critical
    }
    
    return { 
        score: finalScore, 
        color: color, 
        isPostFlood: isPostFloodStatus,
        sensorSummary: sensorSummary,
        cvSummary: cvSummary,
        rawSensorData: sensorData,
    };
}

/**
 * V21.0: Generates the three required recommendation parts: Partial (Sensor), Partial (Visual), and Fused.
 * Analysis is made longer and flood-relevant.
 * @param {object} analysisResult - Result from calculateFusedHealthScoreV21
 * @returns {{partialSensorRec: string, partialCVRec: string, fusedRec: string, colorClass: string}}
 */
function getRecommendationV21(analysisResult) {
    const { score, isPostFlood, sensorSummary, cvSummary, rawSensorData } = analysisResult;
    
    const N = rawSensorData.N;
    const moisture = rawSensorData.moisture;

    // 1. Partial Recommendation (Sensor Data)
    let partialSensorRec = `#### PARTIAL RECOMMENDATION (SENSOR DATA)\n`;
    partialSensorRec += `<p>${sensorSummary}</p>`;
    partialSensorRec += `**Moisture Status**: ${moisture}% | **Nitrogen Status**: ${N} ppm.`;
    
    // 2. Partial Recommendation (Computer Vision)
    let partialCVRec = `#### PARTIAL RECOMMENDATION (VISUAL DATA)\n`;
    partialCVRec += `<p>${cvSummary}</p>`;
    
    // 3. Fused Recommendation (Final Action Plan)
    let fusedRec = ``;
    let colorClass = score >= 80 ? 'rec-optimal' : (score >= 50 ? 'rec-action' : 'rec-critical');
    
    fusedRec += `#### FUSED ACTION PLAN (Overall Health Score: ${score}%)\n`;
    fusedRec += `***Fusion Assessment***: The combined sensor and visual data indicate a health score of ${score}%. This synthesis provides the following comprehensive action plan:\n\n`;

    if (isPostFlood) {
        // Severe Post-Flood Scenario
        fusedRec += `<div class="assessment-section" style="background-color: #f08047; color: #0d1117; padding: 15px; border-radius: 8px;">
            <h3>ðŸš¨ CRITICAL FLOOD RECOVERY PROTOCOL ACTIVE</h3>
            <p><strong>Primary Goal: AERATION & RE-ESTABLISHMENT.</strong> The high soil saturation **(${moisture}%)** combined with the severe Nitrogen depletion **(${N} ppm)** is a classic post-flood crisis. The plant is suffocating and starving simultaneously. </p>
            <p><strong>Action:</strong> 1. **Immediate Drainage/Aeration**: Utilize deep-tilling or air-injection to reduce the root zone hypoxia. 2. **Hold Fertilization**: Do not apply solid fertilizer until moisture drops below 70%. 3. **Foliar Spray**: Apply a fast-acting foliar Nitrogen source (e.g., Urea) to bypass the compromised roots for temporary support. </p>
        </div>`;
        colorClass = 'rec-critical'; 
    } else if (score >= 80) {
        fusedRec += "- **Assessment**: Plant is exhibiting **High Resilience** with optimal moisture/nutrient balance. Data confirms robust health and stability.\n";
        fusedRec += "- **Action**: Continue routine monitoring. No immediate intervention is required. This zone is ideal for long-term health trials or seed harvesting.";
    } else if (score >= 50) {
        fusedRec += "- **Assessment**: Moderate **Stress Indicators** detected. The system is showing sub-optimal but manageable conditions. Stress is primarily due to nutrient imbalance or minor water deficit.\n";
        fusedRec += "- **Action**: Implement **Targeted Minor Intervention**. Based on the highest deficiency (e.g., if P is lowest, apply P-rich fertilizer). Review the water schedule. Re-scan in 48-72 hours to confirm correction.";
    } else {
        fusedRec += "- **Assessment**: **CRITICAL FAILURE RISK**. Multiple severe stressors identified (e.g., severe drought, extreme deficiency, or confirmed disease/pest infestation).\n";
        fusedRec += "- **Action**: **ISOLATE ZONE**. Perform a detailed root/stem inspection. Apply emergency corrective measure (e.g., high-concentration nutrient foliar spray or immediate controlled deep watering) and consider fungicide if water lesions are visible.";
    }

    return { 
        partialSensorRec: `<div class="partial-analysis">${partialSensorRec.replace(/\n/g, '<br>')}</div>`, 
        partialCVRec: `<div class="partial-analysis">${partialCVRec.replace(/\n/g, '<br>')}</div>`, 
        fusedRec: `<div class="${colorClass}">${fusedRec.replace(/\n/g, '<br>')}</div>`, 
        colorClass 
    };
}


/**
 * Renders the comprehensive analysis cards for all scanned grid cells.
 */
function renderAnalysisCards() {
    ANALYSIS_GRID.innerHTML = '';
    
    const cellsToAnalyze = systemLoggedSensorDataArray.filter(d => d.data && !isNaN(d.data.moisture));
    
    if (cellsToAnalyze.length === 0) {
        renderNoDataCards(); // Ensure the default 'No Data' view is available
        return;
    }

    // 1. Run Analysis on all available data
    cellsToAnalyze.forEach(entry => {
        const analysisResult = calculateFusedHealthScoreV21(entry.data);
        entry.analysis = analysisResult; // Store the result
        systemAnalysisResultsMap[entry.id] = analysisResult; // Update global map for visualization
    });

    // 2. Render Cards
    cellsToAnalyze.sort((a, b) => b.analysis.score - a.analysis.score).forEach(entry => {
        const recommendations = getRecommendationV21(entry.analysis);
        const card = document.createElement('div');
        card.className = 'analysis-card';

        let html = `<div class="plant-id-label">Zone ${entry.id} - ${entry.analysis.score}% Health</div>`;
        html += `<p style="color: #f08047; font-weight: bold; margin-bottom: 20px;">LAST SCANNED: ${entry.timestamp}</p>`;

        // A. Partial Sensor Recommendation
        html += recommendations.partialSensorRec;

        // B. Partial Visual Recommendation
        html += recommendations.partialCVRec;
        
        // C. Fused Recommendation (Longer Analysis)
        html += recommendations.fusedRec;
        
        card.innerHTML = html;
        ANALYSIS_GRID.appendChild(card);
    });

    // 3. Update Visualizations
    updateMapVisualization();
    draw3DMap();
}

/**
 * Placeholder for the scenario when no sensor data has been collected.
 */
function renderNoDataCards() {
    ANALYSIS_GRID.innerHTML = `
        <div class="analysis-card" style="grid-column: 1 / -1;">
            <div class="plant-id-label">SYSTEM MESSAGE</div>
            <div class="assessment-section">
                <h3>No Fusion Data Available</h3>
                <p>Please collect Sensor Data or assign Visual Data to grid cells to initiate the Fusion Analysis cycle.</p>
                <div class="rec-no-data">STATUS: AWAITING FIELD INPUT</div>
            </div>
        </div>
    `;
    // Ensure all cells in systemAnalysisResultsMap are reset to 'no data' color
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const id = toGridId(r, c);
            systemAnalysisResultsMap[id] = { score: 0, color: '#30363d' };
        }
    }
}

/**
 * Triggers the entire analysis pipeline.
 */
function triggerComprehensiveAnalysisCycle() {
    renderAnalysisCards();
    STATUS_ELEMENT.innerText = "ANALYSIS COMPLETE: Comprehensive Data Fusion cycle finished. Results updated in Analysis Panel and Visualizations (V21.0).";
}

/* =================================================================
   SECTION 6: VISUALIZATION RENDERING (V21.0 - Fixing 2D & 3D)
   ================================================================= */

/**
 * V21.0 FIX: Renders the 2D map with colored circles reflecting health scores.
 */
function updateMapVisualization() {
    const MAP_SIZE = 480;
    MAP_CANVAS.width = MAP_SIZE;
    MAP_CANVAS.height = MAP_SIZE;
    const CELL_SIZE = MAP_SIZE / GRID_SIZE;
    
    MAP_CONTEXT.clearRect(0, 0, MAP_CANVAS.width, MAP_CANVAS.height);

    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const id = toGridId(r, c);
            const x = c * CELL_SIZE;
            const y = r * CELL_SIZE;
            const w = CELL_SIZE;
            const h = CELL_SIZE;

            // 1. Draw Grid Lines
            MAP_CONTEXT.strokeStyle = '#30363d';
            MAP_CONTEXT.lineWidth = 1;
            MAP_CONTEXT.strokeRect(x, y, w, h);

            // 2. Get Analysis Result for Coloring
            const result = systemAnalysisResultsMap[id] || { score: 0, color: '#30363d' };
            
            // 3. Draw Colored Status Circle (CRITICAL V21.0 FIX)
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            const radius = Math.min(w, h) * 0.35; // 35% of the cell size for clear visibility

            if (result.score > 0) { // Only draw circle if data was collected/analyzed
                MAP_CONTEXT.beginPath();
                MAP_CONTEXT.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                MAP_CONTEXT.fillStyle = result.color; // Use the calculated health color
                MAP_CONTEXT.fill(); // Fill the circle
                
                // Add border to the circle
                MAP_CONTEXT.strokeStyle = '#c9d1d9';
                MAP_CONTEXT.lineWidth = 2;
                MAP_CONTEXT.stroke();
                
                MAP_CONTEXT.closePath();
            }

            // 4. Draw Grid ID Text
            MAP_CONTEXT.fillStyle = '#c9d1d9';
            MAP_CONTEXT.font = 'bold 16px Consolas';
            MAP_CONTEXT.textAlign = 'center';
            MAP_CONTEXT.textBaseline = 'middle';
            MAP_CONTEXT.fillText(id, centerX, centerY);
        }
    }
}

/**
 * Initializes the Three.js scene.
 */
function initThreeD() {
    const container = document.getElementById('threeDContainer');
    const width = container.clientWidth;
    const height = container.clientHeight;

    SCENE = new THREE.Scene();
    SCENE.background = new THREE.Color(0x1a1a2e); // Deep space background

    CAMERA = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    CAMERA.position.set(GRID_SIZE * 0.75, 5, GRID_SIZE * 0.75);

    RENDERER = new THREE.WebGLRenderer({ antialias: true });
    RENDERER.setSize(width, height);
    container.appendChild(RENDERER.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 5); // soft white light
    SCENE.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
    directionalLight.position.set(GRID_SIZE * 2, GRID_SIZE * 2, GRID_SIZE * 2);
    SCENE.add(directionalLight);

    // Controls
    CONTROLS = new THREE.OrbitControls(CAMERA, RENDERER.domElement);
    CONTROLS.enableDamping = true;
    CONTROLS.dampingFactor = 0.05;
    CONTROLS.screenSpacePanning = false;
    CONTROLS.minDistance = 3;
    CONTROLS.maxDistance = 20;

    // Ground Plane
    const geometry = new THREE.PlaneGeometry(GRID_SIZE * 1.2, GRID_SIZE * 1.2);
    const material = new THREE.MeshPhongMaterial({ color: 0x228b22, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = Math.PI / 2;
    plane.position.y = 0;
    SCENE.add(plane);

    // Grid lines for reference
    const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x58a6ff, 0x30363d);
    gridHelper.position.y = 0.01; // Lift slightly above plane
    SCENE.add(gridHelper);

    // Start animation loop
    animate();
}

/**
 * Animation loop for Three.js.
 */
function animate() {
    requestAnimationFrame(animate);
    CONTROLS.update();
    RENDERER.render(SCENE, CAMERA);
}

/**
 * Creates a 3D model of a plant (simplified cylinder and cone).
 * @param {string} color - Hex color string for the leaves.
 * @param {number} healthScore - Score (0-100) to determine plant height/scale.
 * @returns {THREE.Group} A group containing the plant mesh.
 */
function drawPlantV21(color, healthScore) {
    const PLANT_GROUP = new THREE.Group();
    const heightScale = 0.5 + (healthScore / 100) * 1.5; // Scale from 0.5 to 2.0
    
    // Stem
    const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, heightScale, 32);
    const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x3fb950 }); // Fixed green stem
    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
    stem.position.y = heightScale / 2;
    PLANT_GROUP.add(stem);

    // Leaves (Cone for simplified crown)
    const leafGeometry = new THREE.ConeGeometry(0.4, heightScale * 0.8, 16);
    // V21.0 FIX: The color derived from the score is applied here, ensuring the 3D changes color.
    const plantColor = new THREE.Color(color);
    const leafMaterial = new THREE.MeshPhongMaterial({ color: plantColor, side: THREE.DoubleSide });
    const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
    leaves.position.y = heightScale * 1.1; // Place cone on top of stem
    PLANT_GROUP.add(leaves);

    return PLANT_GROUP;
}

/**
 * Draws all plants onto the 3D map based on the analysis results.
 */
function draw3DMap() {
    // 1. Clear existing plants from the scene
    SCENE.children = SCENE.children.filter(child => !child.userData.isPlant);

    // 2. Iterate through all grid cells (A1-D4)
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const id = toGridId(r, c);
            const result = systemAnalysisResultsMap[id];

            if (result && result.score > 0) {
                const plant = drawPlantV21(result.color, result.score);
                
                // Position the plant in the grid (coordinates are centered on the plane)
                // Grid is 4x4, centered at (0,0). Coordinates are -1.5 to 1.5.
                // c/r are 0-3. Mapping: 0 -> -1.5, 3 -> 1.5.
                plant.position.x = c - (GRID_SIZE / 2) + 0.5;
                plant.position.z = r - (GRID_SIZE / 2) + 0.5;
                plant.userData.isPlant = true; // Tag for easy removal later

                SCENE.add(plant);
            }
        }
    }
}


/* =================================================================
   SECTION 7: SYSTEM MANAGEMENT (HISTORY & STORAGE)
   ================================================================= */

/**
 * Resets all logged data and visualizations.
 * @param {boolean} clearStorage - Whether to clear localStorage as well.
 */
function resetSensorAndMapData(clearStorage) {
    systemLoggedSensorDataArray = [];
    currentPhotoAssignmentData = {};
    
    updateSensorDisplay(null);
    renderNoDataCards(); // Clear analysis panel
    updateMapVisualization(); // Clear 2D map
    draw3DMap(); // Clear 3D map

    if (clearStorage) {
        localStorage.removeItem('scoutRoverState');
        STATUS_ELEMENT.innerText = "SYSTEM RESET: All data and history cleared. Ready for new mission.";
    } else {
        STATUS_ELEMENT.innerText = "SYSTEM BOOT: Initialized state from memory.";
    }

    // Re-generate the grid to ensure cells are clean
    generatePhotoGrid();
    moveRover(null); // Move to A1
}

/**
 * Saves the current state to localStorage.
 */
function saveStateToLocalStorage() {
    const state = {
        loggedData: systemLoggedSensorDataArray,
        photoData: currentPhotoAssignmentData
    };
    localStorage.setItem('scoutRoverState', JSON.stringify(state));
}

/**
 * Loads the state from localStorage on startup.
 */
function loadStateFromLocalStorage() {
    const stateJson = localStorage.getItem('scoutRoverState');
    if (stateJson) {
        const state = JSON.parse(stateJson);
        systemLoggedSensorDataArray = state.loggedData || [];
        currentPhotoAssignmentData = state.photoData || {};
        
        // Restore photos to grid
        Object.keys(currentPhotoAssignmentData).forEach(id => {
            const data = currentPhotoAssignmentData[id];
            assignPhotoToCell(id, data.url, data.diagnosis); // Re-run assignment logic without closing modal
        });
        return true;
    }
    return false;
}

/**
 * Shows the history modal populated with logged sensor data.
 */
function showHistoryModal() {
    const historyList = document.getElementById('historyList');
    historyList.innerHTML = '';
    
    if (systemLoggedSensorDataArray.length === 0) {
        historyList.innerHTML = '<p>No historical sensor or visual data logged yet.</p>';
    } else {
        systemLoggedSensorDataArray.forEach(d => {
            const item = document.createElement('div');
            item.className = 'trial-item';
            item.innerHTML = `
                <div style="font-weight: bold; color: #79c0ff;">Zone ${d.id} - ${d.timestamp}</div>
                <div><strong>Moisture:</strong> ${d.data.moisture}% | <strong>N:</strong> ${d.data.N} ppm | <strong>P:</strong> ${d.data.P} ppm | <strong>K:</strong> ${d.data.K} ppm</div>
                <div><strong>CV Diagnosis:</strong> ${d.data.cvDiagnosis ? d.data.cvDiagnosis.join(', ') : 'N/A'}</div>
                <div style="margin-top: 5px; color: ${d.analysis.color || '#c9d1d9'}; font-weight: bold;">Fused Health Score: ${d.analysis.score || 'N/A'}%</div>
            `;
            historyList.appendChild(item);
        });
    }

    HISTORY_MODAL.style.display = 'block';
}

/**
 * Closes the history modal.
 */
function closeHistoryModal() {
    HISTORY_MODAL.style.display = 'none';
}

/**
 * Closes the stock photos modal.
 */
function closeStockPhotosModal() {
    STOCK_PHOTOS_MODAL.style.display = 'none';
}

/* =================================================================
   SECTION 8: INITIALIZATION
   ================================================================= */

// Global window functions for the OpenCV library callback
window.onOpenCvReady = function() {
    openCvLibraryIsReady = true;
    STATUS_ELEMENT.innerText = "System Status: OpenCV.js Library Initialized. Rover Control System Fully Operational (V21.0).";
}

function onDocumentReady() {
    populateStockPhotos(); 
    generatePhotoGrid();
    initThreeD();
    
    const dataLoaded = loadStateFromLocalStorage();
    
    if (dataLoaded && systemLoggedSensorDataArray.length > 0) {
        // Load state and trigger analysis to populate all views
        triggerComprehensiveAnalysisCycle(); 
    } else {
        // Ensure the UI is populated even with no data
        renderNoDataCards(); 
        updateMapVisualization(); 
        draw3DMap(); 
    }
    
    STATUS_ELEMENT.innerText = "SYSTEM BOOT: DOM Ready. Awaiting OpenCV.js initialization for full CV capability.";
}
window.onload = onDocumentReady;

</script>

</body>
</html>
