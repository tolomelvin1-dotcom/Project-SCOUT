<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>S.C.O.U.T. Rover Mapping & Control (Data-Driven 3D)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<style>
/* BASE STYLING (Dark Theme) */
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #1e1e1e; color: #d4d4d4; }
.container {
max-width: 1700px;
margin: auto;
background: #2d2d30;
padding: 25px;
border-radius: 10px;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
display: flex;
flex-wrap: wrap; /* Ensure panels wrap */
}
/* LAYOUT PANELS - Adjusted to ensure Plant Analysis is always visible */
.controls-panel { flex: 1; min-width: 350px; padding-right: 20px; }
.map-panel { flex: 1; min-width: 450px; }
.photo-panel { flex: 1; min-width: 450px; padding-left: 20px; border-left: 1px solid #3c3c3c; }
.map-3d-panel { flex: 1; min-width: 450px; margin-top: 20px; }
.plant-analysis-panel {
flex-basis: 100%; /* Make this panel take the full width */
margin-top: 30px;
padding-top: 20px;
border-top: 1px solid #3c3c3c;
}
/* TYPOGRAPHY & HEADERS */
h1 { color: #569cd6; border-bottom: 3px solid #3c3c3c; padding-bottom: 10px; }
h2 { color: #4ec9b0; margin-top: 20px; }
h3 { color: #c8c8c8; margin-top: 10px; }
#status { font-weight: bold; color: #ffcc00; }
/* BUTTONS */
button { padding: 10px 15px; margin: 8px 5px; cursor: pointer; border: none; border-radius: 6px; font-weight: bold; transition: background-color 0.2s; }
.move-controls button { background-color: #569cd6; color: white; }
.arm-controls button { background-color: #6a9955; color: white; }
.camera-control button { background-color: #ce4257; color: white; }
.history-controls button { background-color: #ff9900; color: white; }
/* DATA DISPLAY */
.data-display { margin-top: 20px; padding: 15px; border: 1px solid #3c3c3c; border-radius: 6px; background-color: #252526; }
.data-row strong { display: inline-block; width: 140px; color: #9cdcfe; }
/* CANVAS MAP (2D) */
#roverMap { border: 3px solid #6a9955; background-color: #3d3d3d; display: block; margin: 20px auto 0; }
/* 3D MAP CANVAS */
#threeDContainer {
width: 450px;
height: 450px;
border: 3px solid #569cd6;
background-color: #1a1a1a;
margin: 20px auto 0;
display: block;
}
/* 4x4 PHOTO GRID STYLES */
#photoGrid {
display: grid;
grid-template-columns: repeat(4, 1fr);
grid-template-rows: repeat(4, 1fr);
gap: 5px;
border: 2px solid #569cd6;
max-width: 450px;
margin: 20px auto;
aspect-ratio: 1 / 1;
background-color: #252526;
}
/* Stock Image Grid (Now up to 50) */
#stockImageGrid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
gap: 10px;
border: none;
max-width: 100%;
margin: 0;
}
.grid-cell {
background-color: #3d3d3d;
border: 1px solid #4ec9b0;
position: relative;
display: flex;
justify-content: center;
align-items: center;
cursor: pointer;
overflow: hidden;
transition: background-color 0.1s;
}
/* Delete Photo Button Styles */
.delete-photo-btn {
position: absolute;
bottom: 2px;
right: 2px;
background-color: rgba(220, 53, 69, 0.8);
color: white;
border: none;
border-radius: 3px;
padding: 2px 5px;
font-size: 10px;
cursor: pointer;
z-index: 20;
line-height: 1;
display: none;
}
.grid-cell:has(.cell-photo) .delete-photo-btn {
display: block;
}
/* NEW: Plant Analysis Grid Styles */
#plantAnalysisGrid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
gap: 20px;
margin-top: 15px;
}
.analysis-card {
padding: 15px;
border-radius: 8px;
background-color: #3e3e42;
box-shadow: 0 2px 5px rgba(0,0,0,0.3);
transition: box-shadow 0.2s;
}
.plant-id-label {
font-size: 1.4em;
font-weight: bold;
color: #ffd700;
border-bottom: 2px solid #555;
padding-bottom: 5px;
margin-bottom: 10px;
}
.status-good { color: #9cdcfe; }
/* Recommendation coloring */
.rec-optimal, .rec-action, .rec-critical {
padding: 5px;
border-radius: 4px;
display: inline-block;
font-weight: bold;
white-space: normal;
word-break: break-word;
width: 100%;
box-sizing: border-box;
}
.rec-optimal { background-color: #28a745; color: white; }
.rec-action { background-color: #ffc101; color: black; }
.rec-critical { background-color: #dc3545; color: white; }
/* MODAL STYLES */
.modal {
display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7);
}
.modal-content {
background-color: #2d2d30; margin: 5% auto; padding: 20px; border: 1px solid #3c3c3c; width: 90%; max-width: 1200px; border-radius: 10px;
}
.close-btn {
color: #aaa; float: right; font-size: 28px; font-weight: bold;
}
.close-btn:hover, .close-btn:focus {
color: #fff; text-decoration: none; cursor: pointer;
}
.trial-item {
padding: 10px; margin-bottom: 5px; background-color: #252526; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;
}
.trial-item:hover { background-color: #404040; }
</style>
</head>
<body>
<div class="container">
<div class="controls-panel">
<h1>S.C.O.U.T. Rover Control</h1>
<p>System Status: <span id="status">Connecting...</span></p>
<div class="data-display history-controls">
<h2>Trial Management   üíæ  </h2>
<div class="data-row"><strong>Current Trial:</strong> <span id="currentTrialNumber">1</span></div>
<p>
<button onclick="saveCurrentTrial()">  üíæ   Save Trial Data</button>
<button onclick="openHistoryModal()">  üìÖ   View History</button>
</p>
<p><small>Saved trials are stored in your browser's local storage.</small></p>
</div>
<div class="move-controls">
<h2>Rover Movement</h2>
<button onclick="sendCommand('forward')">Forward (‚Üë)</button>
<button onclick="sendCommand('stop')">  üõë   STOP</button>
<button onclick="sendCommand('backward')">Backward (‚Üì)</button><br>
<button onclick="sendCommand('left')">Left (‚Üê)</button>
<button onclick="sendCommand('right')">Right (‚Üí)</button>
</div>
<hr style="border-top: 1px solid #3c3c3c;">
<div class="arm-controls">
<h2>Data Acquisition</h2>
<button onclick="sendCommand('probe')">  üî¨   Probe Soil (Arm Down)</button>
<button onclick="sendCommand('read_sensors')">  üíß   Read Soil Data</button>
<button onclick="sendCommand('read_nav')">  üß≠   Get GPS/Heading</button>
</div>
<hr style="border-top: 1px solid #3c3c3c;">
<div class="data-display">
<h2>Live Sensor Data</h2>
<h3>Navigation Data</h3>
<div class="data-row"><strong>Latitude:</strong> <span id="latitudeData">N/A</span></div>
<div class="data-row"><strong>Longitude:</strong> <span id="longitudeData">N/A</span></div>
<div class="data-row"><strong>GPS Fix:</strong> <span id="gpsFix">No Fix</span></div>
<div class="data-row"><strong>Heading:</strong> <span id="headingData">N/A</span></div>
<h3>Soil Data</h3>
<div class="data-row"><strong>Moisture:</strong> <span id="moistureData">N/A</span></div>
<div class="data-row"><strong>NPK (N, P, K):</strong> <span id="npkData">N/A</span></div>
</div>
</div>
<div class="map-panel">
<h2>2D Field Map ($\mathbf{4\text{m} \times 4\text{m}}$ Grid)</h2>
<canvas id="roverMap" width="450" height="450"></canvas>
<p>Map Key: $\text{Grid} = 1 \text{m} \times 1 \text{m}$. $\text{Circles} = \text{Health}$. $\text{Triangle} = \text{Rover}$.</p>
<button onclick="clearMapData()">  üóë  Ô∏è Clear Map Data</button>
</div>
<div class="map-3d-panel">
<h2>3D Soil Metric Visualization   üìä  </h2>
<div id="threeDContainer"></div>
<div class="three-d-controls">
<p>Bar Height = Soil Moisture %. Bar Color = Plant Health (Green/Yellow/Red).</p>
</div>
</div>
<div class="photo-panel">
<div class="camera-control">
<h2>Image Capture & Gallery</h2>
<button onclick="sendCommand('capture')">  üì∏   Take Photo (to Dell Wyse)</button>
<button onclick="openStockImageModal()">  üñº  Ô∏è View/Load Stock Photos</button>
<p>Last photo status: <span id="lastPhotoStatus">N/A</span>. Sent to Dell Wyse server at <span id="server-ip">192.168.X.X:5000</span>.</p>
</div>
<hr style="border-top: 1px solid #3c3c3c;">
<h2>Plant Zone Photo Assignments (Zones 1-16)</h2>
<p>Click a zone to upload a photo. Photos assigned here are used for the AI analysis.</p>
<div id="photoGrid">
</div>
<input type="file" id="fileInput" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
</div>
<div class="plant-analysis-panel">
<h2>Plant-Specific CV Analysis (16 Zones)  üî¨ </h2>
<p>This grid shows the fused analysis of **Leaf Photo (OpenCV.js CV)** + **Local Soil Data ($\text{NPK}$/Moisture)** for all plant zones.</p>
<div id="plantAnalysisGrid">
</div>
</div>
</div>
<div id="historyModal" class="modal" onclick="if(event.target.id === 'historyModal') closeHistoryModal()">
<div class="modal-content">
<span class="close-btn" onclick="closeHistoryModal()">&times;</span>
<h2>Saved Trial History</h2>
<div id="trialHistoryList">
</div>
<hr style="border-top: 1px solid #3c3c3c; margin-top: 15px;">
<button onclick="clearAllHistory()" style="background-color: #dc3545;">  üö®   Clear All Saved Trials</button>
</div>
</div>
<div id="stockImageModal" class="modal" onclick="if(event.target.id === 'stockImageModal') closeStockImageModal()">
<div class="modal-content">
<span class="close-btn" onclick="closeStockImageModal()">&times;</span>
<h2>Stock Photo Gallery (50 Pre-Diagnosed Leaves)</h2>
<p>Click on a stock photo to assign it to your currently selected plant zone.
Note: Stock photos are mocked to show various disease states for demo purposes.</p>
<div id="stockImageGrid">
</div>
</div>
</div>
<script>
// JAVASCRIPT LOGIC
// !!! CONFIGURE YOUR IPs HERE !!!
const ESP32_IP = '192.168.1.50';
const DELL_WYSE_IP = 'http://192.168.X.X:5000';
const ESP32_URL_BASE = `http://${ESP32_IP}`;
const STATUS_ELEMENT = document.getElementById('status');
const LAST_PHOTO_STATUS = document.getElementById('lastPhotoStatus');
document.getElementById('server-ip').innerText = DELL_WYSE_IP.replace('http://', '');

// --- OPENCV INITIALIZATION ---
let cvReady = false;
function onOpenCvReady() {
    cvReady = true;
    STATUS_ELEMENT.innerText = "System Status: OpenCV.js Ready. Rover Control System Online.";
    // Re-run analysis if data exists
    fetchAIResults();
}

// --- GLOBAL CONSTANTS ---
const FIELD_SIZE = 4;
const MAP_CANVAS = document.getElementById('roverMap');
const CTX = MAP_CANVAS.getContext('2d');
const MAP_SIZE = 450;
const PIXELS_PER_METER = MAP_SIZE / FIELD_SIZE;
const MAX_MOISTURE = 100;
// Plant locations in meters (16 zones)
const PLANT_LOCATIONS_M = [];
for(let r=0; r<FIELD_SIZE; r++) for(let c=0; c<FIELD_SIZE; c++) PLANT_LOCATIONS_M.push({x: c + 0.5, y: r + 0.5, id: (r * FIELD_SIZE) + c + 1});

// Global Data Structures
let loggedData = [];
let photoData = {}; // Stores {zoneId: base64Image} - ASSIGNED PHOTOS
let stockPhotoData = {}; // Stores {stockId: base64Image} - GALLERY OF STOCK PHOTOS
let selectedZone = 0;
let trialHistory = JSON.parse(localStorage.getItem('trialHistory') || '[]');
let currentTrialNumber = trialHistory.length + 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
let currentRoverData = {
latitude: 'N/A',
longitude: 'N/A',
heading: 0,
x_m: 2.0,
y_m: 2.0
};

// --- SIMULATED LIBRARY: TOMATO DIAGNOSTIC RULES (SCIENTIFICALLY PRIORITIZED) ---
const TOMATO_DIAGNOSTIC_LIBRARY = {
// Disease Tiers (Prioritized by Severity)
DISEASE_TIERS: [
{ name: "Mottling/Mosaic Pattern (Viral)", severity: 95, probability: 0.10, class: 'rec-critical', recommendation: "ISOLATION REQUIRED: Strong indicator of Tobacco Mosaic Virus (TMV) or similar. Incurable. Remove plant immediately to prevent field-wide contamination."
},
{ name: "Dark Spots & Lesions (Fungal/Bact)", severity: 85, probability: 0.15, class: 'rec-critical', recommendation: "FUNGICIDE/BACTERICIDE: Likely Early Blight or Bacterial Spot. Apply broad-spectrum fungicide and improve air circulation/reduce leaf wetness."
},
{ name: "Leaf Curl & Wilting (Stress/Viral)", severity: 75, probability: 0.10, class: 'rec-critical', recommendation: "WILTING: Could be severe water stress, root rot, or Tomato Yellow Leaf Curl Virus (TYLCV). Check moisture urgently. If moisture is good, isolate for potential virus."
},
{ name: "General Yellowing (Chlorosis)", severity: 50, probability: 0.25, class: 'rec-action', recommendation: "GENERAL YELLOWING: A common sign of nutrient deficiency (N, Mg, Fe) or pH imbalance. Check NPK data for confirmation."
},
{ name: "Healthy, Deep Green", severity: 0, probability: 0.40, class: 'rec-optimal', recommendation: "OPTIMAL: No visual symptoms detected. Continue regular monitoring."
}
],
// NPK Guidelines for Scoring (used in analyzePlant)
NPK_GUIDELINES: {
moisture: { ideal_min: 40, ideal_max: 60, low_crit: 25, high_crit: 75, penalty_minor: 10, penalty_major: 30, low_rec: "deep watering", high_rec: "review soil drainage/stop irrigation" },
N: { ideal_min: 60, ideal_max: 100, low_crit: 30, high_crit: 150, penalty_minor: 15, penalty_major: 40, low_rec: "high-Nitrogen (N) liquid feed", high_rec: "stop all N-fertilizer, flush soil" },
P: { ideal_min: 50, ideal_max: 80, low_crit: 20, high_crit: 120, penalty_minor: 10, penalty_major: 25, low_rec: "Phosphorus (P) booster for root development", high_rec: "check fertilizer blend for P excess" },
K: { ideal_min: 70, ideal_max: 120, low_crit: 40, high_crit: 180, penalty_minor: 10, penalty_major: 25, low_rec: "Potassium (K) to boost resistance/fruit set", high_rec: "check for K salt toxicity" },
}
};

// --- 3D RENDERING SETUP (THREE.JS) ---
let scene, camera, renderer, rover3D, controls;
let dataCubes = {};
function initThreeD() {
const container = document.getElementById('threeDContainer');
const width = container.clientWidth;
const height = container.clientHeight;
scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a1a);
camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
camera.position.set(2, 6, 2);
camera.lookAt(2, 0, 2);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
container.appendChild(renderer.domElement);
controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.screenSpacePanning = false;
controls.minDistance = 1;
controls.maxDistance = 10;
controls.maxPolarAngle = Math.PI / 2.2;
const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x444444);
gridHelper.position.set(FIELD_SIZE / 2, 0, FIELD_SIZE / 2);
scene.add(gridHelper);
const roverGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.2);
const roverMaterial = new THREE.MeshPhongMaterial({ color: 0x569cd6 });
rover3D = new THREE.Mesh(roverGeometry, roverMaterial);
rover3D.position.set(currentRoverData.x_m, 0.05, currentRoverData.y_m);
scene.add(rover3D);
const ambientLight = new THREE.AmbientLight(0x404040, 2);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(5, 10, 5);
scene.add(directionalLight);
animate();
}
function animate() {
requestAnimationFrame(animate);
if(controls) controls.update();
renderer.render(scene, camera);
}
function updateRover3DPosition() {
if (rover3D) {
rover3D.position.set(
parseFloat(currentRoverData.x_m),
0.05,
parseFloat(currentRoverData.y_m)
);
rover3D.rotation.y = -(currentRoverData.heading - 90) * (Math.PI / 180);
}
}
function clear3DDataCubes() {
Object.values(dataCubes).forEach(cube => {
scene.remove(cube);
cube.geometry.dispose();
cube.material.dispose();
});
dataCubes = {};
}
function getHealthColorHex(status) {
switch (status) {
case 'Good': return 0x28a745;
case 'Caution': return 0xffc107;
case 'Bad': return 0xdc3545;
default: return 0x5a5a5a;
}
}
function draw3DMap() {
clear3DDataCubes();
loggedData.forEach((data, index) => {
const { x_m, y_m, moisture, healthStatus } = data;
const cubeWidth = 0.5;
const cubeDepth = 0.5;
const cubeHeight = Math.max(0.01, moisture / MAX_MOISTURE);
const colorHex = getHealthColorHex(healthStatus);
const geometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
const material = new THREE.MeshPhongMaterial({
color: colorHex,
opacity: 0.8,
transparent: true
});
const cube = new THREE.Mesh(geometry, material);
cube.position.set(
x_m,
cubeHeight / 2,
y_m
);
cube.name = `data-cube-${index}`;
dataCubes[index] = cube;
scene.add(cube);
});
updateRover3DPosition();
}

// ------------------------------------
// --- PHOTO GRID & MODAL FUNCTIONS ---
// ------------------------------------
const MAX_STOCK_PHOTOS = 50; // New constant for stock photo count
function populateStockPhotos() {
if (Object.keys(stockPhotoData).length === MAX_STOCK_PHOTOS) return;
const diseaseList = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS;
for (let i = 1; i <= MAX_STOCK_PHOTOS; i++) {
// Use a deterministic assignment for stock photos to show specific diseases
const diseaseIndex = i % diseaseList.length;
const base64 = `data:image/svg+xml;base64,mocked_stock_photo_hash_${i}_diag:${diseaseList[diseaseIndex].name.replace(/\s/g, '_')}`;
stockPhotoData[i] = base64;
}
}
function openStockImageModal() {
populateStockPhotos();
renderStockImageGrid();
document.getElementById('stockImageModal').style.display = "block";

if (selectedZone === 0) {
STATUS_ELEMENT.innerText = "Select a stock photo, then click a zone (1-16) in the main photo grid to assign it.";
}
}
function closeStockImageModal() {
document.getElementById('stockImageModal').style.display = "none";
}

// --- NEW CLASSICAL CV ANALYSIS FUNCTION (ASYNC) ---
function getCVAnalysis(base64Image) {
    if (!cvReady) {
        return Promise.resolve({ score: 5, diagnosis: "CV Library Not Ready", prediction: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Mottling")) });
    }
    
    return new Promise((resolve) => {
        const img = document.createElement('img');
        
        img.onload = function() {
            try {
                // Load image into OpenCV Mat
                const src = cv.imread(img);
                if (src.cols === 0 || src.rows === 0) {
                    src.delete();
                    resolve({ score: 10, diagnosis: "CV Error: Failed to read image data (0 size).", prediction: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Mottling")) });
                    return;
                }

                // 2. Convert to HSV
                const hsv = new cv.Mat();
                cv.cvtColor(src, hsv, cv.COLOR_RGBA2HSV); // Use RGBA2HSV for image data
        
                // 3. Define Masks (H, S, V)
                // Green (Healthy) Range (H: 30-90, S: 40-255, V: 40-255)
                const green_low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [30, 40, 40, 0]);
                const green_high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [90, 255, 255, 255]);
                const green_mask = new cv.Mat();
                cv.inRange(hsv, green_low, green_high, green_mask);

                // Yellow/Brown (Unhealthy) Range (H: 15-30, S: 60-255, V: 60-255)
                const yellow_low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [15, 60, 60, 0]);
                const yellow_high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [30, 255, 255, 255]);
                const yellow_mask = new cv.Mat();
                cv.inRange(hsv, yellow_low, yellow_high, yellow_mask);
                
                green_low.delete(); green_high.delete();
                yellow_low.delete(); yellow_high.delete();

                // 4. Calculate pixel counts
                const greenPixels = cv.countNonZero(green_mask);
                const unhealthyPixels = cv.countNonZero(yellow_mask);
                const totalAnalyzedPixels = greenPixels + unhealthyPixels;

                // Clean up Mats
                src.delete(); hsv.delete(); green_mask.delete(); yellow_mask.delete();
                
                let finalScore = 100;
                let diagnosis = "Healthy, Deep Green";
                let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Healthy"));
                
                if (totalAnalyzedPixels > 500) { // Require a minimum number of relevant pixels to analyze
                    const ratio = greenPixels / totalAnalyzedPixels;
                    finalScore = Math.max(10, Math.min(100, Math.round(ratio * 100)));

                    if (ratio < 0.6) {
                        diagnosis = `General Yellowing (Chlorosis)`;
                        prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Yellowing"));
                    } else if (ratio < 0.8) {
                        diagnosis = `Mild Chlorosis`;
                    }
                } else {
                    // Not enough foliage to analyze, default to neutral
                    finalScore = 80;
                    diagnosis = "Neutral (Low Relevant Pixel Count)";
                }
                
                resolve({ score: finalScore, diagnosis: diagnosis, prediction: prediction });
            } catch (e) {
                console.error("OpenCV Analysis Error:", e);
                // Fallback to critical error state if CV crashes
                resolve({ score: 5, diagnosis: "CV Library Error during processing.", prediction: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Mottling")) });
            }
        };
        img.onerror = function() {
            resolve({ score: 5, diagnosis: "CV Image Load Error.", prediction: TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Mottling")) });
        }
        // Start loading the image
        img.src = base64Image;
    });
}
// --- END NEW CLASSICAL CV ANALYSIS FUNCTION ---

async function getPhotoPrediction(base64Image) {
    if (base64Image.includes('mocked_stock_photo_hash') || base64Image.includes('mocked_rover_capture_zone')) {
        // MOCK PATH: Retains the original hash-based deterministic diagnosis for stock photos
        const mockMatch = base64Image.match(/diag:([a-zA-Z_]+)/);
        const mockDiseaseName = mockMatch ? mockMatch[1].replace(/_/g, ' ') : "Healthy, Deep Green";

        let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes(mockDiseaseName.split('(')[0].trim())) || TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS[4];
        
        const mockScore = 100 - prediction.severity; // Score is inversely proportional to severity
        
        return {
            score: mockScore,
            diagnosis: prediction.name,
            prediction: prediction
        };

    } else {
        // ACTUAL CV PATH: Used for user-uploaded photos
        return await getCVAnalysis(base64Image);
    }
}

async function renderStockImageGrid() {
const grid = document.getElementById('stockImageGrid');
grid.innerHTML = '<div>Loading Stock Images...</div>'; // Loading message

// Create an array of promises for stock photo analysis (using the MAX_STOCK_PHOTOS limit)
const analysisPromises = [];
for (let i = 1; i <= MAX_STOCK_PHOTOS; i++) {
    const base64Image = stockPhotoData[i];
    analysisPromises.push(getPhotoPrediction(base64Image));
}

const results = await Promise.all(analysisPromises);
grid.innerHTML = ''; // Clear loading message

for (let i = 1; i <= MAX_STOCK_PHOTOS; i++) {
    const base64Image = stockPhotoData[i];
    const result = results[i-1];

    const cell = document.createElement('div');
    cell.className = 'grid-cell';
    cell.style.maxWidth = '150px';
    cell.style.aspectRatio = '1/1';

    const img = document.createElement('img');
    img.src = base64Image;
    img.className = 'cell-photo';

    const label = document.createElement('div');
    label.style.position = 'absolute';
    label.style.bottom = '0';
    label.style.backgroundColor = 'rgba(0,0,0,0.7)';
    label.style.color = 'white';
    label.style.padding = '5px';
    label.style.fontSize = '10px';
    label.innerText = `ID ${i}: ${result.prediction.name.split('(')[0].trim()}`;
    cell.appendChild(img);
    cell.appendChild(label);
    cell.onclick = () => assignStockPhotoToZone(i);
    grid.appendChild(cell);
}
}
function assignStockPhotoToZone(stockId) {
if (selectedZone === 0) {
STATUS_ELEMENT.innerText = "ERROR: Please click a zone (1-16) in the main grid first, then select a stock photo.";
return;
}
const base64Image = stockPhotoData[stockId];
photoData[selectedZone] = base64Image;
renderPhotoInCell(selectedZone, base64Image);
STATUS_ELEMENT.innerText = `Stock Photo ID ${stockId} assigned to Zone ${selectedZone}.`;
closeStockImageModal();
selectedZone = 0;
fetchAIResults(); // Re-run analysis
}
function deletePhoto(zoneId) {
if (!photoData[zoneId]) return;
delete photoData[zoneId];
renderPhotoInCell(zoneId, null);
STATUS_ELEMENT.innerText = `Photo deleted from Zone ${zoneId}.`;
fetchAIResults(); // Re-run analysis
}
function generatePhotoGrid() {
const grid = document.getElementById('photoGrid');
for (let i = 1; i <= 16; i++) {
const cell = document.createElement('div');
cell.className = 'grid-cell';
cell.id = 'zone-' + i;
cell.innerHTML = `
<span class="cell-label">${i}</span>
<button class="delete-photo-btn" onclick="event.stopPropagation(); deletePhoto(${i})">X</button>
`;
cell.addEventListener('click', function(e) {
if (e.target.className !== 'delete-photo-btn') {
selectedZone = i;
document.getElementById('fileInput').click();
}
});
grid.appendChild(cell);
}
loadCurrentPhotoData();
}
function handleFileSelect(event) {
const file = event.target.files[0];
if (!file || selectedZone === 0) return;
const reader = new FileReader();
reader.onload = function(e) {
const base64Image = e.target.result;
photoData[selectedZone] = base64Image;
renderPhotoInCell(selectedZone, base64Image);
selectedZone = 0;

event.target.value = '';

fetchAIResults(); // Re-run analysis with the new photo
};
reader.readAsDataURL(file);
}
function renderPhotoInCell(zoneId, base64Image) {
const cell = document.getElementById('zone-' + zoneId);
if (!cell) return;
const existingPhoto = cell.querySelector('.cell-photo');
if (existingPhoto) existingPhoto.remove();
if (base64Image) {
const img = document.createElement('img');
img.src = base64Image;
img.className = 'cell-photo';
cell.appendChild(img);
}
}
function clearPhotoGrid() {
for (let i = 1; i <= 16; i++) {
renderPhotoInCell(i, null);
}
}
function loadCurrentPhotoData() {
clearPhotoGrid();
for (const [zoneId, base64Image] of Object.entries(photoData)) {
renderPhotoInCell(parseInt(zoneId), base64Image);
}
}
// ------------------------------------
// --- COMBINED AI ANALYSIS LOGIC (CRITICAL FUSION) ---
// ------------------------------------
function getNearestSensorData(plantX, plantY) {
let nearestData = null;
let min_dist_sq = Infinity;
loggedData.forEach(data => {
let dx = data.x_m - plantX;
let dy = data.y_m - plantY;
let dist_sq = dx * dx + dy * dy;
// Search radius: 0.707m (center of one grid to the edge of the next)
if (dist_sq < 0.707 * 0.707 && dist_sq < min_dist_sq) {
min_dist_sq = dist_sq;
nearestData = data;
}
});
return nearestData;
}

function analyzePlant(plant, sensorData, visualResult) {
let soilScore = 100;
let soilProblems = [];
let sensorDiagnosis = "Soil: Sensor Data Missing (Cannot Analyze)";

// --- 1. Sensor Data Analysis ---
if (sensorData) {
const { moisture, npk_n, npk_p, npk_k } = sensorData;
const data = { moisture, N: npk_n, P: npk_p, K: npk_k };
const keys = ['moisture', 'N', 'P', 'K'];
keys.forEach(key => {
const guideline = TOMATO_DIAGNOSTIC_LIBRARY.NPK_GUIDELINES[key];
const value = data[key];
let problem = '';

if (value < guideline.low_crit) {
soilScore -= guideline.penalty_major;
problem = `CRITICAL LOW ${key}`;
} else if (value < guideline.ideal_min) {
soilScore -= guideline.penalty_minor;
problem = `LOW ${key}`;
} else if (value > guideline.high_crit) {
soilScore -= guideline.penalty_major;
problem = `CRITICAL HIGH ${key}`;
} else if (value > guideline.ideal_max) {
soilScore -= guideline.penalty_minor;
problem = `HIGH ${key}`;
}

if (problem) {
let rec = (problem.includes('CRITICAL') ? "Urgent " : "") +
(value < guideline.low_crit ? guideline.low_rec : guideline.high_rec);

soilProblems.push({ key, value, problem, rec });
}
});
sensorDiagnosis = `Soil: M=${moisture}%, NPK=${npk_n}/${npk_p}/${npk_k}`;
} else {
// Data Missing scenario
return {
id: plant.id,
score: 20,
visualDiagnosis: "Visual: N/A (Data Missing)",
sensorDiagnosis: sensorDiagnosis,
recommendation: "CRITICAL ERROR: DATA GAP. Conduct soil probe at Zone " + plant.id + " immediately to enable fused analysis.",
healthClass: 'rec-critical'
};
}

// --- 2. Photo Analysis (CV or Mock Lookup) ---
let visualDiagnosis = "Visual: No Photo Taken";
let prediction = TOMATO_DIAGNOSTIC_LIBRARY.DISEASE_TIERS.find(d => d.name.includes("Healthy"));
let visualScore = 100;
let finalRecommendation = '';
let healthClass = 'rec-optimal';

if (visualResult) {
    prediction = visualResult.prediction;
    visualScore = visualResult.score;
    // Updated visualDiagnosis to include the score for partial analysis clarity
    visualDiagnosis = `Visual: ${visualResult.diagnosis} (Score: ${visualScore}%)`;

    // Apply the visual score (from CV/Mock) as a penalty to the soil score
    // Lower score means higher penalty. Penalty maxes out at 90.
    const visualPenalty = 100 - visualScore;
    soilScore = Math.max(0, soilScore - (visualPenalty * 0.4)); // 40% penalty integration
}

// --- 3. Fused Diagnosis (Tiers 1-7) ---
// Convenience lookups (Based on prediction name, which comes from Mock or CV)
const isYellow = prediction.name.includes('Yellowing') || visualDiagnosis.includes('Chlorosis');
const isLesions = prediction.name.includes('Dark Spots');
const isMottling = prediction.name.includes('Mottling');
const isWilting = prediction.name.includes('Leaf Curl');
const isLowN = soilProblems.some(p => p.problem.includes('CRITICAL LOW N'));
const isLowK = soilProblems.some(p => p.problem.includes('CRITICAL LOW K'));
const isCritMoisture = soilProblems.some(p => p.problem.includes('CRITICAL LOW moisture') || p.problem.includes('CRITICAL HIGH moisture'));


// TIER 1: INCURABLE PATHOGEN OVERRIDE
if (isMottling || isWilting) {
finalRecommendation = prediction.recommendation; // Use the fixed viral recommendation
healthClass = prediction.class;
soilScore = 5; // Force minimum score
}
// TIER 2: FUNGUS/BACTERIA OVERRIDE
else if (isLesions) {
finalRecommendation = prediction.recommendation; // Use the fixed fungal recommendation
healthClass = prediction.class;
soilScore = Math.min(25, soilScore); // Penalize severely
}
// TIER 3: CRITICAL MOISTURE STRESS
else if (isCritMoisture) {
const critMoisture = soilProblems.find(p => p.problem.includes('CRITICAL'));
finalRecommendation = `CRITICAL WATER STRESS: ${critMoisture.problem} (${critMoisture.value}%). Action: ${critMoisture.rec}.`;
healthClass = 'rec-critical';
soilScore = Math.min(35, soilScore);
}
// TIER 4: N-DEFICIENCY CONFIRMATION (Visual + Soil)
else if (isYellow && isLowN) {
const critN = soilProblems.find(p => p.key === 'N');
finalRecommendation = `CONFIRMED N-DEFICIENCY: Yellowing is caused by ${critN.problem} (${critN.value} ppm). Action: Apply ${critN.rec}.`;
healthClass = 'rec-action'; // Usually action, not critical, unless growth is severely stunted.
}
// TIER 5: SECONDARY DEFICIENCY INFERENCE
else if (isYellow && isLowK) {
const critK = soilProblems.find(p => p.key === 'K');
finalRecommendation = `INFERENCE: Yellowing present. Low Potassium (${critK.value} ppm) suggests K-deficiency. Action: Supplement Potassium to boost resistance/fruit health.`;
healthClass = 'rec-action';
}
// TIER 6: SOIL PROBLEMS ONLY (No Major Visual)
else if (soilProblems.length > 0) {
const problemString = soilProblems.map(p => `${p.problem} (${p.value}%)`).join(', ');
const recString = soilProblems.map(p => p.rec).join('; ');

finalRecommendation = `CAUTION: Soil Imbalance Detected: ${problemString}. Recommended action: ${recString}`;
healthClass = soilScore <= 60 ? 'rec-action' : 'rec-optimal';
}
// TIER 7: OPTIMAL
else {
finalRecommendation = prediction.recommendation; // "Optimal: Continue monitoring"
healthClass = prediction.class;
}

// Final Score Calculation (The final soilScore is already the fused score)
const finalScore = Math.round(soilScore);

return {
id: plant.id,
score: finalScore.toFixed(0),
visualDiagnosis: visualDiagnosis,
sensorDiagnosis: sensorDiagnosis,
recommendation: finalRecommendation.trim(),
healthClass: healthClass
};
}

// --- ASYNC AI Analysis function ---
async function fetchAIResults() {
const analysisGrid = document.getElementById('plantAnalysisGrid');
analysisGrid.innerHTML = '<h2>Running Fused Analysis... This may take a moment for CV processing.</h2>';

// Create an array of promises for concurrent analysis
const analysisPromises = PLANT_LOCATIONS_M.map(async plant => {
    const sensorData = getNearestSensorData(plant.x, plant.y);
    const photoExists = !!photoData[plant.id];
    
    let visualResult = null;
    if (photoExists) {
        visualResult = await getPhotoPrediction(photoData[plant.id]); // Wait for photo analysis
    }
    
    return analyzePlant(plant, sensorData, visualResult); // Fused analysis
});

const analyses = await Promise.all(analysisPromises); // Wait for all analyses to complete

analysisGrid.innerHTML = ''; // Clear status message

analyses.forEach(analysis => {
    const recLabel = analysis.recommendation;
    const card = `
    <div class="analysis-card">
    <div class="plant-id-label">Zone ${analysis.id} (P${Math.ceil(analysis.id/4)}R${(analysis.id-1)%4 + 1})</div>
    <div class="analysis-row">
    <strong>Composite Score:</strong> <span class="status-good">${analysis.score}/100</span>
    </div>
    <div class="analysis-row">
    <strong>Leaf Analysis:</strong> ${analysis.visualDiagnosis}
    </div>
    <div class="analysis-row">
    <strong>Soil Analysis:</strong> ${analysis.sensorDiagnosis}
    </div>
    <div class="analysis-row" style="margin-top: 10px;">
    <strong>Recommendation:</strong> <span class="${analysis.healthClass}">${recLabel}</span>
    </div>
    </div>
    `;
    analysisGrid.insertAdjacentHTML('beforeend', card);
});

STATUS_ELEMENT.innerText = `AI Analysis Complete: ${PLANT_LOCATIONS_M.length} plants analyzed.`;
}
// ------------------------------------
// --- COMMUNICATION, MAP, AND HISTORY FUNCTIONS (Minor Changes) ---
// ------------------------------------
function sendCommand(command) {
let url = (command === 'capture') ? `${ESP32_URL_BASE}/capture` : `${ESP32_URL_BASE}/move?dir=${command}`;
STATUS_ELEMENT.innerText = `Sending command: ${command}...`;
fetch(url)
.then(response => {
if (!response.ok) { throw new Error(`HTTP Error: ${response.status}`); }
return response.text();
})
.then(data => {
STATUS_ELEMENT.innerText = `Command '${command}' Success.`;
if (command.startsWith('read_') || command === 'probe') {
setTimeout(() => fetchData(command), 500);
} else if (command === 'capture') {
LAST_PHOTO_STATUS.innerText = 'Photo captured and sent to server.';
const nearestPlant = getNearestPlant(currentRoverData.x_m, currentRoverData.y_m);
if (nearestPlant) {
// Mock capture creates a unique hash for consistency, which is then analyzed by the CV logic
photoData[nearestPlant.id] = `data:image/jpeg;base64,mocked_rover_capture_zone_${nearestPlant.id}_diag:Healthy_Deep_Green`;
renderPhotoInCell(nearestPlant.id, photoData[nearestPlant.id]);
}
setTimeout(() => fetchAIResults(), 1000); // Re-run analysis
}
})
.catch(error => {
STATUS_ELEMENT.innerText = `ERROR: Command ${command} failed. Is ESP32 at ${ESP32_IP} online?`;
console.error('Error sending command:', error);
});
}
function getNearestPlant(x, y) {
let nearest = null;
let minDistSq = Infinity;
PLANT_LOCATIONS_M.forEach(plant => {
let dx = plant.x - x;
let dy = plant.y - y;
let distSq = dx * dx + dy * dy;
if (distSq < minDistSq) {
minDistSq = distSq;
nearest = plant;
}
});
return nearest;
}
function fetchData(lastCommand = null) {
STATUS_ELEMENT.innerText = "Fetching latest data...";
setTimeout(() => {
// --- Simulate GPS/Nav Data ---
let headingStr = (Math.random() * 360).toFixed(1) + ' deg';
currentRoverData.heading = parseFloat(headingStr.split(' ')[0]) || 0;
currentRoverData.latitude = "40.7128";
currentRoverData.longitude = "-74.0060";
document.getElementById('latitudeData').innerText = currentRoverData.latitude;
document.getElementById('longitudeData').innerText = currentRoverData.longitude;
document.getElementById('gpsFix').innerText = "3D Fix";
document.getElementById('headingData').innerText = headingStr;
if (lastCommand !== 'read_nav' && lastCommand !== 'stop') {
currentRoverData.x_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.x_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
currentRoverData.y_m = Math.min(FIELD_SIZE, Math.max(0, parseFloat(currentRoverData.y_m) + (Math.random() - 0.5) * 0.1)).toFixed(2);
}
// --- Simulate Soil Data ---
let moistureVal = (Math.random() * 80 + 10).toFixed(1);
let npk_n = Math.floor(Math.random() * 100);
let npk_p = Math.floor(Math.random() * 100);
let npk_k = Math.floor(Math.random() * 100);
let moistureStr = moistureVal + '%';
let npkStr = `N:${npk_n}, P:${npk_p}, K:${npk_k}`;
document.getElementById('moistureData').innerText = moistureStr;
document.getElementById('npkData').innerText = npkStr;
if (lastCommand === 'probe' || lastCommand === 'read_sensors') {
let healthStatus = analyzeHealth(parseFloat(moistureVal), npk_n, npk_p, npk_k);

loggedData.push({
x_m: parseFloat(currentRoverData.x_m),
y_m: parseFloat(currentRoverData.y_m),
healthStatus: healthStatus,
moisture: parseFloat(moistureVal),
npk_n: npk_n, npk_p: npk_p, npk_k: npk_k
});
STATUS_ELEMENT.innerText = `Data logged! Status: ${healthStatus}`;
fetchAIResults();
}
drawMap();
draw3DMap();
STATUS_ELEMENT.innerText = "Data update complete.";
}, 500);
}
function analyzeHealth(moisture, npk_n, npk_p, npk_k) {
let issues = 0;
const MIN_MOISTURE = 30;
const IDEAL_NPK_SUM = 150;
const NPK_TOLERANCE = 50;
if (moisture < MIN_MOISTURE || moisture > 80) { issues++; }
let npk_sum = npk_n + npk_p + npk_k;
if (Math.abs(npk_sum - IDEAL_NPK_SUM) > NPK_TOLERANCE) { issues++; }
if (issues >= 2) return 'Bad';
if (issues === 1) return 'Caution';
return 'Good';
}
function clearMapData(resetRover = true) {
loggedData = [];
photoData = {};
if (resetRover) {
currentRoverData.x_m = 2.0;
currentRoverData.y_m = 2.0;
currentRoverData.heading = 0;
}
drawMap();
draw3DMap();
clearPhotoGrid();
fetchAIResults();
STATUS_ELEMENT.innerText = "Map and photo data cleared.";
}
function drawMap() {
CTX.clearRect(0, 0, MAP_SIZE, MAP_SIZE);
CTX.strokeStyle = '#5a5a5a';
CTX.lineWidth = 1;
for (let i = 1; i < FIELD_SIZE; i++) {
let px = i * PIXELS_PER_METER;
CTX.beginPath(); CTX.moveTo(px, 0); CTX.lineTo(px, MAP_SIZE); CTX.stroke();
CTX.beginPath(); CTX.moveTo(0, px); CTX.lineTo(MAP_SIZE, px); CTX.stroke();
}

const GRID_SIZE_M = 1.0;
for (let row = 0; row < FIELD_SIZE; row++) {
for (let col = 0; col < FIELD_SIZE; col++) {
let center_x_m = col * GRID_SIZE_M + 0.5;
let center_y_m = row * GRID_SIZE_M + 0.5;
let nearestData = getNearestSensorData(center_x_m, center_y_m);
if (nearestData) {
let moistureColor;
if (nearestData.moisture < 20) { moistureColor = '#0070e040'; }
else if (nearestData.moisture > 70) { moistureColor = '#80008040'; }
else { moistureColor = '#6a995540'; }
CTX.fillStyle = moistureColor;
CTX.fillRect(
col * PIXELS_PER_METER,
MAP_SIZE - ((row + 1) * PIXELS_PER_METER),
PIXELS_PER_METER,
PIXELS_PER_METER
);
}
}
}
PLANT_LOCATIONS_M.forEach((plant, index) => {
let px = plant.x * PIXELS_PER_METER;
let py = MAP_SIZE - (plant.y * PIXELS_PER_METER);
let nearestData = getNearestSensorData(plant.x, plant.y);
let plantColor = nearestData ? getHealthColor(nearestData.healthStatus) : '#5a5a5a';
CTX.fillStyle = plantColor;
CTX.beginPath();
CTX.arc(px, py, 6, 0, 2 * Math.PI);
CTX.fill();
if (nearestData && nearestData.healthStatus) {
CTX.fillStyle = 'white';
CTX.font = '10px Arial';
CTX.fillText(nearestData.healthStatus.charAt(0), px - 3, py + 3);
}
});
let rover_x_px = currentRoverData.x_m * PIXELS_PER_METER;
let rover_y_px = MAP_SIZE - (currentRoverData.y_m * PIXELS_PER_METER);
let heading_rad = (currentRoverData.heading - 90) * (Math.PI / 180);
CTX.fillStyle = '#9cdcfe';
CTX.save();
CTX.translate(rover_x_px, rover_y_px);
CTX.rotate(heading_rad);
CTX.beginPath();
CTX.moveTo(10, 0);
CTX.lineTo(-10, -8);
CTX.lineTo(-10, 8);
CTX.closePath();
CTX.fill();
CTX.restore();
CTX.fillStyle = 'white';
CTX.beginPath();
CTX.arc(rover_x_px, rover_y_px, 3, 0, 2 * Math.PI);
CTX.fill();
}
function getHealthColor(status) {
switch (status) {
case 'Good': return '#28a745';
case 'Caution': return '#ffc107';
case 'Bad': return '#dc3545';
default: return '#5a5a5a';
}
}
// ------------------------------------
// --- HISTORY & DATA SAVING FUNCTIONS ---
// ------------------------------------
function saveCurrentTrial() {
populateStockPhotos();
const trialData = {
id: currentTrialNumber,
date: new Date().toLocaleString(),
roverData: { ...currentRoverData },
loggedData: [...loggedData],
photoData: { ...photoData },
stockPhotoData: { ...stockPhotoData },
aiData: {
// Only save the current state of the analysis grid HTML for easy recall
analysisGrid: document.getElementById('plantAnalysisGrid').innerHTML
}
};
// Check if the history length exceeds 50 and trim the oldest if necessary
if (trialHistory.length >= 50) {
    trialHistory.shift(); 
}

trialHistory.push(trialData);
localStorage.setItem('trialHistory', JSON.stringify(trialHistory));
STATUS_ELEMENT.innerText = `Trial ${currentTrialNumber} saved successfully! Starting new trial...`;
loggedData = [];
photoData = {};
currentTrialNumber++;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
clearMapData(false);
clearPhotoGrid();
clear3DDataCubes();
fetchAIResults();
updateRover3DPosition();
}
function openHistoryModal() {
const modal = document.getElementById('historyModal');
const list = document.getElementById('trialHistoryList');
list.innerHTML = '';
if (trialHistory.length === 0) {
list.innerHTML = '<p>No trials saved yet.</p>';
} else {
    // Display last 50, but sort by descending ID
    const sortedHistory = trialHistory.slice().sort((a, b) => b.id - a.id);
    
    sortedHistory.forEach(trial => {
        const item = document.createElement('div');
        item.className = 'trial-item';
        item.innerHTML = `<strong>Trial ${trial.id}:</strong> ${trial.date} (${trial.loggedData.length} sensor readings, ${Object.keys(trial.photoData).length} photos)`;
        item.onclick = () => loadPastTrial(trial.id);
        list.appendChild(item);
    });
}
modal.style.display = "block";
}
function closeHistoryModal() {
document.getElementById('historyModal').style.display = "none";
}
function loadPastTrial(trialId) {
const trial = trialHistory.find(t => t.id === trialId);
if (!trial) return;

// Load all trial data for full history context
currentRoverData = trial.roverData;
loggedData = trial.loggedData;
photoData = trial.photoData;
stockPhotoData = trial.stockPhotoData || {};

// Update Control Panel Data
document.getElementById('latitudeData').innerText = trial.roverData.latitude;
document.getElementById('longitudeData').innerText = trial.roverData.longitude;
document.getElementById('headingData').innerText = trial.roverData.heading + ' deg';
document.getElementById('gpsFix').innerText = 'Historical';

// Update Visuals
drawMap();
draw3DMap();
loadCurrentPhotoData();

// Update Analysis Grid
document.getElementById('plantAnalysisGrid').innerHTML = trial.aiData.analysisGrid;

STATUS_ELEMENT.innerText = `Loaded data for Trial ${trialId}.`;
document.getElementById('currentTrialNumber').innerText = `${currentTrialNumber} (VIEWING PAST TRIAL ${trialId})`;
closeHistoryModal();
}
function clearAllHistory() {
if (confirm("Are you sure you want to clear ALL saved trial history? This cannot be undone.")) {
localStorage.removeItem('trialHistory');
trialHistory = [];
currentTrialNumber = 1;
document.getElementById('currentTrialNumber').innerText = currentTrialNumber;
closeHistoryModal();
STATUS_ELEMENT.innerText = "All trial history cleared.";
}
}
// --- Initialization ---
window.onload = function() {
initThreeD();
drawMap();
generatePhotoGrid();
populateStockPhotos(); 
fetchAIResults();
};
</script>
</body>
</html>
